/*
* generated by Xtext
*/

package org.eclipse.b3.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;

import org.eclipse.xtext.service.GrammarProvider;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class BeeLangGrammarAccess implements IGrammarAccess {
	
	
	public class BeeModelElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BeeModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyUnitParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//BeeModel:
		//  imports+=Import* body=Unit; 
		//                
		//
		//// Redeclare the default ID without the ^ keyword escape mechanism, and including
		//// the JS $ char which is allowed in the first position.
		////
		public ParserRule getRule() { return rule; }

		//imports+=Import* body=Unit
		public Group getGroup() { return cGroup; }

		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }

		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }

		//body=Unit
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//Unit
		public RuleCall getBodyUnitParserRuleCall_1_0() { return cBodyUnitParserRuleCall_1_0; }
	}

	public class QualifiedNameElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Alternatives cAlternatives_2_2 = (Alternatives)cGroup_2.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_2_2_0 = (RuleCall)cAlternatives_2_2.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_2_2_1 = (RuleCall)cAlternatives_2_2.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_2_2_2 = (RuleCall)cAlternatives_2_2.eContents().get(2);
		private final RuleCall cHIDDENBUGParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//QualifiedName returns ecore::EString hidden ( ):
		//  ID (INT|HEX|ID)* ("." ID (INT|HEX|ID)*)* HIDDENBUG; 
		//
		//// Qualified name
		//// TODO: Needs to disallow whie space between ID and '.', and no embedded comments. A bug in xtext prevents using hidden() here.
		////
		public ParserRule getRule() { return rule; }

		//ID (INT|HEX|ID)* ("." ID (INT|HEX|ID)*)* HIDDENBUG
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//(INT|HEX|ID)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_0() { return cINTTerminalRuleCall_1_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1_1() { return cHEXTerminalRuleCall_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_2() { return cIDTerminalRuleCall_1_2; }

		//("." ID (INT|HEX|ID)*)*
		public Group getGroup_2() { return cGroup_2; }

		//"."
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_2_1() { return cIDTerminalRuleCall_2_1; }

		//(INT|HEX|ID)*
		public Alternatives getAlternatives_2_2() { return cAlternatives_2_2; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_2_0() { return cINTTerminalRuleCall_2_2_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_2_2_1() { return cHEXTerminalRuleCall_2_2_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_2_2_2() { return cIDTerminalRuleCall_2_2_2; }

		//HIDDENBUG
		public RuleCall getHIDDENBUGParserRuleCall_3() { return cHIDDENBUGParserRuleCall_3; }
	}

	public class HIDDENBUGElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HIDDENBUG");
		private final Keyword cTildeTildeTildeTildeTildeKeyword = (Keyword)rule.eContents().get(1);
		
		//HIDDENBUG returns ecore::EString hidden ( WS , SL_COMMENT , ML_COMMENT ):
		//  "~~~~~"?; 
		//            // TODO: REPLACE HACK WHEN HIDDEN WORKS.
		//
		//
		//// Declare Property ID to include '.'
		public ParserRule getRule() { return rule; }

		//"~~~~~"?
		public Keyword getTildeTildeTildeTildeTildeKeyword() { return cTildeTildeTildeTildeTildeKeyword; }
	}

	public class PROPElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PROP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDollarSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PROP returns ecore::EString hidden ( ):
		//  "$" "{" QualifiedName "}";   // TODO: REPLACE HACK WHEN HIDDEN WORKS.
		//
		//
		//// Declare Property ID to include '.'
		public ParserRule getRule() { return rule; }

		//"$" "{" QualifiedName "}"
		public Group getGroup() { return cGroup; }

		//"$"
		public Keyword getDollarSignKeyword_0() { return cDollarSignKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_2() { return cQualifiedNameParserRuleCall_2; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class PropertyNameElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyName");
		private final RuleCall cPIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PropertyName returns ecore::EString:
		//  PID;
		public ParserRule getRule() { return rule; }

		//PID
		public RuleCall getPIDTerminalRuleCall() { return cPIDTerminalRuleCall; }
	}

	public class EscapedQualifiedNameElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EscapedQualifiedName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQualifiedNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EscapedQualifiedName returns ecore::EString:
		//  STRING|QualifiedName;
		public ParserRule getRule() { return rule; }

		//STRING|QualifiedName
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_1() { return cQualifiedNameParserRuleCall_1; }
	}

	public class InterfaceNameElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InterfaceName");
		private final RuleCall cQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//InterfaceName returns ecore::EString:
		//  QualifiedName; 
		//    
		//
		//// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
		//// do not allow being broken across lines.
		////
		public ParserRule getRule() { return rule; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall() { return cQualifiedNameParserRuleCall; }
	}

	public class CompoundNameElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEscapedQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cEscapedQualifiedNameParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//CompoundName returns ecore::EString:
		//  EscapedQualifiedName "/" EscapedQualifiedName; 
		//
		//// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
		//// do not allow being broken across lines.
		////
		//          
		//
		//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
		public ParserRule getRule() { return rule; }

		//EscapedQualifiedName "/" EscapedQualifiedName
		public Group getGroup() { return cGroup; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall_0() { return cEscapedQualifiedNameParserRuleCall_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall_2() { return cEscapedQualifiedNameParserRuleCall_2; }
	}

	public class UnitNameElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitName");
		private final RuleCall cEscapedQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//UnitName returns ecore::EString:
		//  EscapedQualifiedName; 
		//
		//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
		public ParserRule getRule() { return rule; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall() { return cEscapedQualifiedNameParserRuleCall; }
	}

	public class PartNameElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PartName");
		private final RuleCall cEscapedQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PartName returns ecore::EString:
		//  EscapedQualifiedName;
		public ParserRule getRule() { return rule; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall() { return cEscapedQualifiedNameParserRuleCall; }
	}

	public class SeparatorElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Separator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cCommercialAtKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDollarSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cPercentSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cAmpersandKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cPlusSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cEqualsSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cAsteriskKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cLessThanSignKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cGreaterThanSignKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cColonKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cQuestionMarkKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		
		//Separator returns ecore::EString:
		//  "."|"-"|"!"|"@"|"$"|"%"|"&"|"+"|"="|"*"|"<"|">"|":"|"?"; 
		//
		//// Version, and VersionRange
		//// TODO: make it into a datatype and have better rules, syntax coloring (now integer parts are colored grey, other parts are not colored), etc.
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public ParserRule getRule() { return rule; }

		//"."|"-"|"!"|"@"|"$"|"%"|"&"|"+"|"="|"*"|"<"|">"|":"|"?" 
		//
		//// Version, and VersionRange
		//// TODO: make it into a datatype and have better rules, syntax coloring (now integer parts are colored grey, other parts are not colored), etc.
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public Alternatives getAlternatives() { return cAlternatives; }

		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }

		//"!"
		public Keyword getExclamationMarkKeyword_2() { return cExclamationMarkKeyword_2; }

		//"@"
		public Keyword getCommercialAtKeyword_3() { return cCommercialAtKeyword_3; }

		//"$"
		public Keyword getDollarSignKeyword_4() { return cDollarSignKeyword_4; }

		//"%"
		public Keyword getPercentSignKeyword_5() { return cPercentSignKeyword_5; }

		//"&"
		public Keyword getAmpersandKeyword_6() { return cAmpersandKeyword_6; }

		//"+"
		public Keyword getPlusSignKeyword_7() { return cPlusSignKeyword_7; }

		//"="
		public Keyword getEqualsSignKeyword_8() { return cEqualsSignKeyword_8; }

		//"*"
		public Keyword getAsteriskKeyword_9() { return cAsteriskKeyword_9; }

		//"<"
		public Keyword getLessThanSignKeyword_10() { return cLessThanSignKeyword_10; }

		//">"
		public Keyword getGreaterThanSignKeyword_11() { return cGreaterThanSignKeyword_11; }

		//":"
		public Keyword getColonKeyword_12() { return cColonKeyword_12; }

		//"?"
		public Keyword getQuestionMarkKeyword_13() { return cQuestionMarkKeyword_13; }
	}

	public class AlfanumSymElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AlfanumSym");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cHEXTerminalRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cREALTerminalRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cSeparatorParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final RuleCall cHEXTerminalRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		private final RuleCall cREALTerminalRuleCall_1_4 = (RuleCall)cAlternatives_1.eContents().get(4);
		
		//AlfanumSym returns ecore::EString:
		//  (ID|INT|HEX|REAL) (Separator|ID|INT|HEX|REAL)*;
		public ParserRule getRule() { return rule; }

		//(ID|INT|HEX|REAL) (Separator|ID|INT|HEX|REAL)*
		public Group getGroup() { return cGroup; }

		//ID|INT|HEX|REAL
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_0_0() { return cIDTerminalRuleCall_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1() { return cINTTerminalRuleCall_0_1; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_0_2() { return cHEXTerminalRuleCall_0_2; }

		//REAL
		public RuleCall getREALTerminalRuleCall_0_3() { return cREALTerminalRuleCall_0_3; }

		//(Separator|ID|INT|HEX|REAL)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//Separator
		public RuleCall getSeparatorParserRuleCall_1_0() { return cSeparatorParserRuleCall_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_2() { return cINTTerminalRuleCall_1_2; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1_3() { return cHEXTerminalRuleCall_1_3; }

		//REAL
		public RuleCall getREALTerminalRuleCall_1_4() { return cREALTerminalRuleCall_1_4; }
	}

	public class VersionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Version");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAlfanumSymParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Version returns ecore::EString:
		//  STRING|AlfanumSym; 
		//
		//
		//	    
		//	  
		//	
		//
		/// *
		// ** VersionRange TODO: Uses two instances of Version. This works because use of [ ]  ( ) in Version must be 
		// ** escaped with " ". Omni
		// ** version uses version strings with \[ when a range is presented/parsed in string format.
		// * /
		public ParserRule getRule() { return rule; }

		//STRING|AlfanumSym 
		//
		//
		//	    
		//	  
		//	
		//
		/// *
		// ** VersionRange TODO: Uses two instances of Version. This works because use of [ ]  ( ) in Version must be 
		// ** escaped with " ". Omni
		// ** version uses version strings with \[ when a range is presented/parsed in string format.
		// * /
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//AlfanumSym
		public RuleCall getAlfanumSymParserRuleCall_1() { return cAlfanumSymParserRuleCall_1; }
	}

	public class VersionRangeElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VersionRange");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final RuleCall cVersionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final RuleCall cVersionParserRuleCall_0_2_1 = (RuleCall)cGroup_0_2.eContents().get(1);
		private final Alternatives cAlternatives_0_3 = (Alternatives)cGroup_0.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_0_3_0 = (Keyword)cAlternatives_0_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_3_1 = (Keyword)cAlternatives_0_3.eContents().get(1);
		private final RuleCall cVersionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//VersionRange returns ecore::EString:
		//  ("["|"(") Version ("," Version)? ("]"|")")|Version; 
		//
		/// *
		// ** VersionRange TODO: Uses two instances of Version. This works because use of [ ]  ( ) in Version must be 
		// ** escaped with " ". Omni
		// ** version uses version strings with \[ when a range is presented/parsed in string format.
		// * /
		//
		//	              
		//	  
		//	
		//
		/// *
		// ** Import
		// ** TODO: Is specified as import of URI, a String, should be QID
		// * /
		public ParserRule getRule() { return rule; }

		//("["|"(") Version ("," Version)? ("]"|")")|Version 
		//
		/// *
		// ** VersionRange TODO: Uses two instances of Version. This works because use of [ ]  ( ) in Version must be 
		// ** escaped with " ". Omni
		// ** version uses version strings with \[ when a range is presented/parsed in string format.
		// * /
		//
		//	              
		//	  
		//	
		//
		/// *
		// ** Import
		// ** TODO: Is specified as import of URI, a String, should be QID
		// * /
		public Alternatives getAlternatives() { return cAlternatives; }

		//("["|"(") Version ("," Version)? ("]"|")")
		public Group getGroup_0() { return cGroup_0; }

		//"["|"("
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_0_0() { return cLeftSquareBracketKeyword_0_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0_1() { return cLeftParenthesisKeyword_0_0_1; }

		//Version
		public RuleCall getVersionParserRuleCall_0_1() { return cVersionParserRuleCall_0_1; }

		//("," Version)?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//","
		public Keyword getCommaKeyword_0_2_0() { return cCommaKeyword_0_2_0; }

		//Version
		public RuleCall getVersionParserRuleCall_0_2_1() { return cVersionParserRuleCall_0_2_1; }

		//"]"|")"
		public Alternatives getAlternatives_0_3() { return cAlternatives_0_3; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_3_0() { return cRightSquareBracketKeyword_0_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_3_1() { return cRightParenthesisKeyword_0_3_1; }

		//Version
		public RuleCall getVersionParserRuleCall_1() { return cVersionParserRuleCall_1; }
	}

	public class ImportElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportClassAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportClassQualifiedNameParserRuleCall_1_0 = (RuleCall)cImportClassAssignment_1.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Import:
		//  "import" importClass=QualifiedName ".*"? ";"; 
		//
		/// *
		// ** Import
		// ** TODO: Is specified as import of URI, a String, should be QID
		// * /	
		//  
		//	         
		//		
		/// * UNIT - the body (compare to java class)
		// * /
		public ParserRule getRule() { return rule; }

		//"import" importClass=QualifiedName ".*"? ";"
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importClass=QualifiedName
		public Assignment getImportClassAssignment_1() { return cImportClassAssignment_1; }

		//QualifiedName
		public RuleCall getImportClassQualifiedNameParserRuleCall_1_0() { return cImportClassQualifiedNameParserRuleCall_1_0; }

		//".*"?
		public Keyword getFullStopAsteriskKeyword_2() { return cFullStopAsteriskKeyword_2; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class UnitElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExecutionModeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExecutionModeExecutionModeEnumRuleCall_0_0 = (RuleCall)cExecutionModeAssignment_0.eContents().get(0);
		private final Keyword cUnitKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameUnitNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cVersionKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cVersionAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cVersionVersionParserRuleCall_3_1_0 = (RuleCall)cVersionAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cImplementsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cImplementsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cImplementsInterfaceNameParserRuleCall_4_1_0 = (RuleCall)cImplementsAssignment_4_1.eContents().get(0);
		private final Group cGroup_4_2 = (Group)cGroup_4.eContents().get(2);
		private final Keyword cCommaKeyword_4_2_0 = (Keyword)cGroup_4_2.eContents().get(0);
		private final Assignment cImplementsAssignment_4_2_1 = (Assignment)cGroup_4_2.eContents().get(1);
		private final RuleCall cImplementsInterfaceNameParserRuleCall_4_2_1_0 = (RuleCall)cImplementsAssignment_4_2_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cPropertiesKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cPropertyStatementsAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cPropertyStatementsNamedPropertyStatementsParserRuleCall_6_1_0 = (RuleCall)cPropertyStatementsAssignment_6_1.eContents().get(0);
		private final Alternatives cAlternatives_7 = (Alternatives)cGroup.eContents().get(7);
		private final Group cGroup_7_0 = (Group)cAlternatives_7.eContents().get(0);
		private final Keyword cProvidesKeyword_7_0_0 = (Keyword)cGroup_7_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_7_0_1 = (Keyword)cGroup_7_0.eContents().get(1);
		private final Group cGroup_7_0_2 = (Group)cGroup_7_0.eContents().get(2);
		private final Assignment cProvidedCapabilityAssignment_7_0_2_0 = (Assignment)cGroup_7_0_2.eContents().get(0);
		private final RuleCall cProvidedCapabilityProvidedCapabilityParserRuleCall_7_0_2_0_0 = (RuleCall)cProvidedCapabilityAssignment_7_0_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_7_0_2_1 = (Keyword)cGroup_7_0_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_7_0_3 = (Keyword)cGroup_7_0.eContents().get(3);
		private final Group cGroup_7_1 = (Group)cAlternatives_7.eContents().get(1);
		private final Keyword cProvidesKeyword_7_1_0 = (Keyword)cGroup_7_1.eContents().get(0);
		private final Assignment cProvidedCapabilityAssignment_7_1_1 = (Assignment)cGroup_7_1.eContents().get(1);
		private final RuleCall cProvidedCapabilityProvidedCapabilityParserRuleCall_7_1_1_0 = (RuleCall)cProvidedCapabilityAssignment_7_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_7_1_2 = (Keyword)cGroup_7_1.eContents().get(2);
		private final Group cGroup_7_2 = (Group)cAlternatives_7.eContents().get(2);
		private final Keyword cRequiresKeyword_7_2_0 = (Keyword)cGroup_7_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_7_2_1 = (Keyword)cGroup_7_2.eContents().get(1);
		private final Group cGroup_7_2_2 = (Group)cGroup_7_2.eContents().get(2);
		private final Assignment cRequiredCapabilitiesAssignment_7_2_2_0 = (Assignment)cGroup_7_2_2.eContents().get(0);
		private final RuleCall cRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_2_2_0_0 = (RuleCall)cRequiredCapabilitiesAssignment_7_2_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_7_2_2_1 = (Keyword)cGroup_7_2_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_7_2_3 = (Keyword)cGroup_7_2.eContents().get(3);
		private final Group cGroup_7_3 = (Group)cAlternatives_7.eContents().get(3);
		private final Keyword cRequiresKeyword_7_3_0 = (Keyword)cGroup_7_3.eContents().get(0);
		private final Assignment cRequiredCapabilitiesAssignment_7_3_1 = (Assignment)cGroup_7_3.eContents().get(1);
		private final RuleCall cRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_3_1_0 = (RuleCall)cRequiredCapabilitiesAssignment_7_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_7_3_2 = (Keyword)cGroup_7_3.eContents().get(2);
		private final Group cGroup_7_4 = (Group)cAlternatives_7.eContents().get(4);
		private final Keyword cMetaKeyword_7_4_0 = (Keyword)cGroup_7_4.eContents().get(0);
		private final Keyword cRequiresKeyword_7_4_1 = (Keyword)cGroup_7_4.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_7_4_2 = (Keyword)cGroup_7_4.eContents().get(2);
		private final Group cGroup_7_4_3 = (Group)cGroup_7_4.eContents().get(3);
		private final Assignment cMetaRequiredCapabilitiesAssignment_7_4_3_0 = (Assignment)cGroup_7_4_3.eContents().get(0);
		private final RuleCall cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_4_3_0_0 = (RuleCall)cMetaRequiredCapabilitiesAssignment_7_4_3_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_7_4_3_1 = (Keyword)cGroup_7_4_3.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_7_4_4 = (Keyword)cGroup_7_4.eContents().get(4);
		private final Group cGroup_7_5 = (Group)cAlternatives_7.eContents().get(5);
		private final Keyword cMetaKeyword_7_5_0 = (Keyword)cGroup_7_5.eContents().get(0);
		private final Keyword cRequiresKeyword_7_5_1 = (Keyword)cGroup_7_5.eContents().get(1);
		private final Assignment cMetaRequiredCapabilitiesAssignment_7_5_2 = (Assignment)cGroup_7_5.eContents().get(2);
		private final RuleCall cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_5_2_0 = (RuleCall)cMetaRequiredCapabilitiesAssignment_7_5_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_7_5_3 = (Keyword)cGroup_7_5.eContents().get(3);
		private final Group cGroup_7_6 = (Group)cAlternatives_7.eContents().get(6);
		private final Keyword cAdviceKeyword_7_6_0 = (Keyword)cGroup_7_6.eContents().get(0);
		private final Assignment cAdviceAssignment_7_6_1 = (Assignment)cGroup_7_6.eContents().get(1);
		private final RuleCall cAdviceNamedAdviceParserRuleCall_7_6_1_0 = (RuleCall)cAdviceAssignment_7_6_1.eContents().get(0);
		private final Group cGroup_7_7 = (Group)cAlternatives_7.eContents().get(7);
		private final Keyword cSequentialKeyword_7_7_0 = (Keyword)cGroup_7_7.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_7_7_1 = (Keyword)cGroup_7_7.eContents().get(1);
		private final Assignment cSynchronizeAssignment_7_7_2 = (Assignment)cGroup_7_7.eContents().get(2);
		private final RuleCall cSynchronizeSynchronizationParserRuleCall_7_7_2_0 = (RuleCall)cSynchronizeAssignment_7_7_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7_7_3 = (Keyword)cGroup_7_7.eContents().get(3);
		private final Group cGroup_7_8 = (Group)cAlternatives_7.eContents().get(8);
		private final Keyword cSequentialKeyword_7_8_0 = (Keyword)cGroup_7_8.eContents().get(0);
		private final Assignment cSynchronizeAssignment_7_8_1 = (Assignment)cGroup_7_8.eContents().get(1);
		private final RuleCall cSynchronizeSynchronizationParserRuleCall_7_8_1_0 = (RuleCall)cSynchronizeAssignment_7_8_1.eContents().get(0);
		private final Assignment cPartsAssignment_7_9 = (Assignment)cAlternatives_7.eContents().get(9);
		private final RuleCall cPartsPartParserRuleCall_7_9_0 = (RuleCall)cPartsAssignment_7_9.eContents().get(0);
		private final Group cGroup_7_10 = (Group)cAlternatives_7.eContents().get(10);
		private final Keyword cRepositoriesKeyword_7_10_0 = (Keyword)cGroup_7_10.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_7_10_1 = (Keyword)cGroup_7_10.eContents().get(1);
		private final Assignment cRepositoryConfigAssignment_7_10_2 = (Assignment)cGroup_7_10.eContents().get(2);
		private final RuleCall cRepositoryConfigRepositoryConfigurationParserRuleCall_7_10_2_0 = (RuleCall)cRepositoryConfigAssignment_7_10_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7_10_3 = (Keyword)cGroup_7_10.eContents().get(3);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Unit returns BuildUnit hidden ( WS , ML_COMMENT , SL_COMMENT ):
		//  executionMode=ExecutionMode? "unit" name=UnitName? ("version" version=Version)? (
		//  "implements" implements+=InterfaceName ("," implements+=InterfaceName)*)? "{" (
		//  "properties" propertyStatements+=NamedPropertyStatements)* ("provides" "{" (
		//  providedCapability+=ProvidedCapability ";")+ "}"|"provides" providedCapability+=
		//  ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=RequiredCapability ";")
		//  + "}"|"requires" requiredCapabilities+=RequiredCapability ";"|"meta" "requires" "{" (
		//  metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"meta" "requires"
		//  metaRequiredCapabilities+=RequiredCapability ";"|"advice" advice+=NamedAdvice|
		//  "sequential" "{" synchronize+=Synchronization+ "}"|"sequential" synchronize+=
		//  Synchronization|parts+=Part|"repositories" "{" repositoryConfig+=
		//  RepositoryConfiguration* "}")* "}";  
		//		
		/// * UNIT - the body (compare to java class)
		// * /	
		//            
		//	    
		//	          
		//		           
		//	
		//			 //-- PROPERTIES
		//			 // goes first, because they may be used in the other clauses.
		//			 //
		//			          
		//		
		//		 	 //-- PROVIDES
		//			               
		//			          
		//			//-- REQUIRES & META REQUIRES
		//			               
		//			          
		//			                  
		//			            
		//			//--ADVICE
		//			       
		//			//--SYNCHRONIZE
		//			                  
		//			           
		//			//--PARTS
		//			         			
		//			//-- REPOSITORIES
		public ParserRule getRule() { return rule; }

		//executionMode=ExecutionMode? "unit" name=UnitName? ("version" version=Version)? (
		//"implements" implements+=InterfaceName ("," implements+=InterfaceName)*)? "{" (
		//"properties" propertyStatements+=NamedPropertyStatements)* ("provides" "{" (
		//providedCapability+=ProvidedCapability ";")+ "}"|"provides" providedCapability+=
		//ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=RequiredCapability ";")
		//+ "}"|"requires" requiredCapabilities+=RequiredCapability ";"|"meta" "requires" "{" (
		//metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"meta" "requires"
		//metaRequiredCapabilities+=RequiredCapability ";"|"advice" advice+=NamedAdvice|
		//"sequential" "{" synchronize+=Synchronization+ "}"|"sequential" synchronize+=
		//Synchronization|parts+=Part|"repositories" "{" repositoryConfig+=
		//RepositoryConfiguration* "}")* "}" 
		//	    
		//	          
		//		           
		//	
		//			 //-- PROPERTIES
		//			 // goes first, because they may be used in the other clauses.
		//			 //
		//			          
		//		
		//		 	 //-- PROVIDES
		//			               
		//			          
		//			//-- REQUIRES & META REQUIRES
		//			               
		//			          
		//			                  
		//			            
		//			//--ADVICE
		//			       
		//			//--SYNCHRONIZE
		//			                  
		//			           
		//			//--PARTS
		//			         			
		//			//-- REPOSITORIES
		public Group getGroup() { return cGroup; }

		//executionMode=ExecutionMode?
		public Assignment getExecutionModeAssignment_0() { return cExecutionModeAssignment_0; }

		//ExecutionMode
		public RuleCall getExecutionModeExecutionModeEnumRuleCall_0_0() { return cExecutionModeExecutionModeEnumRuleCall_0_0; }

		//"unit"
		public Keyword getUnitKeyword_1() { return cUnitKeyword_1; }

		//name=UnitName?
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//UnitName
		public RuleCall getNameUnitNameParserRuleCall_2_0() { return cNameUnitNameParserRuleCall_2_0; }

		//("version" version=Version)?
		public Group getGroup_3() { return cGroup_3; }

		//"version"
		public Keyword getVersionKeyword_3_0() { return cVersionKeyword_3_0; }

		//version=Version
		public Assignment getVersionAssignment_3_1() { return cVersionAssignment_3_1; }

		//Version
		public RuleCall getVersionVersionParserRuleCall_3_1_0() { return cVersionVersionParserRuleCall_3_1_0; }

		//("implements" implements+=InterfaceName ("," implements+=InterfaceName)*)?
		public Group getGroup_4() { return cGroup_4; }

		//"implements"
		public Keyword getImplementsKeyword_4_0() { return cImplementsKeyword_4_0; }

		//implements+=InterfaceName
		public Assignment getImplementsAssignment_4_1() { return cImplementsAssignment_4_1; }

		//InterfaceName
		public RuleCall getImplementsInterfaceNameParserRuleCall_4_1_0() { return cImplementsInterfaceNameParserRuleCall_4_1_0; }

		//("," implements+=InterfaceName)*
		public Group getGroup_4_2() { return cGroup_4_2; }

		//","
		public Keyword getCommaKeyword_4_2_0() { return cCommaKeyword_4_2_0; }

		//implements+=InterfaceName
		public Assignment getImplementsAssignment_4_2_1() { return cImplementsAssignment_4_2_1; }

		//InterfaceName
		public RuleCall getImplementsInterfaceNameParserRuleCall_4_2_1_0() { return cImplementsInterfaceNameParserRuleCall_4_2_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }

		//("properties" propertyStatements+=NamedPropertyStatements)*
		public Group getGroup_6() { return cGroup_6; }

		//"properties"
		public Keyword getPropertiesKeyword_6_0() { return cPropertiesKeyword_6_0; }

		//propertyStatements+=NamedPropertyStatements
		public Assignment getPropertyStatementsAssignment_6_1() { return cPropertyStatementsAssignment_6_1; }

		//NamedPropertyStatements
		public RuleCall getPropertyStatementsNamedPropertyStatementsParserRuleCall_6_1_0() { return cPropertyStatementsNamedPropertyStatementsParserRuleCall_6_1_0; }

		//("provides" "{" (providedCapability+=ProvidedCapability ";")+ "}"|"provides"
		//providedCapability+=ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=
		//RequiredCapability ";")+ "}"|"requires" requiredCapabilities+=RequiredCapability ";"
		//|"meta" "requires" "{" (metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"meta"
		//"requires" metaRequiredCapabilities+=RequiredCapability ";"|"advice" advice+=
		//NamedAdvice|"sequential" "{" synchronize+=Synchronization+ "}"|"sequential"
		//synchronize+=Synchronization|parts+=Part|"repositories" "{" repositoryConfig+=
		//RepositoryConfiguration* "}")* 
		//		 	 //-- PROVIDES
		//			               
		//			          
		//			//-- REQUIRES & META REQUIRES
		//			               
		//			          
		//			                  
		//			            
		//			//--ADVICE
		//			       
		//			//--SYNCHRONIZE
		//			                  
		//			           
		//			//--PARTS
		//			         			
		//			//-- REPOSITORIES
		public Alternatives getAlternatives_7() { return cAlternatives_7; }

		//"provides" "{" (providedCapability+=ProvidedCapability ";")+ "}"
		public Group getGroup_7_0() { return cGroup_7_0; }

		//"provides"
		public Keyword getProvidesKeyword_7_0_0() { return cProvidesKeyword_7_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_7_0_1() { return cLeftCurlyBracketKeyword_7_0_1; }

		//(providedCapability+=ProvidedCapability ";")+
		public Group getGroup_7_0_2() { return cGroup_7_0_2; }

		//providedCapability+=ProvidedCapability
		public Assignment getProvidedCapabilityAssignment_7_0_2_0() { return cProvidedCapabilityAssignment_7_0_2_0; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilityProvidedCapabilityParserRuleCall_7_0_2_0_0() { return cProvidedCapabilityProvidedCapabilityParserRuleCall_7_0_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_7_0_2_1() { return cSemicolonKeyword_7_0_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7_0_3() { return cRightCurlyBracketKeyword_7_0_3; }

		//"provides" providedCapability+=ProvidedCapability ";"
		public Group getGroup_7_1() { return cGroup_7_1; }

		//"provides"
		public Keyword getProvidesKeyword_7_1_0() { return cProvidesKeyword_7_1_0; }

		//providedCapability+=ProvidedCapability
		public Assignment getProvidedCapabilityAssignment_7_1_1() { return cProvidedCapabilityAssignment_7_1_1; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilityProvidedCapabilityParserRuleCall_7_1_1_0() { return cProvidedCapabilityProvidedCapabilityParserRuleCall_7_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_7_1_2() { return cSemicolonKeyword_7_1_2; }

		//"requires" "{" (requiredCapabilities+=RequiredCapability ";")+ "}"
		public Group getGroup_7_2() { return cGroup_7_2; }

		//"requires"
		public Keyword getRequiresKeyword_7_2_0() { return cRequiresKeyword_7_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_7_2_1() { return cLeftCurlyBracketKeyword_7_2_1; }

		//(requiredCapabilities+=RequiredCapability ";")+
		public Group getGroup_7_2_2() { return cGroup_7_2_2; }

		//requiredCapabilities+=RequiredCapability
		public Assignment getRequiredCapabilitiesAssignment_7_2_2_0() { return cRequiredCapabilitiesAssignment_7_2_2_0; }

		//RequiredCapability
		public RuleCall getRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_2_2_0_0() { return cRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_2_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_7_2_2_1() { return cSemicolonKeyword_7_2_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7_2_3() { return cRightCurlyBracketKeyword_7_2_3; }

		//"requires" requiredCapabilities+=RequiredCapability ";"
		public Group getGroup_7_3() { return cGroup_7_3; }

		//"requires"
		public Keyword getRequiresKeyword_7_3_0() { return cRequiresKeyword_7_3_0; }

		//requiredCapabilities+=RequiredCapability
		public Assignment getRequiredCapabilitiesAssignment_7_3_1() { return cRequiredCapabilitiesAssignment_7_3_1; }

		//RequiredCapability
		public RuleCall getRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_3_1_0() { return cRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_7_3_2() { return cSemicolonKeyword_7_3_2; }

		//"meta" "requires" "{" (metaRequiredCapabilities+=RequiredCapability ";")+ "}"
		public Group getGroup_7_4() { return cGroup_7_4; }

		//"meta"
		public Keyword getMetaKeyword_7_4_0() { return cMetaKeyword_7_4_0; }

		//"requires"
		public Keyword getRequiresKeyword_7_4_1() { return cRequiresKeyword_7_4_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_7_4_2() { return cLeftCurlyBracketKeyword_7_4_2; }

		//(metaRequiredCapabilities+=RequiredCapability ";")+
		public Group getGroup_7_4_3() { return cGroup_7_4_3; }

		//metaRequiredCapabilities+=RequiredCapability
		public Assignment getMetaRequiredCapabilitiesAssignment_7_4_3_0() { return cMetaRequiredCapabilitiesAssignment_7_4_3_0; }

		//RequiredCapability
		public RuleCall getMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_4_3_0_0() { return cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_4_3_0_0; }

		//";"
		public Keyword getSemicolonKeyword_7_4_3_1() { return cSemicolonKeyword_7_4_3_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7_4_4() { return cRightCurlyBracketKeyword_7_4_4; }

		//"meta" "requires" metaRequiredCapabilities+=RequiredCapability ";"
		public Group getGroup_7_5() { return cGroup_7_5; }

		//"meta"
		public Keyword getMetaKeyword_7_5_0() { return cMetaKeyword_7_5_0; }

		//"requires"
		public Keyword getRequiresKeyword_7_5_1() { return cRequiresKeyword_7_5_1; }

		//metaRequiredCapabilities+=RequiredCapability
		public Assignment getMetaRequiredCapabilitiesAssignment_7_5_2() { return cMetaRequiredCapabilitiesAssignment_7_5_2; }

		//RequiredCapability
		public RuleCall getMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_5_2_0() { return cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_7_5_2_0; }

		//";"
		public Keyword getSemicolonKeyword_7_5_3() { return cSemicolonKeyword_7_5_3; }

		//"advice" advice+=NamedAdvice
		public Group getGroup_7_6() { return cGroup_7_6; }

		//"advice"
		public Keyword getAdviceKeyword_7_6_0() { return cAdviceKeyword_7_6_0; }

		//advice+=NamedAdvice
		public Assignment getAdviceAssignment_7_6_1() { return cAdviceAssignment_7_6_1; }

		//NamedAdvice
		public RuleCall getAdviceNamedAdviceParserRuleCall_7_6_1_0() { return cAdviceNamedAdviceParserRuleCall_7_6_1_0; }

		//"sequential" "{" synchronize+=Synchronization+ "}"
		public Group getGroup_7_7() { return cGroup_7_7; }

		//"sequential"
		public Keyword getSequentialKeyword_7_7_0() { return cSequentialKeyword_7_7_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_7_7_1() { return cLeftCurlyBracketKeyword_7_7_1; }

		//synchronize+=Synchronization+
		public Assignment getSynchronizeAssignment_7_7_2() { return cSynchronizeAssignment_7_7_2; }

		//Synchronization
		public RuleCall getSynchronizeSynchronizationParserRuleCall_7_7_2_0() { return cSynchronizeSynchronizationParserRuleCall_7_7_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7_7_3() { return cRightCurlyBracketKeyword_7_7_3; }

		//"sequential" synchronize+=Synchronization
		public Group getGroup_7_8() { return cGroup_7_8; }

		//"sequential"
		public Keyword getSequentialKeyword_7_8_0() { return cSequentialKeyword_7_8_0; }

		//synchronize+=Synchronization
		public Assignment getSynchronizeAssignment_7_8_1() { return cSynchronizeAssignment_7_8_1; }

		//Synchronization
		public RuleCall getSynchronizeSynchronizationParserRuleCall_7_8_1_0() { return cSynchronizeSynchronizationParserRuleCall_7_8_1_0; }

		//parts+=Part
		public Assignment getPartsAssignment_7_9() { return cPartsAssignment_7_9; }

		//Part
		public RuleCall getPartsPartParserRuleCall_7_9_0() { return cPartsPartParserRuleCall_7_9_0; }

		//"repositories" "{" repositoryConfig+=RepositoryConfiguration* "}"
		public Group getGroup_7_10() { return cGroup_7_10; }

		//"repositories"
		public Keyword getRepositoriesKeyword_7_10_0() { return cRepositoriesKeyword_7_10_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_7_10_1() { return cLeftCurlyBracketKeyword_7_10_1; }

		//repositoryConfig+=RepositoryConfiguration*
		public Assignment getRepositoryConfigAssignment_7_10_2() { return cRepositoryConfigAssignment_7_10_2; }

		//RepositoryConfiguration
		public RuleCall getRepositoryConfigRepositoryConfigurationParserRuleCall_7_10_2_0() { return cRepositoryConfigRepositoryConfigurationParserRuleCall_7_10_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7_10_3() { return cRightCurlyBracketKeyword_7_10_3; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}

	public class ProvidedCapabilityElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProvidedCapability");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cFilterAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_0_1_0 = (RuleCall)cFilterAssignment_0_1.eContents().get(0);
		private final Assignment cInterfaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInterfaceQualifiedNameParserRuleCall_1_0 = (RuleCall)cInterfaceAssignment_1.eContents().get(0);
		private final Keyword cSolidusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameQualifiedNameParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cSolidusKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cVersionAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cVersionVersionParserRuleCall_4_1_0 = (RuleCall)cVersionAssignment_4_1.eContents().get(0);
		
		//ProvidedCapability:
		//  ("when" filter=Filter)? interface=QualifiedName "/" name=QualifiedName ("/" version=
		//  Version)?;
		public ParserRule getRule() { return rule; }

		//("when" filter=Filter)? interface=QualifiedName "/" name=QualifiedName ("/" version=
		//Version)?
		public Group getGroup() { return cGroup; }

		//("when" filter=Filter)?
		public Group getGroup_0() { return cGroup_0; }

		//"when"
		public Keyword getWhenKeyword_0_0() { return cWhenKeyword_0_0; }

		//filter=Filter
		public Assignment getFilterAssignment_0_1() { return cFilterAssignment_0_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_0_1_0() { return cFilterFilterParserRuleCall_0_1_0; }

		//interface=QualifiedName
		public Assignment getInterfaceAssignment_1() { return cInterfaceAssignment_1; }

		//QualifiedName
		public RuleCall getInterfaceQualifiedNameParserRuleCall_1_0() { return cInterfaceQualifiedNameParserRuleCall_1_0; }

		//"/"
		public Keyword getSolidusKeyword_2() { return cSolidusKeyword_2; }

		//name=QualifiedName
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_3_0() { return cNameQualifiedNameParserRuleCall_3_0; }

		//("/" version=Version)?
		public Group getGroup_4() { return cGroup_4; }

		//"/"
		public Keyword getSolidusKeyword_4_0() { return cSolidusKeyword_4_0; }

		//version=Version
		public Assignment getVersionAssignment_4_1() { return cVersionAssignment_4_1; }

		//Version
		public RuleCall getVersionVersionParserRuleCall_4_1_0() { return cVersionVersionParserRuleCall_4_1_0; }
	}

	public class RequiredCapabilityElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RequiredCapability");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cFilterAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_0_1_0 = (RuleCall)cFilterAssignment_0_1.eContents().get(0);
		private final Assignment cInterfaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInterfaceQualifiedNameParserRuleCall_1_0 = (RuleCall)cInterfaceAssignment_1.eContents().get(0);
		private final Keyword cSolidusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameQualifiedNameParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cSolidusKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cRangeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRangeVersionRangeParserRuleCall_4_1_0 = (RuleCall)cRangeAssignment_4_1.eContents().get(0);
		
		//RequiredCapability:
		//  ("when" filter=Filter)? interface=QualifiedName "/" name=QualifiedName ("/" range=
		//  VersionRange)?; 
		//                   
		//
		//// An optionally named sequence of property statements
		public ParserRule getRule() { return rule; }

		//("when" filter=Filter)? interface=QualifiedName "/" name=QualifiedName ("/" range=
		//VersionRange)?
		public Group getGroup() { return cGroup; }

		//("when" filter=Filter)?
		public Group getGroup_0() { return cGroup_0; }

		//"when"
		public Keyword getWhenKeyword_0_0() { return cWhenKeyword_0_0; }

		//filter=Filter
		public Assignment getFilterAssignment_0_1() { return cFilterAssignment_0_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_0_1_0() { return cFilterFilterParserRuleCall_0_1_0; }

		//interface=QualifiedName
		public Assignment getInterfaceAssignment_1() { return cInterfaceAssignment_1; }

		//QualifiedName
		public RuleCall getInterfaceQualifiedNameParserRuleCall_1_0() { return cInterfaceQualifiedNameParserRuleCall_1_0; }

		//"/"
		public Keyword getSolidusKeyword_2() { return cSolidusKeyword_2; }

		//name=QualifiedName
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_3_0() { return cNameQualifiedNameParserRuleCall_3_0; }

		//("/" range=VersionRange)?
		public Group getGroup_4() { return cGroup_4; }

		//"/"
		public Keyword getSolidusKeyword_4_0() { return cSolidusKeyword_4_0; }

		//range=VersionRange
		public Assignment getRangeAssignment_4_1() { return cRangeAssignment_4_1; }

		//VersionRange
		public RuleCall getRangeVersionRangeParserRuleCall_4_1_0() { return cRangeVersionRangeParserRuleCall_4_1_0; }
	}

	public class NamedPropertyStatementsElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamedPropertyStatements");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsPropertyStatementsParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		
		//NamedPropertyStatements returns PropertyStatements:
		//  name=ID? statements=PropertyStatements; 
		//
		//// An optionally named sequence of property statements
		//    
		//	             
		//	
		//
		//// Sequence of property statements
		public ParserRule getRule() { return rule; }

		//name=ID? statements=PropertyStatements
		public Group getGroup() { return cGroup; }

		//name=ID?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//statements=PropertyStatements
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }

		//PropertyStatements
		public RuleCall getStatementsPropertyStatementsParserRuleCall_1_0() { return cStatementsPropertyStatementsParserRuleCall_1_0; }
	}

	public class PropertyStatementsElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyStatements");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Keyword cWhenKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cFilterAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_1_0_1_0 = (RuleCall)cFilterAssignment_1_0_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cStatementsAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cStatementsUnsetPropertyStatementParserRuleCall_1_1_0_0 = (RuleCall)cStatementsAssignment_1_1_0.eContents().get(0);
		private final Assignment cStatementsAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cStatementsPropertyStatementParserRuleCall_1_1_1_0 = (RuleCall)cStatementsAssignment_1_1_1.eContents().get(0);
		private final Assignment cStatementsAssignment_1_1_2 = (Assignment)cAlternatives_1_1.eContents().get(2);
		private final RuleCall cStatementsPropertyStatementsParserRuleCall_1_1_2_0 = (RuleCall)cStatementsAssignment_1_1_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PropertyStatements returns PropertyStatement:
		//  "{" (("when" filter=Filter)? (statements+=UnsetPropertyStatement|statements+=
		//  PropertyStatement|statements+=PropertyStatements))* "}"; 
		//
		//// Sequence of property statements
		public ParserRule getRule() { return rule; }

		//"{" (("when" filter=Filter)? (statements+=UnsetPropertyStatement|statements+=
		//PropertyStatement|statements+=PropertyStatements))* "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//(("when" filter=Filter)? (statements+=UnsetPropertyStatement|statements+=
		//PropertyStatement|statements+=PropertyStatements))*
		public Group getGroup_1() { return cGroup_1; }

		//("when" filter=Filter)?
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"when"
		public Keyword getWhenKeyword_1_0_0() { return cWhenKeyword_1_0_0; }

		//filter=Filter
		public Assignment getFilterAssignment_1_0_1() { return cFilterAssignment_1_0_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_1_0_1_0() { return cFilterFilterParserRuleCall_1_0_1_0; }

		//statements+=UnsetPropertyStatement|statements+=PropertyStatement|statements+=
		//PropertyStatements
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//statements+=UnsetPropertyStatement
		public Assignment getStatementsAssignment_1_1_0() { return cStatementsAssignment_1_1_0; }

		//UnsetPropertyStatement
		public RuleCall getStatementsUnsetPropertyStatementParserRuleCall_1_1_0_0() { return cStatementsUnsetPropertyStatementParserRuleCall_1_1_0_0; }

		//statements+=PropertyStatement
		public Assignment getStatementsAssignment_1_1_1() { return cStatementsAssignment_1_1_1; }

		//PropertyStatement
		public RuleCall getStatementsPropertyStatementParserRuleCall_1_1_1_0() { return cStatementsPropertyStatementParserRuleCall_1_1_1_0; }

		//statements+=PropertyStatements
		public Assignment getStatementsAssignment_1_1_2() { return cStatementsAssignment_1_1_2; }

		//PropertyStatements
		public RuleCall getStatementsPropertyStatementsParserRuleCall_1_1_2_0() { return cStatementsPropertyStatementsParserRuleCall_1_1_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class PropertyStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImmutableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cImmutableImmutableKeyword_0_0 = (Keyword)cImmutableAssignment_0.eContents().get(0);
		private final Assignment cKeyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKeyPropertyNameParserRuleCall_1_0 = (RuleCall)cKeyAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOpAlternatives_2_0 = (Alternatives)cOpAssignment_2.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_2_0_0 = (Keyword)cOpAlternatives_2_0.eContents().get(0);
		private final Keyword cOpPlusSignEqualsSignKeyword_2_0_1 = (Keyword)cOpAlternatives_2_0.eContents().get(1);
		private final Keyword cOpHyphenMinusEqualsSignKeyword_2_0_2 = (Keyword)cOpAlternatives_2_0.eContents().get(2);
		private final Keyword cOpAsteriskEqualsSignKeyword_2_0_3 = (Keyword)cOpAlternatives_2_0.eContents().get(3);
		private final Keyword cOpSolidusEqualsSignKeyword_2_0_4 = (Keyword)cOpAlternatives_2_0.eContents().get(4);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValuePropertyExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PropertyStatement:
		//  immutable?="immutable"? key=PropertyName op=( "=" | "+=" | "-=" | "*=" | "/=" ) value=
		//  PropertyExpression ";";
		public ParserRule getRule() { return rule; }

		//immutable?="immutable"? key=PropertyName op=( "=" | "+=" | "-=" | "*=" | "/=" ) value=
		//PropertyExpression ";"
		public Group getGroup() { return cGroup; }

		//immutable?="immutable"?
		public Assignment getImmutableAssignment_0() { return cImmutableAssignment_0; }

		//"immutable"
		public Keyword getImmutableImmutableKeyword_0_0() { return cImmutableImmutableKeyword_0_0; }

		//key=PropertyName
		public Assignment getKeyAssignment_1() { return cKeyAssignment_1; }

		//PropertyName
		public RuleCall getKeyPropertyNameParserRuleCall_1_0() { return cKeyPropertyNameParserRuleCall_1_0; }

		//op=( "=" | "+=" | "-=" | "*=" | "/=" )
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }

		//"="|"+="|"-="|"*="|"/="
		public Alternatives getOpAlternatives_2_0() { return cOpAlternatives_2_0; }

		//"="
		public Keyword getOpEqualsSignKeyword_2_0_0() { return cOpEqualsSignKeyword_2_0_0; }

		//"+="
		public Keyword getOpPlusSignEqualsSignKeyword_2_0_1() { return cOpPlusSignEqualsSignKeyword_2_0_1; }

		//"-="
		public Keyword getOpHyphenMinusEqualsSignKeyword_2_0_2() { return cOpHyphenMinusEqualsSignKeyword_2_0_2; }

		//"*="
		public Keyword getOpAsteriskEqualsSignKeyword_2_0_3() { return cOpAsteriskEqualsSignKeyword_2_0_3; }

		//"/="
		public Keyword getOpSolidusEqualsSignKeyword_2_0_4() { return cOpSolidusEqualsSignKeyword_2_0_4; }

		//value=PropertyExpression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//PropertyExpression
		public RuleCall getValuePropertyExpressionParserRuleCall_3_0() { return cValuePropertyExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class UnsetPropertyStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnsetPropertyStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUnsetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cUnsetPropertiesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cUnsetPropertiesPropertyNameParserRuleCall_1_0 = (RuleCall)cUnsetPropertiesAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//UnsetPropertyStatement returns PropertyStatement:
		//  "unset" unsetProperties+=PropertyName ";"; 
		//
		//    
		//	             
		//	
		//
		//// identical to nested properties statement, but used to get a separate data type
		public ParserRule getRule() { return rule; }

		//"unset" unsetProperties+=PropertyName ";"
		public Group getGroup() { return cGroup; }

		//"unset"
		public Keyword getUnsetKeyword_0() { return cUnsetKeyword_0; }

		//unsetProperties+=PropertyName
		public Assignment getUnsetPropertiesAssignment_1() { return cUnsetPropertiesAssignment_1; }

		//PropertyName
		public RuleCall getUnsetPropertiesPropertyNameParserRuleCall_1_0() { return cUnsetPropertiesPropertyNameParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class AnnotationStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AnnotationStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cFilterAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_0_1_0 = (RuleCall)cFilterAssignment_0_1.eContents().get(0);
		private final Assignment cImmutableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cImmutableImmutableKeyword_1_0 = (Keyword)cImmutableAssignment_1.eContents().get(0);
		private final Assignment cKeyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cKeyPropertyNameParserRuleCall_2_0 = (RuleCall)cKeyAssignment_2.eContents().get(0);
		private final Assignment cOpAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cOpAlternatives_3_0 = (Alternatives)cOpAssignment_3.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_3_0_0 = (Keyword)cOpAlternatives_3_0.eContents().get(0);
		private final Keyword cOpPlusSignEqualsSignKeyword_3_0_1 = (Keyword)cOpAlternatives_3_0.eContents().get(1);
		private final Keyword cOpHyphenMinusEqualsSignKeyword_3_0_2 = (Keyword)cOpAlternatives_3_0.eContents().get(2);
		private final Keyword cOpAsteriskEqualsSignKeyword_3_0_3 = (Keyword)cOpAlternatives_3_0.eContents().get(3);
		private final Keyword cOpSolidusEqualsSignKeyword_3_0_4 = (Keyword)cOpAlternatives_3_0.eContents().get(4);
		private final Assignment cValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValuePropertyExpressionParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//AnnotationStatement returns PropertyStatement:
		//  ("when" filter=Filter)? immutable?="immutable"? key=PropertyName op=( "=" | "+=" | "-=" |
		//  "*=" | "/=" ) value=PropertyExpression ";"; 
		//
		//// identical to nested properties statement, but used to get a separate data type
		public ParserRule getRule() { return rule; }

		//("when" filter=Filter)? immutable?="immutable"? key=PropertyName op=( "=" | "+=" | "-=" |
		//"*=" | "/=" ) value=PropertyExpression ";"
		public Group getGroup() { return cGroup; }

		//("when" filter=Filter)?
		public Group getGroup_0() { return cGroup_0; }

		//"when"
		public Keyword getWhenKeyword_0_0() { return cWhenKeyword_0_0; }

		//filter=Filter
		public Assignment getFilterAssignment_0_1() { return cFilterAssignment_0_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_0_1_0() { return cFilterFilterParserRuleCall_0_1_0; }

		//immutable?="immutable"?
		public Assignment getImmutableAssignment_1() { return cImmutableAssignment_1; }

		//"immutable"
		public Keyword getImmutableImmutableKeyword_1_0() { return cImmutableImmutableKeyword_1_0; }

		//key=PropertyName
		public Assignment getKeyAssignment_2() { return cKeyAssignment_2; }

		//PropertyName
		public RuleCall getKeyPropertyNameParserRuleCall_2_0() { return cKeyPropertyNameParserRuleCall_2_0; }

		//op=( "=" | "+=" | "-=" | "*=" | "/=" )
		public Assignment getOpAssignment_3() { return cOpAssignment_3; }

		//"="|"+="|"-="|"*="|"/="
		public Alternatives getOpAlternatives_3_0() { return cOpAlternatives_3_0; }

		//"="
		public Keyword getOpEqualsSignKeyword_3_0_0() { return cOpEqualsSignKeyword_3_0_0; }

		//"+="
		public Keyword getOpPlusSignEqualsSignKeyword_3_0_1() { return cOpPlusSignEqualsSignKeyword_3_0_1; }

		//"-="
		public Keyword getOpHyphenMinusEqualsSignKeyword_3_0_2() { return cOpHyphenMinusEqualsSignKeyword_3_0_2; }

		//"*="
		public Keyword getOpAsteriskEqualsSignKeyword_3_0_3() { return cOpAsteriskEqualsSignKeyword_3_0_3; }

		//"/="
		public Keyword getOpSolidusEqualsSignKeyword_3_0_4() { return cOpSolidusEqualsSignKeyword_3_0_4; }

		//value=PropertyExpression
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }

		//PropertyExpression
		public RuleCall getValuePropertyExpressionParserRuleCall_4_0() { return cValuePropertyExpressionParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class PropertyExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyExpression");
		private final RuleCall cExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PropertyExpression:
		//  Expression;
		public ParserRule getRule() { return rule; }

		//Expression
		public RuleCall getExpressionParserRuleCall() { return cExpressionParserRuleCall; }
	}

	public class SynchronizationElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Synchronization");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPartrefsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPartrefsSynchronizedPartParserRuleCall_0_0 = (RuleCall)cPartrefsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cPartrefsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPartrefsSynchronizedPartParserRuleCall_1_1_0 = (RuleCall)cPartrefsAssignment_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Synchronization:
		//  partrefs+=SynchronizedPart ("," partrefs+=SynchronizedPart)+ ";";  
		//
		// 
		//	                // at least 2
		public ParserRule getRule() { return rule; }

		//partrefs+=SynchronizedPart ("," partrefs+=SynchronizedPart)+ ";"                 // at least 2
		public Group getGroup() { return cGroup; }

		//partrefs+=SynchronizedPart
		public Assignment getPartrefsAssignment_0() { return cPartrefsAssignment_0; }

		//SynchronizedPart
		public RuleCall getPartrefsSynchronizedPartParserRuleCall_0_0() { return cPartrefsSynchronizedPartParserRuleCall_0_0; }

		//("," partrefs+=SynchronizedPart)+
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//partrefs+=SynchronizedPart
		public Assignment getPartrefsAssignment_1_1() { return cPartrefsAssignment_1_1; }

		//SynchronizedPart
		public RuleCall getPartrefsSynchronizedPartParserRuleCall_1_1_0() { return cPartrefsSynchronizedPartParserRuleCall_1_1_0; }

		//";"     // at least 2
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class SynchronizedPartElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SynchronizedPart");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cCompoundNameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cNumberSignKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final RuleCall cPartNameParserRuleCall_0_1_1 = (RuleCall)cGroup_0_1.eContents().get(1);
		private final RuleCall cPartNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SynchronizedPart returns ecore::EString:
		//  CompoundName ("#" PartName)?|PartName; 
		//	
		//
		//	      
		//	  
		//	
		//	
		//
		//// NOT NEEDED - action can specify a layout and return it	
		////Artifacts returns ArtifactsPart 
		////	: (visibility = Visibility)? 'artifacts' name=PartName
		////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		////		(asserts += PostConditionAssert)?
		////		'{' (paths += PathGroup)* '}'
		////	;
		//	
		/// * PATH GROUP
		// * TODO: Allow basePath without paths?
		// * TODO: generated structure is wrong . should be in sequence, basepath and expr are out of band !!
		// * /
		public ParserRule getRule() { return rule; }

		//CompoundName ("#" PartName)?|PartName 
		//	
		//
		//	      
		//	  
		//	
		//	
		//
		//// NOT NEEDED - action can specify a layout and return it	
		////Artifacts returns ArtifactsPart 
		////	: (visibility = Visibility)? 'artifacts' name=PartName
		////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		////		(asserts += PostConditionAssert)?
		////		'{' (paths += PathGroup)* '}'
		////	;
		//	
		/// * PATH GROUP
		// * TODO: Allow basePath without paths?
		// * TODO: generated structure is wrong . should be in sequence, basepath and expr are out of band !!
		// * /
		public Alternatives getAlternatives() { return cAlternatives; }

		//CompoundName ("#" PartName)?
		public Group getGroup_0() { return cGroup_0; }

		//CompoundName
		public RuleCall getCompoundNameParserRuleCall_0_0() { return cCompoundNameParserRuleCall_0_0; }

		//("#" PartName)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"#"
		public Keyword getNumberSignKeyword_0_1_0() { return cNumberSignKeyword_0_1_0; }

		//PartName
		public RuleCall getPartNameParserRuleCall_0_1_1() { return cPartNameParserRuleCall_0_1_1; }

		//PartName
		public RuleCall getPartNameParserRuleCall_1() { return cPartNameParserRuleCall_1; }
	}

	public class PathGroupElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathGroup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cFilterAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_0_1_0 = (RuleCall)cFilterAssignment_0_1.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cPathsAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cPathsPathExpressionParserRuleCall_1_0_0_0 = (RuleCall)cPathsAssignment_1_0_0.eContents().get(0);
		private final Alternatives cAlternatives_1_0_1 = (Alternatives)cGroup_1_0.eContents().get(1);
		private final Group cGroup_1_0_1_0 = (Group)cAlternatives_1_0_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_0_1_0_0 = (Keyword)cGroup_1_0_1_0.eContents().get(0);
		private final Assignment cPathsAssignment_1_0_1_0_1 = (Assignment)cGroup_1_0_1_0.eContents().get(1);
		private final RuleCall cPathsPathExpressionParserRuleCall_1_0_1_0_1_0 = (RuleCall)cPathsAssignment_1_0_1_0_1.eContents().get(0);
		private final Group cGroup_1_0_1_1 = (Group)cAlternatives_1_0_1.eContents().get(1);
		private final Assignment cFirstIsBaseAssignment_1_0_1_1_0 = (Assignment)cGroup_1_0_1_1.eContents().get(0);
		private final Keyword cFirstIsBaseLeftSquareBracketKeyword_1_0_1_1_0_0 = (Keyword)cFirstIsBaseAssignment_1_0_1_1_0.eContents().get(0);
		private final Assignment cPathsAssignment_1_0_1_1_1 = (Assignment)cGroup_1_0_1_1.eContents().get(1);
		private final RuleCall cPathsPathExpressionParserRuleCall_1_0_1_1_1_0 = (RuleCall)cPathsAssignment_1_0_1_1_1.eContents().get(0);
		private final Group cGroup_1_0_1_1_2 = (Group)cGroup_1_0_1_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_0_1_1_2_0 = (Keyword)cGroup_1_0_1_1_2.eContents().get(0);
		private final Assignment cPathsAssignment_1_0_1_1_2_1 = (Assignment)cGroup_1_0_1_1_2.eContents().get(1);
		private final RuleCall cPathsPathExpressionParserRuleCall_1_0_1_1_2_1_0 = (RuleCall)cPathsAssignment_1_0_1_1_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_0_1_1_3 = (Keyword)cGroup_1_0_1_1.eContents().get(3);
		private final Keyword cSemicolonKeyword_1_0_2 = (Keyword)cGroup_1_0.eContents().get(2);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cAnnotationsKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Alternatives cAlternatives_1_1_2 = (Alternatives)cGroup_1_1.eContents().get(2);
		private final Group cGroup_1_1_2_0 = (Group)cAlternatives_1_1_2.eContents().get(0);
		private final Keyword cUnsetKeyword_1_1_2_0_0 = (Keyword)cGroup_1_1_2_0.eContents().get(0);
		private final Assignment cUnsetPropertiesAssignment_1_1_2_0_1 = (Assignment)cGroup_1_1_2_0.eContents().get(1);
		private final RuleCall cUnsetPropertiesPropertyNameParserRuleCall_1_1_2_0_1_0 = (RuleCall)cUnsetPropertiesAssignment_1_1_2_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1_2_0_2 = (Keyword)cGroup_1_1_2_0.eContents().get(2);
		private final Assignment cSetPropertiesAssignment_1_1_2_1 = (Assignment)cAlternatives_1_1_2.eContents().get(1);
		private final RuleCall cSetPropertiesAnnotationStatementParserRuleCall_1_1_2_1_0 = (RuleCall)cSetPropertiesAssignment_1_1_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_1_3 = (Keyword)cGroup_1_1.eContents().get(3);
		
		//PathGroup:
		//  ("when" filter=Filter)? (paths+=PathExpression (("," paths+=PathExpression)*|
		//  firstIsBase?="[" paths+=PathExpression ("," paths+=PathExpression)* "]") ";"|
		//  "annotations" "{" ("unset" unsetProperties+=PropertyName ";"|setProperties+=
		//  AnnotationStatement)+ "}"); 
		//	
		//
		//// NOT NEEDED - action can specify a layout and return it	
		////Artifacts returns ArtifactsPart 
		////	: (visibility = Visibility)? 'artifacts' name=PartName
		////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		////		(asserts += PostConditionAssert)?
		////		'{' (paths += PathGroup)* '}'
		////	;
		//	
		/// * PATH GROUP
		// * TODO: Allow basePath without paths?
		// * TODO: generated structure is wrong . should be in sequence, basepath and expr are out of band !!
		// * /
		// 
		//	     
		//		   
		//		           
		//		                
		//		      
		////		| basePath=PathExpression '[' paths+=PathExpression (',' paths+=PathExpression)* ']' ';'
		////		| ('expr' pathExpressions += Expression ';' )
		public ParserRule getRule() { return rule; }

		//("when" filter=Filter)? (paths+=PathExpression (("," paths+=PathExpression)*|
		//firstIsBase?="[" paths+=PathExpression ("," paths+=PathExpression)* "]") ";"|
		//"annotations" "{" ("unset" unsetProperties+=PropertyName ";"|setProperties+=
		//AnnotationStatement)+ "}")      
		//		   
		//		           
		//		                
		//		      
		////		| basePath=PathExpression '[' paths+=PathExpression (',' paths+=PathExpression)* ']' ';'
		////		| ('expr' pathExpressions += Expression ';' )
		public Group getGroup() { return cGroup; }

		//("when" filter=Filter)?
		public Group getGroup_0() { return cGroup_0; }

		//"when"
		public Keyword getWhenKeyword_0_0() { return cWhenKeyword_0_0; }

		//filter=Filter
		public Assignment getFilterAssignment_0_1() { return cFilterAssignment_0_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_0_1_0() { return cFilterFilterParserRuleCall_0_1_0; }

		//paths+=PathExpression (("," paths+=PathExpression)*|firstIsBase?="[" paths+=
		//PathExpression ("," paths+=PathExpression)* "]") ";"|"annotations" "{" ("unset"
		//unsetProperties+=PropertyName ";"|setProperties+=AnnotationStatement)+ "}"  
		//		   
		//		           
		//		                
		//		      
		////		| basePath=PathExpression '[' paths+=PathExpression (',' paths+=PathExpression)* ']' ';'
		////		| ('expr' pathExpressions += Expression ';' )
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//paths+=PathExpression (("," paths+=PathExpression)*|firstIsBase?="[" paths+=
		//PathExpression ("," paths+=PathExpression)* "]") ";"    
		//		           
		//		                
		//		      
		////		| basePath=PathExpression '[' paths+=PathExpression (',' paths+=PathExpression)* ']' ';'
		////		| ('expr' pathExpressions += Expression ';' )
		public Group getGroup_1_0() { return cGroup_1_0; }

		//paths+=PathExpression
		public Assignment getPathsAssignment_1_0_0() { return cPathsAssignment_1_0_0; }

		//PathExpression
		public RuleCall getPathsPathExpressionParserRuleCall_1_0_0_0() { return cPathsPathExpressionParserRuleCall_1_0_0_0; }

		//("," paths+=PathExpression)*|firstIsBase?="[" paths+=PathExpression ("," paths+=
		//PathExpression)* "]"
		public Alternatives getAlternatives_1_0_1() { return cAlternatives_1_0_1; }

		//("," paths+=PathExpression)*
		public Group getGroup_1_0_1_0() { return cGroup_1_0_1_0; }

		//","
		public Keyword getCommaKeyword_1_0_1_0_0() { return cCommaKeyword_1_0_1_0_0; }

		//paths+=PathExpression
		public Assignment getPathsAssignment_1_0_1_0_1() { return cPathsAssignment_1_0_1_0_1; }

		//PathExpression
		public RuleCall getPathsPathExpressionParserRuleCall_1_0_1_0_1_0() { return cPathsPathExpressionParserRuleCall_1_0_1_0_1_0; }

		//firstIsBase?="[" paths+=PathExpression ("," paths+=PathExpression)* "]"
		public Group getGroup_1_0_1_1() { return cGroup_1_0_1_1; }

		//firstIsBase?="["
		public Assignment getFirstIsBaseAssignment_1_0_1_1_0() { return cFirstIsBaseAssignment_1_0_1_1_0; }

		//"["
		public Keyword getFirstIsBaseLeftSquareBracketKeyword_1_0_1_1_0_0() { return cFirstIsBaseLeftSquareBracketKeyword_1_0_1_1_0_0; }

		//paths+=PathExpression
		public Assignment getPathsAssignment_1_0_1_1_1() { return cPathsAssignment_1_0_1_1_1; }

		//PathExpression
		public RuleCall getPathsPathExpressionParserRuleCall_1_0_1_1_1_0() { return cPathsPathExpressionParserRuleCall_1_0_1_1_1_0; }

		//("," paths+=PathExpression)*
		public Group getGroup_1_0_1_1_2() { return cGroup_1_0_1_1_2; }

		//","
		public Keyword getCommaKeyword_1_0_1_1_2_0() { return cCommaKeyword_1_0_1_1_2_0; }

		//paths+=PathExpression
		public Assignment getPathsAssignment_1_0_1_1_2_1() { return cPathsAssignment_1_0_1_1_2_1; }

		//PathExpression
		public RuleCall getPathsPathExpressionParserRuleCall_1_0_1_1_2_1_0() { return cPathsPathExpressionParserRuleCall_1_0_1_1_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_0_1_1_3() { return cRightSquareBracketKeyword_1_0_1_1_3; }

		//";"   
		////		| basePath=PathExpression '[' paths+=PathExpression (',' paths+=PathExpression)* ']' ';'
		////		| ('expr' pathExpressions += Expression ';' )
		public Keyword getSemicolonKeyword_1_0_2() { return cSemicolonKeyword_1_0_2; }

		//"annotations" "{" ("unset" unsetProperties+=PropertyName ";"|setProperties+=
		//AnnotationStatement)+ "}"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"annotations"
		public Keyword getAnnotationsKeyword_1_1_0() { return cAnnotationsKeyword_1_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_1_1() { return cLeftCurlyBracketKeyword_1_1_1; }

		//("unset" unsetProperties+=PropertyName ";"|setProperties+=AnnotationStatement)+
		public Alternatives getAlternatives_1_1_2() { return cAlternatives_1_1_2; }

		//"unset" unsetProperties+=PropertyName ";"
		public Group getGroup_1_1_2_0() { return cGroup_1_1_2_0; }

		//"unset"
		public Keyword getUnsetKeyword_1_1_2_0_0() { return cUnsetKeyword_1_1_2_0_0; }

		//unsetProperties+=PropertyName
		public Assignment getUnsetPropertiesAssignment_1_1_2_0_1() { return cUnsetPropertiesAssignment_1_1_2_0_1; }

		//PropertyName
		public RuleCall getUnsetPropertiesPropertyNameParserRuleCall_1_1_2_0_1_0() { return cUnsetPropertiesPropertyNameParserRuleCall_1_1_2_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_1_1_2_0_2() { return cSemicolonKeyword_1_1_2_0_2; }

		//setProperties+=AnnotationStatement
		public Assignment getSetPropertiesAssignment_1_1_2_1() { return cSetPropertiesAssignment_1_1_2_1; }

		//AnnotationStatement
		public RuleCall getSetPropertiesAnnotationStatementParserRuleCall_1_1_2_1_0() { return cSetPropertiesAnnotationStatementParserRuleCall_1_1_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_1_3() { return cRightCurlyBracketKeyword_1_1_3; }
	}

	public class PathExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPathParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExprStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PathExpression:
		//  Path|ExprStatement;
		public ParserRule getRule() { return rule; }

		//Path|ExprStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//Path
		public RuleCall getPathParserRuleCall_0() { return cPathParserRuleCall_0; }

		//ExprStatement
		public RuleCall getExprStatementParserRuleCall_1() { return cExprStatementParserRuleCall_1; }
	}

	public class ExprStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExprStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExprKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ExprStatement:
		//  "expr" "(" expression=Expression ")"; 
		//
		//                  
		//
		/// *
		// * A path can be written without quotes if it consists of safe chars 
		// * TODO: repace use of ID with better definition.
		// * TODO: Validation of path syntax (MS, n*x) ?
		// * /
		public ParserRule getRule() { return rule; }

		//"expr" "(" expression=Expression ")"
		public Group getGroup() { return cGroup; }

		//"expr"
		public Keyword getExprKeyword_0() { return cExprKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class PathElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Path");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cSolidusKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cQualifiedNameParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cSolidusKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final RuleCall cQualifiedNameParserRuleCall_1_2_1 = (RuleCall)cGroup_1_2.eContents().get(1);
		private final Keyword cSolidusKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Path returns ecore::EString hidden ( ):
		//  STRING|"/"? QualifiedName ("/" QualifiedName)* "/"?; 
		//
		/// *
		// * A path can be written without quotes if it consists of safe chars 
		// * TODO: repace use of ID with better definition.
		// * TODO: Validation of path syntax (MS, n*x) ?
		// * /
		//  
		//	  
		//	            // HIDDENBUG
		//	 
		//
		////Group returns GroupPart 
		////	: (visibility = Visibility)?
		////	  (executionMode = ExecutionMode)?
		////	  'group' name=PartName
		////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		////		(asserts += PreConditionAssert)?
		////		(asserts += PostConditionAssert)?
		////		'{' ( prerequisites += Prerequisite )*
		////		'}'
		////	;
		public ParserRule getRule() { return rule; }

		//STRING|"/"? QualifiedName ("/" QualifiedName)* "/"? 
		//
		/// *
		// * A path can be written without quotes if it consists of safe chars 
		// * TODO: repace use of ID with better definition.
		// * TODO: Validation of path syntax (MS, n*x) ?
		// * /
		//  
		//	  
		//	            // HIDDENBUG
		//	 
		//
		////Group returns GroupPart 
		////	: (visibility = Visibility)?
		////	  (executionMode = ExecutionMode)?
		////	  'group' name=PartName
		////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		////		(asserts += PreConditionAssert)?
		////		(asserts += PostConditionAssert)?
		////		'{' ( prerequisites += Prerequisite )*
		////		'}'
		////	;
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//"/"? QualifiedName ("/" QualifiedName)* "/"?   
		//	            // HIDDENBUG
		public Group getGroup_1() { return cGroup_1; }

		//"/"?
		public Keyword getSolidusKeyword_1_0() { return cSolidusKeyword_1_0; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_1_1() { return cQualifiedNameParserRuleCall_1_1; }

		//("/" QualifiedName)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"/"
		public Keyword getSolidusKeyword_1_2_0() { return cSolidusKeyword_1_2_0; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_1_2_1() { return cQualifiedNameParserRuleCall_1_2_1; }

		//"/"?
		public Keyword getSolidusKeyword_1_3() { return cSolidusKeyword_1_3; }
	}

	public class PrerequisiteElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Prerequisite");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cSurpressedAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Keyword cSurpressedHiddenKeyword_0_0_0 = (Keyword)cSurpressedAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cWhenKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cFilterAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_0_1_1_0 = (RuleCall)cFilterAssignment_0_1_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Assignment cAliasAssignment_0_2_0 = (Assignment)cGroup_0_2.eContents().get(0);
		private final RuleCall cAliasIDTerminalRuleCall_0_2_0_0 = (RuleCall)cAliasAssignment_0_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_2_1 = (Keyword)cGroup_0_2.eContents().get(1);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Assignment cPartReferenceAssignment_0_3_0 = (Assignment)cGroup_0_3.eContents().get(0);
		private final RuleCall cPartReferencePrerequisiteEntryParserRuleCall_0_3_0_0 = (RuleCall)cPartReferenceAssignment_0_3_0.eContents().get(0);
		private final Assignment cClosureAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cClosureClosureParserRuleCall_0_3_1_0 = (RuleCall)cClosureAssignment_0_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Prerequisite:
		//  (surpressed?="hidden"? ("when" filter=Filter)? (alias=ID "=")? (partReference=
		//  PrerequisiteEntry closure=Closure?)) ";"; 
		//
		////Group returns GroupPart 
		////	: (visibility = Visibility)?
		////	  (executionMode = ExecutionMode)?
		////	  'group' name=PartName
		////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		////		(asserts += PreConditionAssert)?
		////		(asserts += PostConditionAssert)?
		////		'{' ( prerequisites += Prerequisite )*
		////		'}'
		////	;
		//
		//
		//	                   
		//	       / *| (partReference=ExprStatement) * /
		public ParserRule getRule() { return rule; }

		//(surpressed?="hidden"? ("when" filter=Filter)? (alias=ID "=")? (partReference=
		//PrerequisiteEntry closure=Closure?)) ";"                    
		//	       / *| (partReference=ExprStatement) * /
		public Group getGroup() { return cGroup; }

		//surpressed?="hidden"? ("when" filter=Filter)? (alias=ID "=")? (partReference=
		//PrerequisiteEntry closure=Closure?)                  
		//	       / *| (partReference=ExprStatement) * /
		public Group getGroup_0() { return cGroup_0; }

		//surpressed?="hidden"?
		public Assignment getSurpressedAssignment_0_0() { return cSurpressedAssignment_0_0; }

		//"hidden"
		public Keyword getSurpressedHiddenKeyword_0_0_0() { return cSurpressedHiddenKeyword_0_0_0; }

		//("when" filter=Filter)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"when"
		public Keyword getWhenKeyword_0_1_0() { return cWhenKeyword_0_1_0; }

		//filter=Filter
		public Assignment getFilterAssignment_0_1_1() { return cFilterAssignment_0_1_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_0_1_1_0() { return cFilterFilterParserRuleCall_0_1_1_0; }

		//(alias=ID "=")?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//alias=ID
		public Assignment getAliasAssignment_0_2_0() { return cAliasAssignment_0_2_0; }

		//ID
		public RuleCall getAliasIDTerminalRuleCall_0_2_0_0() { return cAliasIDTerminalRuleCall_0_2_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_0_2_1() { return cEqualsSignKeyword_0_2_1; }

		//partReference=PrerequisiteEntry closure=Closure?
		public Group getGroup_0_3() { return cGroup_0_3; }

		//partReference=PrerequisiteEntry
		public Assignment getPartReferenceAssignment_0_3_0() { return cPartReferenceAssignment_0_3_0; }

		//PrerequisiteEntry
		public RuleCall getPartReferencePrerequisiteEntryParserRuleCall_0_3_0_0() { return cPartReferencePrerequisiteEntryParserRuleCall_0_3_0_0; }

		//closure=Closure?
		public Assignment getClosureAssignment_0_3_1() { return cClosureAssignment_0_3_1; }

		//Closure
		public RuleCall getClosureClosureParserRuleCall_0_3_1_0() { return cClosureClosureParserRuleCall_0_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class ClosureElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Closure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWithKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cPropertiesKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final Alternatives cAlternatives_2_0_2 = (Alternatives)cGroup_2_0.eContents().get(2);
		private final Group cGroup_2_0_2_0 = (Group)cAlternatives_2_0_2.eContents().get(0);
		private final Keyword cUnsetKeyword_2_0_2_0_0 = (Keyword)cGroup_2_0_2_0.eContents().get(0);
		private final Assignment cUnsetPropertiesAssignment_2_0_2_0_1 = (Assignment)cGroup_2_0_2_0.eContents().get(1);
		private final RuleCall cUnsetPropertiesPropertyNameParserRuleCall_2_0_2_0_1_0 = (RuleCall)cUnsetPropertiesAssignment_2_0_2_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_0_2_0_2 = (Keyword)cGroup_2_0_2_0.eContents().get(2);
		private final Assignment cSetPropertiesAssignment_2_0_2_1 = (Assignment)cAlternatives_2_0_2.eContents().get(1);
		private final RuleCall cSetPropertiesPropertyStatementParserRuleCall_2_0_2_1_0 = (RuleCall)cSetPropertiesAssignment_2_0_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2_0_3 = (Keyword)cGroup_2_0.eContents().get(3);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cAdviceKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cAdviceAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cAdviceCompoundAdviceParserRuleCall_2_1_1_0 = (RuleCall)cAdviceAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Closure:
		//  "with" "{" ("properties" "{" ("unset" unsetProperties+=PropertyName ";"|setProperties
		//  +=PropertyStatement)+ "}"|"advice" advice+=CompoundAdvice)* "}";
		public ParserRule getRule() { return rule; }

		//"with" "{" ("properties" "{" ("unset" unsetProperties+=PropertyName ";"|setProperties
		//+=PropertyStatement)+ "}"|"advice" advice+=CompoundAdvice)* "}"
		public Group getGroup() { return cGroup; }

		//"with"
		public Keyword getWithKeyword_0() { return cWithKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//("properties" "{" ("unset" unsetProperties+=PropertyName ";"|setProperties+=
		//PropertyStatement)+ "}"|"advice" advice+=CompoundAdvice)*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"properties" "{" ("unset" unsetProperties+=PropertyName ";"|setProperties+=
		//PropertyStatement)+ "}"
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"properties"
		public Keyword getPropertiesKeyword_2_0_0() { return cPropertiesKeyword_2_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2_0_1() { return cLeftCurlyBracketKeyword_2_0_1; }

		//("unset" unsetProperties+=PropertyName ";"|setProperties+=PropertyStatement)+
		public Alternatives getAlternatives_2_0_2() { return cAlternatives_2_0_2; }

		//"unset" unsetProperties+=PropertyName ";"
		public Group getGroup_2_0_2_0() { return cGroup_2_0_2_0; }

		//"unset"
		public Keyword getUnsetKeyword_2_0_2_0_0() { return cUnsetKeyword_2_0_2_0_0; }

		//unsetProperties+=PropertyName
		public Assignment getUnsetPropertiesAssignment_2_0_2_0_1() { return cUnsetPropertiesAssignment_2_0_2_0_1; }

		//PropertyName
		public RuleCall getUnsetPropertiesPropertyNameParserRuleCall_2_0_2_0_1_0() { return cUnsetPropertiesPropertyNameParserRuleCall_2_0_2_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2_0_2_0_2() { return cSemicolonKeyword_2_0_2_0_2; }

		//setProperties+=PropertyStatement
		public Assignment getSetPropertiesAssignment_2_0_2_1() { return cSetPropertiesAssignment_2_0_2_1; }

		//PropertyStatement
		public RuleCall getSetPropertiesPropertyStatementParserRuleCall_2_0_2_1_0() { return cSetPropertiesPropertyStatementParserRuleCall_2_0_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2_0_3() { return cRightCurlyBracketKeyword_2_0_3; }

		//"advice" advice+=CompoundAdvice
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"advice"
		public Keyword getAdviceKeyword_2_1_0() { return cAdviceKeyword_2_1_0; }

		//advice+=CompoundAdvice
		public Assignment getAdviceAssignment_2_1_1() { return cAdviceAssignment_2_1_1; }

		//CompoundAdvice
		public RuleCall getAdviceCompoundAdviceParserRuleCall_2_1_1_0() { return cAdviceCompoundAdviceParserRuleCall_2_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class PrerequisiteEntryElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrerequisiteEntry");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPartInSelfParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCapabilityReferencedPartParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCompoundReferencesParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cExprStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//PrerequisiteEntry:
		//  PartInSelf|CapabilityReferencedPart|CompoundReferences|ExprStatement;
		public ParserRule getRule() { return rule; }

		//PartInSelf|CapabilityReferencedPart|CompoundReferences|ExprStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//PartInSelf
		public RuleCall getPartInSelfParserRuleCall_0() { return cPartInSelfParserRuleCall_0; }

		//CapabilityReferencedPart
		public RuleCall getCapabilityReferencedPartParserRuleCall_1() { return cCapabilityReferencedPartParserRuleCall_1; }

		//CompoundReferences
		public RuleCall getCompoundReferencesParserRuleCall_2() { return cCompoundReferencesParserRuleCall_2; }

		//ExprStatement
		public RuleCall getExprStatementParserRuleCall_3() { return cExprStatementParserRuleCall_3; }
	}

	public class PartInSelfElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PartInSelf");
		private final Assignment cPartNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPartNamePartNameParserRuleCall_0 = (RuleCall)cPartNameAssignment.eContents().get(0);
		
		//PartInSelf:
		//  partName=PartName; 
		//	
		//	      // i.e. self#partName
		public ParserRule getRule() { return rule; }

		//partName=PartName      // i.e. self#partName
		public Assignment getPartNameAssignment() { return cPartNameAssignment; }

		//PartName    // i.e. self#partName
		public RuleCall getPartNamePartNameParserRuleCall_0() { return cPartNamePartNameParserRuleCall_0; }
	}

	public class CapabilityReferencedPartElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CapabilityReferencedPart");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cInterfaceAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cInterfaceInterfaceNameParserRuleCall_0_0_0 = (RuleCall)cInterfaceAssignment_0_0.eContents().get(0);
		private final Keyword cSolidusKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cNameUnitNameParserRuleCall_0_2_0 = (RuleCall)cNameAssignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cSolidusKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cRangeAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cRangeVersionRangeParserRuleCall_0_3_1_0 = (RuleCall)cRangeAssignment_0_3_1.eContents().get(0);
		private final Keyword cNumberSignKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Assignment cPartNameAssignment_0_5 = (Assignment)cGroup_0.eContents().get(5);
		private final RuleCall cPartNamePartNameParserRuleCall_0_5_0 = (RuleCall)cPartNameAssignment_0_5.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cInterfaceAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cInterfaceInterfaceNameParserRuleCall_1_0_0 = (RuleCall)cInterfaceAssignment_1_0.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cNameUnitNameParserRuleCall_1_2_0 = (RuleCall)cNameAssignment_1_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cSolidusKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cRangeAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cRangeVersionRangeParserRuleCall_1_3_1_0 = (RuleCall)cRangeAssignment_1_3_1.eContents().get(0);
		
		//CapabilityReferencedPart:
		//  interface=InterfaceName "/" name=UnitName ("/" range=VersionRange)? "#" partName=
		//  PartName|interface=InterfaceName "/" name=UnitName ("/" range=VersionRange)?;
		public ParserRule getRule() { return rule; }

		//interface=InterfaceName "/" name=UnitName ("/" range=VersionRange)? "#" partName=
		//PartName|interface=InterfaceName "/" name=UnitName ("/" range=VersionRange)?
		public Alternatives getAlternatives() { return cAlternatives; }

		//interface=InterfaceName "/" name=UnitName ("/" range=VersionRange)? "#" partName=
		//PartName
		public Group getGroup_0() { return cGroup_0; }

		//interface=InterfaceName
		public Assignment getInterfaceAssignment_0_0() { return cInterfaceAssignment_0_0; }

		//InterfaceName
		public RuleCall getInterfaceInterfaceNameParserRuleCall_0_0_0() { return cInterfaceInterfaceNameParserRuleCall_0_0_0; }

		//"/"
		public Keyword getSolidusKeyword_0_1() { return cSolidusKeyword_0_1; }

		//name=UnitName
		public Assignment getNameAssignment_0_2() { return cNameAssignment_0_2; }

		//UnitName
		public RuleCall getNameUnitNameParserRuleCall_0_2_0() { return cNameUnitNameParserRuleCall_0_2_0; }

		//("/" range=VersionRange)?
		public Group getGroup_0_3() { return cGroup_0_3; }

		//"/"
		public Keyword getSolidusKeyword_0_3_0() { return cSolidusKeyword_0_3_0; }

		//range=VersionRange
		public Assignment getRangeAssignment_0_3_1() { return cRangeAssignment_0_3_1; }

		//VersionRange
		public RuleCall getRangeVersionRangeParserRuleCall_0_3_1_0() { return cRangeVersionRangeParserRuleCall_0_3_1_0; }

		//"#"
		public Keyword getNumberSignKeyword_0_4() { return cNumberSignKeyword_0_4; }

		//partName=PartName
		public Assignment getPartNameAssignment_0_5() { return cPartNameAssignment_0_5; }

		//PartName
		public RuleCall getPartNamePartNameParserRuleCall_0_5_0() { return cPartNamePartNameParserRuleCall_0_5_0; }

		//interface=InterfaceName "/" name=UnitName ("/" range=VersionRange)?
		public Group getGroup_1() { return cGroup_1; }

		//interface=InterfaceName
		public Assignment getInterfaceAssignment_1_0() { return cInterfaceAssignment_1_0; }

		//InterfaceName
		public RuleCall getInterfaceInterfaceNameParserRuleCall_1_0_0() { return cInterfaceInterfaceNameParserRuleCall_1_0_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }

		//name=UnitName
		public Assignment getNameAssignment_1_2() { return cNameAssignment_1_2; }

		//UnitName
		public RuleCall getNameUnitNameParserRuleCall_1_2_0() { return cNameUnitNameParserRuleCall_1_2_0; }

		//("/" range=VersionRange)?
		public Group getGroup_1_3() { return cGroup_1_3; }

		//"/"
		public Keyword getSolidusKeyword_1_3_0() { return cSolidusKeyword_1_3_0; }

		//range=VersionRange
		public Assignment getRangeAssignment_1_3_1() { return cRangeAssignment_1_3_1; }

		//VersionRange
		public RuleCall getRangeVersionRangeParserRuleCall_1_3_1_0() { return cRangeVersionRangeParserRuleCall_1_3_1_0; }
	}

	public class CompoundReferencesElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundReferences");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPrerequisitesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPrerequisitesPrerequisiteParserRuleCall_1_0 = (RuleCall)cPrerequisitesAssignment_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//CompoundReferences:
		//  "{" prerequisites+=Prerequisite* "}";
		public ParserRule getRule() { return rule; }

		//"{" prerequisites+=Prerequisite* "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//prerequisites+=Prerequisite*
		public Assignment getPrerequisitesAssignment_1() { return cPrerequisitesAssignment_1; }

		//Prerequisite
		public RuleCall getPrerequisitesPrerequisiteParserRuleCall_1_0() { return cPrerequisitesPrerequisiteParserRuleCall_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class PartElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVisibilityAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVisibilityVisibilityEnumRuleCall_0_0 = (RuleCall)cVisibilityAssignment_0.eContents().get(0);
		private final Assignment cExecutionModeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExecutionModeExecutionModeEnumRuleCall_1_0 = (RuleCall)cExecutionModeAssignment_1.eContents().get(0);
		private final RuleCall cPartNameParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cProvidesKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cProvidedCapabilitiesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cProvidedCapabilitiesProvidedCapabilityParserRuleCall_3_1_0 = (RuleCall)cProvidedCapabilitiesAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cProvidedCapabilitiesAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cProvidedCapabilitiesProvidedCapabilityParserRuleCall_3_2_1_0 = (RuleCall)cProvidedCapabilitiesAssignment_3_2_1.eContents().get(0);
		private final Assignment cAssertsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAssertsPreConditionAssertParserRuleCall_4_0 = (RuleCall)cAssertsAssignment_4.eContents().get(0);
		private final Assignment cAssertsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cAssertsPostConditionAssertParserRuleCall_5_0 = (RuleCall)cAssertsAssignment_5.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cPropertiesKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cPropertiesAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cPropertiesPropertyStatementsParserRuleCall_7_1_0 = (RuleCall)cPropertiesAssignment_7_1.eContents().get(0);
		private final Assignment cAdviceAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cAdviceAdviceParserRuleCall_8_0 = (RuleCall)cAdviceAssignment_8.eContents().get(0);
		private final Assignment cResultGroupAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cResultGroupActionInputGroupParserRuleCall_9_0 = (RuleCall)cResultGroupAssignment_9.eContents().get(0);
		private final Assignment cLayoutAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cLayoutLayoutParserRuleCall_10_0 = (RuleCall)cLayoutAssignment_10.eContents().get(0);
		private final Assignment cStatementsAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final RuleCall cStatementsStatementsParserRuleCall_11_0 = (RuleCall)cStatementsAssignment_11.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_12 = (Keyword)cGroup.eContents().get(12);
		
		//Part:
		//  visibility=Visibility? executionMode=ExecutionMode? PartName ("provides"
		//  providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
		//  ProvidedCapability)*)? asserts+=PreConditionAssert? asserts+=PostConditionAssert?
		//  "{" ("properties" properties+=PropertyStatements)? advice=Advice? resultGroup=
		//  ActionInputGroup? layout+=Layout* statements=Statements "}"; 
		//          
		//          
		//	 / *'part'* /   
		////	 'actor' QualifiedName '(' (actorParameters += Parameter (',' actorParameters += Parameter)*)? ')'
		public ParserRule getRule() { return rule; }

		//visibility=Visibility? executionMode=ExecutionMode? PartName ("provides"
		//providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
		//ProvidedCapability)*)? asserts+=PreConditionAssert? asserts+=PostConditionAssert?
		//"{" ("properties" properties+=PropertyStatements)? advice=Advice? resultGroup=
		//ActionInputGroup? layout+=Layout* statements=Statements "}"       
		//          
		//	 / *'part'* /   
		////	 'actor' QualifiedName '(' (actorParameters += Parameter (',' actorParameters += Parameter)*)? ')'
		public Group getGroup() { return cGroup; }

		//visibility=Visibility?
		public Assignment getVisibilityAssignment_0() { return cVisibilityAssignment_0; }

		//Visibility
		public RuleCall getVisibilityVisibilityEnumRuleCall_0_0() { return cVisibilityVisibilityEnumRuleCall_0_0; }

		//executionMode=ExecutionMode?
		public Assignment getExecutionModeAssignment_1() { return cExecutionModeAssignment_1; }

		//ExecutionMode
		public RuleCall getExecutionModeExecutionModeEnumRuleCall_1_0() { return cExecutionModeExecutionModeEnumRuleCall_1_0; }

		//PartName 
		//	 / *'part'* /   
		////	 'actor' QualifiedName '(' (actorParameters += Parameter (',' actorParameters += Parameter)*)? ')'
		public RuleCall getPartNameParserRuleCall_2() { return cPartNameParserRuleCall_2; }

		//("provides" providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
		//ProvidedCapability)*)?
		public Group getGroup_3() { return cGroup_3; }

		//"provides"
		public Keyword getProvidesKeyword_3_0() { return cProvidesKeyword_3_0; }

		//providedCapabilities+=ProvidedCapability
		public Assignment getProvidedCapabilitiesAssignment_3_1() { return cProvidedCapabilitiesAssignment_3_1; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilitiesProvidedCapabilityParserRuleCall_3_1_0() { return cProvidedCapabilitiesProvidedCapabilityParserRuleCall_3_1_0; }

		//("," providedCapabilities+=ProvidedCapability)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }

		//providedCapabilities+=ProvidedCapability
		public Assignment getProvidedCapabilitiesAssignment_3_2_1() { return cProvidedCapabilitiesAssignment_3_2_1; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilitiesProvidedCapabilityParserRuleCall_3_2_1_0() { return cProvidedCapabilitiesProvidedCapabilityParserRuleCall_3_2_1_0; }

		//asserts+=PreConditionAssert?
		public Assignment getAssertsAssignment_4() { return cAssertsAssignment_4; }

		//PreConditionAssert
		public RuleCall getAssertsPreConditionAssertParserRuleCall_4_0() { return cAssertsPreConditionAssertParserRuleCall_4_0; }

		//asserts+=PostConditionAssert?
		public Assignment getAssertsAssignment_5() { return cAssertsAssignment_5; }

		//PostConditionAssert
		public RuleCall getAssertsPostConditionAssertParserRuleCall_5_0() { return cAssertsPostConditionAssertParserRuleCall_5_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_6() { return cLeftCurlyBracketKeyword_6; }

		//("properties" properties+=PropertyStatements)?
		public Group getGroup_7() { return cGroup_7; }

		//"properties"
		public Keyword getPropertiesKeyword_7_0() { return cPropertiesKeyword_7_0; }

		//properties+=PropertyStatements
		public Assignment getPropertiesAssignment_7_1() { return cPropertiesAssignment_7_1; }

		//PropertyStatements
		public RuleCall getPropertiesPropertyStatementsParserRuleCall_7_1_0() { return cPropertiesPropertyStatementsParserRuleCall_7_1_0; }

		//advice=Advice?
		public Assignment getAdviceAssignment_8() { return cAdviceAssignment_8; }

		//Advice
		public RuleCall getAdviceAdviceParserRuleCall_8_0() { return cAdviceAdviceParserRuleCall_8_0; }

		//resultGroup=ActionInputGroup?
		public Assignment getResultGroupAssignment_9() { return cResultGroupAssignment_9; }

		//ActionInputGroup
		public RuleCall getResultGroupActionInputGroupParserRuleCall_9_0() { return cResultGroupActionInputGroupParserRuleCall_9_0; }

		//layout+=Layout*
		public Assignment getLayoutAssignment_10() { return cLayoutAssignment_10; }

		//Layout
		public RuleCall getLayoutLayoutParserRuleCall_10_0() { return cLayoutLayoutParserRuleCall_10_0; }

		//statements=Statements
		public Assignment getStatementsAssignment_11() { return cStatementsAssignment_11; }

		//Statements
		public RuleCall getStatementsStatementsParserRuleCall_11_0() { return cStatementsStatementsParserRuleCall_11_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_12() { return cRightCurlyBracketKeyword_12; }
	}

	public class ParameterElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValExpressionParserRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//Parameter:
		//  val=Expression;
		public ParserRule getRule() { return rule; }

		//val=Expression
		public Assignment getValAssignment() { return cValAssignment; }

		//Expression
		public RuleCall getValExpressionParserRuleCall_0() { return cValExpressionParserRuleCall_0; }
	}

	public class LayoutElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Layout");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cFilterAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_0_1_0 = (RuleCall)cFilterAssignment_0_1.eContents().get(0);
		private final Keyword cLayoutKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cAssertsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAssertsPostConditionAssertParserRuleCall_3_0 = (RuleCall)cAssertsAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cPathsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cPathsPathGroupParserRuleCall_5_0 = (RuleCall)cPathsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Layout:
		//  ("when" filter=Filter)? "layout" name=QualifiedName? asserts+=PostConditionAssert?
		//  "{" paths+=PathGroup* "}"; 
		//	
		//    
		//	            
		////		(asserts += PreConditionAssert)? // precondition does not make sense
		public ParserRule getRule() { return rule; }

		//("when" filter=Filter)? "layout" name=QualifiedName? asserts+=PostConditionAssert?
		//"{" paths+=PathGroup* "}"             
		////		(asserts += PreConditionAssert)? // precondition does not make sense
		public Group getGroup() { return cGroup; }

		//("when" filter=Filter)?
		public Group getGroup_0() { return cGroup_0; }

		//"when"
		public Keyword getWhenKeyword_0_0() { return cWhenKeyword_0_0; }

		//filter=Filter
		public Assignment getFilterAssignment_0_1() { return cFilterAssignment_0_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_0_1_0() { return cFilterFilterParserRuleCall_0_1_0; }

		//"layout"
		public Keyword getLayoutKeyword_1() { return cLayoutKeyword_1; }

		//name=QualifiedName?
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }

		//asserts+=PostConditionAssert?
		public Assignment getAssertsAssignment_3() { return cAssertsAssignment_3; }

		//PostConditionAssert
		public RuleCall getAssertsPostConditionAssertParserRuleCall_3_0() { return cAssertsPostConditionAssertParserRuleCall_3_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//paths+=PathGroup*
		public Assignment getPathsAssignment_5() { return cPathsAssignment_5; }

		//PathGroup
		public RuleCall getPathsPathGroupParserRuleCall_5_0() { return cPathsPathGroupParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class ActionInputGroupElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ActionInputGroup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGroupKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAssertsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAssertsPreConditionAssertParserRuleCall_1_0 = (RuleCall)cAssertsAssignment_1.eContents().get(0);
		private final Assignment cAssertsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAssertsPostConditionAssertParserRuleCall_2_0 = (RuleCall)cAssertsAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPrerequisitesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPrerequisitesPrerequisiteParserRuleCall_4_0 = (RuleCall)cPrerequisitesAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ActionInputGroup:
		//  "group" asserts+=PreConditionAssert? asserts+=PostConditionAssert? "{" prerequisites
		//  +=Prerequisite* "}";
		public ParserRule getRule() { return rule; }

		//"group" asserts+=PreConditionAssert? asserts+=PostConditionAssert? "{" prerequisites
		//+=Prerequisite* "}"
		public Group getGroup() { return cGroup; }

		//"group"
		public Keyword getGroupKeyword_0() { return cGroupKeyword_0; }

		//asserts+=PreConditionAssert?
		public Assignment getAssertsAssignment_1() { return cAssertsAssignment_1; }

		//PreConditionAssert
		public RuleCall getAssertsPreConditionAssertParserRuleCall_1_0() { return cAssertsPreConditionAssertParserRuleCall_1_0; }

		//asserts+=PostConditionAssert?
		public Assignment getAssertsAssignment_2() { return cAssertsAssignment_2; }

		//PostConditionAssert
		public RuleCall getAssertsPostConditionAssertParserRuleCall_2_0() { return cAssertsPostConditionAssertParserRuleCall_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//prerequisites+=Prerequisite*
		public Assignment getPrerequisitesAssignment_4() { return cPrerequisitesAssignment_4; }

		//Prerequisite
		public RuleCall getPrerequisitesPrerequisiteParserRuleCall_4_0() { return cPrerequisitesPrerequisiteParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class RepositoryConfigurationElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RepositoryConfiguration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cLocationAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cLocationURIParserRuleCall_0_0_0 = (RuleCall)cLocationAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Keyword cResolverKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cResolverClassAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cResolverClassQualifiedNameParserRuleCall_0_1_1_0 = (RuleCall)cResolverClassAssignment_0_1_1.eContents().get(0);
		private final Assignment cAdviceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAdviceCompoundAdviceParserRuleCall_1_0 = (RuleCall)cAdviceAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//RepositoryConfiguration:
		//  (location=URI|"resolver" resolverClass=QualifiedName) advice=CompoundAdvice? ";"; 
		//
		//
		//	              
		//	
		//
		/// *
		// ** URI TODO: Would like to have better parsing of URL - don't know if possible to push this to lexer
		// ** as we may want to support namespaces (using 'ns:' prefix) (for importing b3 files, common advice, rules etc.).
		// ** The ':' clashes with 'scheme:' which is the only known part in an opaque URI. 
		// * /
		public ParserRule getRule() { return rule; }

		//(location=URI|"resolver" resolverClass=QualifiedName) advice=CompoundAdvice? ";"
		public Group getGroup() { return cGroup; }

		//location=URI|"resolver" resolverClass=QualifiedName
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//location=URI
		public Assignment getLocationAssignment_0_0() { return cLocationAssignment_0_0; }

		//URI
		public RuleCall getLocationURIParserRuleCall_0_0_0() { return cLocationURIParserRuleCall_0_0_0; }

		//"resolver" resolverClass=QualifiedName
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"resolver"
		public Keyword getResolverKeyword_0_1_0() { return cResolverKeyword_0_1_0; }

		//resolverClass=QualifiedName
		public Assignment getResolverClassAssignment_0_1_1() { return cResolverClassAssignment_0_1_1; }

		//QualifiedName
		public RuleCall getResolverClassQualifiedNameParserRuleCall_0_1_1_0() { return cResolverClassQualifiedNameParserRuleCall_0_1_1_0; }

		//advice=CompoundAdvice?
		public Assignment getAdviceAssignment_1() { return cAdviceAssignment_1; }

		//CompoundAdvice
		public RuleCall getAdviceCompoundAdviceParserRuleCall_1_0() { return cAdviceCompoundAdviceParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class URIElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "URI");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//URI returns ecore::EString:
		//  STRING; 
		//
		/// *
		// ** URI TODO: Would like to have better parsing of URL - don't know if possible to push this to lexer
		// ** as we may want to support namespaces (using 'ns:' prefix) (for importing b3 files, common advice, rules etc.).
		// ** The ':' clashes with 'scheme:' which is the only known part in an opaque URI. 
		// * /
		//    
		//	
		//
		/// * ADVICE
		// ** TODO: Had to use '?' instead if '*', and '??' intead of '**' as these operators are intermixed with / which sometimes
		// ** makes them look like comments. (Forbidding // comments is not the wanted sollution). 
		// **
		// * /
		public ParserRule getRule() { return rule; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}

	public class NamedAdviceElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamedAdvice");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cAdviceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAdviceCompoundAdviceParserRuleCall_1_0 = (RuleCall)cAdviceAssignment_1.eContents().get(0);
		
		//NamedAdvice:
		//  name=ID? advice=CompoundAdvice; 
		//
		/// * ADVICE
		// ** TODO: Had to use '?' instead if '*', and '??' intead of '**' as these operators are intermixed with / which sometimes
		// ** makes them look like comments. (Forbidding // comments is not the wanted sollution). 
		// **
		// * /
		public ParserRule getRule() { return rule; }

		//name=ID? advice=CompoundAdvice
		public Group getGroup() { return cGroup; }

		//name=ID?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//advice=CompoundAdvice
		public Assignment getAdviceAssignment_1() { return cAdviceAssignment_1; }

		//CompoundAdvice
		public RuleCall getAdviceCompoundAdviceParserRuleCall_1_0() { return cAdviceCompoundAdviceParserRuleCall_1_0; }
	}

	public class AdviceElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Advice");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAdviceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cCompoundAdviceParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Advice:
		//  "advice" CompoundAdvice;
		public ParserRule getRule() { return rule; }

		//"advice" CompoundAdvice
		public Group getGroup() { return cGroup; }

		//"advice"
		public Keyword getAdviceKeyword_0() { return cAdviceKeyword_0; }

		//CompoundAdvice
		public RuleCall getCompoundAdviceParserRuleCall_1() { return cCompoundAdviceParserRuleCall_1; }
	}

	public class CompoundAdviceElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundAdvice");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cAdviceAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cAdviceAdviceStatementParserRuleCall_1_0_0 = (RuleCall)cAdviceAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//CompoundAdvice:
		//  "{" (advice+=AdviceStatement ";")* "}";
		public ParserRule getRule() { return rule; }

		//"{" (advice+=AdviceStatement ";")* "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//(advice+=AdviceStatement ";")*
		public Group getGroup_1() { return cGroup_1; }

		//advice+=AdviceStatement
		public Assignment getAdviceAssignment_1_0() { return cAdviceAssignment_1_0; }

		//AdviceStatement
		public RuleCall getAdviceAdviceStatementParserRuleCall_1_0_0() { return cAdviceAdviceStatementParserRuleCall_1_0_0; }

		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class AdviceStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdviceStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPathAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPathAdvicePathParserRuleCall_0_0 = (RuleCall)cPathAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cValueAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_0_1_0 = (RuleCall)cValueAssignment_1_0_1.eContents().get(0);
		private final Assignment cAdviceAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cAdviceCompoundAdviceParserRuleCall_1_1_0 = (RuleCall)cAdviceAssignment_1_1.eContents().get(0);
		
		//AdviceStatement:
		//  path=AdvicePath ("=" value=Expression|advice=CompoundAdvice);
		public ParserRule getRule() { return rule; }

		//path=AdvicePath ("=" value=Expression|advice=CompoundAdvice)
		public Group getGroup() { return cGroup; }

		//path=AdvicePath
		public Assignment getPathAssignment_0() { return cPathAssignment_0; }

		//AdvicePath
		public RuleCall getPathAdvicePathParserRuleCall_0_0() { return cPathAdvicePathParserRuleCall_0_0; }

		//"=" value=Expression|advice=CompoundAdvice
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"=" value=Expression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_0_0() { return cEqualsSignKeyword_1_0_0; }

		//value=Expression
		public Assignment getValueAssignment_1_0_1() { return cValueAssignment_1_0_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_0_1_0() { return cValueExpressionParserRuleCall_1_0_1_0; }

		//advice=CompoundAdvice
		public Assignment getAdviceAssignment_1_1() { return cAdviceAssignment_1_1; }

		//CompoundAdvice
		public RuleCall getAdviceCompoundAdviceParserRuleCall_1_1_0() { return cAdviceCompoundAdviceParserRuleCall_1_1_0; }
	}

	public class AdvicePathElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdvicePath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPathElementsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPathElementsAdvicePathSeparatorParserRuleCall_0_0 = (RuleCall)cPathElementsAssignment_0.eContents().get(0);
		private final Assignment cPathElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathElementsAdvicePathElementParserRuleCall_1_0 = (RuleCall)cPathElementsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cPathElementsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cPathElementsAdvicePathSeparatorParserRuleCall_2_0_0 = (RuleCall)cPathElementsAssignment_2_0.eContents().get(0);
		private final Assignment cPathElementAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPathElementAdvicePathElementParserRuleCall_2_1_0 = (RuleCall)cPathElementAssignment_2_1.eContents().get(0);
		
		//AdvicePath:
		//  pathElements+=AdvicePathSeparator? pathElements+=AdvicePathElement (pathElements+=
		//  AdvicePathSeparator pathElement+=AdvicePathElement)*;
		public ParserRule getRule() { return rule; }

		//pathElements+=AdvicePathSeparator? pathElements+=AdvicePathElement (pathElements+=
		//AdvicePathSeparator pathElement+=AdvicePathElement)*
		public Group getGroup() { return cGroup; }

		//pathElements+=AdvicePathSeparator?
		public Assignment getPathElementsAssignment_0() { return cPathElementsAssignment_0; }

		//AdvicePathSeparator
		public RuleCall getPathElementsAdvicePathSeparatorParserRuleCall_0_0() { return cPathElementsAdvicePathSeparatorParserRuleCall_0_0; }

		//pathElements+=AdvicePathElement
		public Assignment getPathElementsAssignment_1() { return cPathElementsAssignment_1; }

		//AdvicePathElement
		public RuleCall getPathElementsAdvicePathElementParserRuleCall_1_0() { return cPathElementsAdvicePathElementParserRuleCall_1_0; }

		//(pathElements+=AdvicePathSeparator pathElement+=AdvicePathElement)*
		public Group getGroup_2() { return cGroup_2; }

		//pathElements+=AdvicePathSeparator
		public Assignment getPathElementsAssignment_2_0() { return cPathElementsAssignment_2_0; }

		//AdvicePathSeparator
		public RuleCall getPathElementsAdvicePathSeparatorParserRuleCall_2_0_0() { return cPathElementsAdvicePathSeparatorParserRuleCall_2_0_0; }

		//pathElement+=AdvicePathElement
		public Assignment getPathElementAssignment_2_1() { return cPathElementAssignment_2_1; }

		//AdvicePathElement
		public RuleCall getPathElementAdvicePathElementParserRuleCall_2_1_0() { return cPathElementAdvicePathElementParserRuleCall_2_1_0; }
	}

	public class AdvicePathSeparatorElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdvicePathSeparator");
		private final RuleCall cAdvicePathChildrenParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//AdvicePathSeparator returns AdvicePathElement:
		//  AdvicePathChildren;
		public ParserRule getRule() { return rule; }

		//AdvicePathChildren
		public RuleCall getAdvicePathChildrenParserRuleCall() { return cAdvicePathChildrenParserRuleCall; }
	}

	public class AdvicePathChildrenElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdvicePathChildren");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAdvicePathChildrenAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//AdvicePathChildren:
		//  {AdvicePathChildren} "/";
		public ParserRule getRule() { return rule; }

		//{AdvicePathChildren} "/"
		public Group getGroup() { return cGroup; }

		//{AdvicePathChildren}
		public Action getAdvicePathChildrenAction_0() { return cAdvicePathChildrenAction_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }
	}

	public class AdvicePathElementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdvicePathElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cNodeAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Alternatives cNodeAlternatives_0_0_0 = (Alternatives)cNodeAssignment_0_0.eContents().get(0);
		private final RuleCall cNodeQualifiedNameParserRuleCall_0_0_0_0 = (RuleCall)cNodeAlternatives_0_0_0.eContents().get(0);
		private final RuleCall cNodeWildcardNodeParserRuleCall_0_0_0_1 = (RuleCall)cNodeAlternatives_0_0_0.eContents().get(1);
		private final Keyword cNodeFullStopKeyword_0_0_0_2 = (Keyword)cNodeAlternatives_0_0_0.eContents().get(2);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cPredicateAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cPredicateExpressionParserRuleCall_0_1_1_0 = (RuleCall)cPredicateAssignment_0_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_1_2 = (Keyword)cGroup_0_1.eContents().get(2);
		private final Assignment cNodeAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cNodeFullStopFullStopKeyword_1_0 = (Keyword)cNodeAssignment_1.eContents().get(0);
		
		//AdvicePathElement:
		//  node=( QualifiedName | WildcardNode | "." ) ("[" predicate=Expression "]")?|node="..";
		public ParserRule getRule() { return rule; }

		//node=( QualifiedName | WildcardNode | "." ) ("[" predicate=Expression "]")?|node=".."
		public Alternatives getAlternatives() { return cAlternatives; }

		//node=( QualifiedName | WildcardNode | "." ) ("[" predicate=Expression "]")?
		public Group getGroup_0() { return cGroup_0; }

		//node=( QualifiedName | WildcardNode | "." )
		public Assignment getNodeAssignment_0_0() { return cNodeAssignment_0_0; }

		//QualifiedName|WildcardNode|"."
		public Alternatives getNodeAlternatives_0_0_0() { return cNodeAlternatives_0_0_0; }

		//QualifiedName
		public RuleCall getNodeQualifiedNameParserRuleCall_0_0_0_0() { return cNodeQualifiedNameParserRuleCall_0_0_0_0; }

		//WildcardNode
		public RuleCall getNodeWildcardNodeParserRuleCall_0_0_0_1() { return cNodeWildcardNodeParserRuleCall_0_0_0_1; }

		//"."
		public Keyword getNodeFullStopKeyword_0_0_0_2() { return cNodeFullStopKeyword_0_0_0_2; }

		//("[" predicate=Expression "]")?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_1_0() { return cLeftSquareBracketKeyword_0_1_0; }

		//predicate=Expression
		public Assignment getPredicateAssignment_0_1_1() { return cPredicateAssignment_0_1_1; }

		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_0_1_1_0() { return cPredicateExpressionParserRuleCall_0_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_1_2() { return cRightSquareBracketKeyword_0_1_2; }

		//node=".."
		public Assignment getNodeAssignment_1() { return cNodeAssignment_1; }

		//".."
		public Keyword getNodeFullStopFullStopKeyword_1_0() { return cNodeFullStopFullStopKeyword_1_0; }
	}

	public class WildcardNodeElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WildcardNode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuestionMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//WildcardNode returns ecore::EString:
		//  "?" "?"?;
		public ParserRule getRule() { return rule; }

		//"?" "?"?
		public Group getGroup() { return cGroup; }

		//"?"
		public Keyword getQuestionMarkKeyword_0() { return cQuestionMarkKeyword_0; }

		//"?"?
		public Keyword getQuestionMarkKeyword_1() { return cQuestionMarkKeyword_1; }
	}

	public class FilterElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Filter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredicateExpressionParserRuleCall_1_0 = (RuleCall)cPredicateAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Filter:
		//  "(" predicate=Expression ")"; 
		//
		//              
		//
		/// * ASSERTS * /
		public ParserRule getRule() { return rule; }

		//"(" predicate=Expression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//predicate=Expression
		public Assignment getPredicateAssignment_1() { return cPredicateAssignment_1; }

		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_1_0() { return cPredicateExpressionParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class PreConditionAssertElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PreConditionAssert");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cScopeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cScopePreconditionKeyword_0_0 = (Keyword)cScopeAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAssertsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAssertsAssertionExpressionParserRuleCall_2_0 = (RuleCall)cAssertsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PreConditionAssert:
		//  scope="precondition" "{" asserts+=AssertionExpression* "}"; 
		//
		/// * ASSERTS * /
		public ParserRule getRule() { return rule; }

		//scope="precondition" "{" asserts+=AssertionExpression* "}"
		public Group getGroup() { return cGroup; }

		//scope="precondition"
		public Assignment getScopeAssignment_0() { return cScopeAssignment_0; }

		//"precondition"
		public Keyword getScopePreconditionKeyword_0_0() { return cScopePreconditionKeyword_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//asserts+=AssertionExpression*
		public Assignment getAssertsAssignment_2() { return cAssertsAssignment_2; }

		//AssertionExpression
		public RuleCall getAssertsAssertionExpressionParserRuleCall_2_0() { return cAssertsAssertionExpressionParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class PostConditionAssertElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostConditionAssert");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cScopeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cScopePostconditionKeyword_0_0 = (Keyword)cScopeAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAssertsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAssertsAssertionExpressionParserRuleCall_2_0 = (RuleCall)cAssertsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PostConditionAssert:
		//  scope="postcondition" "{" asserts+=AssertionExpression* "}";
		public ParserRule getRule() { return rule; }

		//scope="postcondition" "{" asserts+=AssertionExpression* "}"
		public Group getGroup() { return cGroup; }

		//scope="postcondition"
		public Assignment getScopeAssignment_0() { return cScopeAssignment_0; }

		//"postcondition"
		public Keyword getScopePostconditionKeyword_0_0() { return cScopePostconditionKeyword_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//asserts+=AssertionExpression*
		public Assignment getAssertsAssignment_2() { return cAssertsAssignment_2; }

		//AssertionExpression
		public RuleCall getAssertsAssertionExpressionParserRuleCall_2_0() { return cAssertsAssertionExpressionParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class AssertionExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAssertKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cMessageAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cMessageSTRINGTerminalRuleCall_2_1_0 = (RuleCall)cMessageAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//AssertionExpression:
		//  "assert" expr=Expression ("," message=STRING)? ";"; 
		//
		//             
		//
		//
		/// * STATEMENTS * /
		public ParserRule getRule() { return rule; }

		//"assert" expr=Expression ("," message=STRING)? ";"
		public Group getGroup() { return cGroup; }

		//"assert"
		public Keyword getAssertKeyword_0() { return cAssertKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//("," message=STRING)?
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//message=STRING
		public Assignment getMessageAssignment_2_1() { return cMessageAssignment_2_1; }

		//STRING
		public RuleCall getMessageSTRINGTerminalRuleCall_2_1_0() { return cMessageSTRINGTerminalRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class StatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSwitchStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWhileStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cForStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cDoWhileStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cCompoundStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final RuleCall cVarExpressionParserRuleCall_6_0 = (RuleCall)cGroup_6.eContents().get(0);
		private final Keyword cSemicolonKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final RuleCall cBreakStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cContinueStatementParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cReturnStatementParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cFunctionStatementParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cLabelStatementParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cThrowStatementParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cTryCatchStatementParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cWithStatementParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		
		//Statement:
		//  IfStatement|SwitchStatement|WhileStatement|ForStatement|DoWhileStatement|
		//  CompoundStatement|VarExpression? ";"|BreakStatement|ContinueStatement|
		//  ReturnStatement|FunctionStatement|LabelStatement|ThrowStatement|
		//  TryCatchStatement|WithStatement; 
		//
		/// * STATEMENTS * /
		public ParserRule getRule() { return rule; }

		//IfStatement|SwitchStatement|WhileStatement|ForStatement|DoWhileStatement|
		//CompoundStatement|VarExpression? ";"|BreakStatement|ContinueStatement|
		//ReturnStatement|FunctionStatement|LabelStatement|ThrowStatement|
		//TryCatchStatement|WithStatement 
		//
		/// * STATEMENTS * /
		public Alternatives getAlternatives() { return cAlternatives; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_0() { return cIfStatementParserRuleCall_0; }

		//SwitchStatement
		public RuleCall getSwitchStatementParserRuleCall_1() { return cSwitchStatementParserRuleCall_1; }

		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_2() { return cWhileStatementParserRuleCall_2; }

		//ForStatement
		public RuleCall getForStatementParserRuleCall_3() { return cForStatementParserRuleCall_3; }

		//DoWhileStatement
		public RuleCall getDoWhileStatementParserRuleCall_4() { return cDoWhileStatementParserRuleCall_4; }

		//CompoundStatement
		public RuleCall getCompoundStatementParserRuleCall_5() { return cCompoundStatementParserRuleCall_5; }

		//VarExpression? ";"
		public Group getGroup_6() { return cGroup_6; }

		//VarExpression?
		public RuleCall getVarExpressionParserRuleCall_6_0() { return cVarExpressionParserRuleCall_6_0; }

		//";"
		public Keyword getSemicolonKeyword_6_1() { return cSemicolonKeyword_6_1; }

		//BreakStatement
		public RuleCall getBreakStatementParserRuleCall_7() { return cBreakStatementParserRuleCall_7; }

		//ContinueStatement
		public RuleCall getContinueStatementParserRuleCall_8() { return cContinueStatementParserRuleCall_8; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_9() { return cReturnStatementParserRuleCall_9; }

		//FunctionStatement
		public RuleCall getFunctionStatementParserRuleCall_10() { return cFunctionStatementParserRuleCall_10; }

		//LabelStatement
		public RuleCall getLabelStatementParserRuleCall_11() { return cLabelStatementParserRuleCall_11; }

		//ThrowStatement
		public RuleCall getThrowStatementParserRuleCall_12() { return cThrowStatementParserRuleCall_12; }

		//TryCatchStatement
		public RuleCall getTryCatchStatementParserRuleCall_13() { return cTryCatchStatementParserRuleCall_13; }

		//WithStatement
		public RuleCall getWithStatementParserRuleCall_14() { return cWithStatementParserRuleCall_14; }
	}

	public class BreakStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BreakStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBreakStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBreakKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLabelIDTerminalRuleCall_2_0 = (RuleCall)cLabelAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//BreakStatement:
		//  {BreakStatement} "break" label=ID? ";";
		public ParserRule getRule() { return rule; }

		//{BreakStatement} "break" label=ID? ";"
		public Group getGroup() { return cGroup; }

		//{BreakStatement}
		public Action getBreakStatementAction_0() { return cBreakStatementAction_0; }

		//"break"
		public Keyword getBreakKeyword_1() { return cBreakKeyword_1; }

		//label=ID?
		public Assignment getLabelAssignment_2() { return cLabelAssignment_2; }

		//ID
		public RuleCall getLabelIDTerminalRuleCall_2_0() { return cLabelIDTerminalRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ContinueStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ContinueStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cContinueStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cContinueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLabelIDTerminalRuleCall_2_0 = (RuleCall)cLabelAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ContinueStatement:
		//  {ContinueStatement} "continue" label=ID? ";";
		public ParserRule getRule() { return rule; }

		//{ContinueStatement} "continue" label=ID? ";"
		public Group getGroup() { return cGroup; }

		//{ContinueStatement}
		public Action getContinueStatementAction_0() { return cContinueStatementAction_0; }

		//"continue"
		public Keyword getContinueKeyword_1() { return cContinueKeyword_1; }

		//label=ID?
		public Assignment getLabelAssignment_2() { return cLabelAssignment_2; }

		//ID
		public RuleCall getLabelIDTerminalRuleCall_2_0() { return cLabelIDTerminalRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class CompoundStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsStatementsParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//CompoundStatement:
		//  "{" statements=Statements "}";
		public ParserRule getRule() { return rule; }

		//"{" statements=Statements "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//statements=Statements
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }

		//Statements
		public RuleCall getStatementsStatementsParserRuleCall_1_0() { return cStatementsStatementsParserRuleCall_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class StatementsElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statements");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//Statements:
		//  statements+=Statement+;
		public ParserRule getRule() { return rule; }

		//statements+=Statement+
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}

	public class WhileStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyStatementParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		
		//WhileStatement:
		//  "while" "(" condition=Expression ")" body=Statement;
		public ParserRule getRule() { return rule; }

		//"while" "(" condition=Expression ")" body=Statement
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//body=Statement
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//Statement
		public RuleCall getBodyStatementParserRuleCall_4_0() { return cBodyStatementParserRuleCall_4_0; }
	}

	public class SwitchStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SwitchStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSwitchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSwitchExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSwitchExprVarExpressionParserRuleCall_2_0 = (RuleCall)cSwitchExprAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCaseAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCaseCaseParserRuleCall_5_0 = (RuleCall)cCaseAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cDefaultKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cColonKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cStatementsAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cStatementsStatementsParserRuleCall_6_2_0 = (RuleCall)cStatementsAssignment_6_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//SwitchStatement:
		//  "switch" "(" switchExpr=VarExpression ")" "{" case+=Case* ("default" ":" statements=
		//  Statements?)? "}";
		public ParserRule getRule() { return rule; }

		//"switch" "(" switchExpr=VarExpression ")" "{" case+=Case* ("default" ":" statements=
		//Statements?)? "}"
		public Group getGroup() { return cGroup; }

		//"switch"
		public Keyword getSwitchKeyword_0() { return cSwitchKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//switchExpr=VarExpression
		public Assignment getSwitchExprAssignment_2() { return cSwitchExprAssignment_2; }

		//VarExpression
		public RuleCall getSwitchExprVarExpressionParserRuleCall_2_0() { return cSwitchExprVarExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//case+=Case*
		public Assignment getCaseAssignment_5() { return cCaseAssignment_5; }

		//Case
		public RuleCall getCaseCaseParserRuleCall_5_0() { return cCaseCaseParserRuleCall_5_0; }

		//("default" ":" statements=Statements?)?
		public Group getGroup_6() { return cGroup_6; }

		//"default"
		public Keyword getDefaultKeyword_6_0() { return cDefaultKeyword_6_0; }

		//":"
		public Keyword getColonKeyword_6_1() { return cColonKeyword_6_1; }

		//statements=Statements?
		public Assignment getStatementsAssignment_6_2() { return cStatementsAssignment_6_2; }

		//Statements
		public RuleCall getStatementsStatementsParserRuleCall_6_2_0() { return cStatementsStatementsParserRuleCall_6_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}

	public class CaseElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Case");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionValueLiteralParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStatementsParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		
		//Case:
		//  "case" condition=ValueLiteral ":" statements=Statements?; 
		//		
		//        
		//
		//// TODO: needs validation that expression list only has one entry and is a LHS value
		//// if inLoop == true. Needs validation that RHS is a collection item if inLoop == true.
		////
		public ParserRule getRule() { return rule; }

		//"case" condition=ValueLiteral ":" statements=Statements?
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//condition=ValueLiteral
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//ValueLiteral
		public RuleCall getConditionValueLiteralParserRuleCall_1_0() { return cConditionValueLiteralParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//statements=Statements?
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }

		//Statements
		public RuleCall getStatementsStatementsParserRuleCall_3_0() { return cStatementsStatementsParserRuleCall_3_0; }
	}

	public class ForStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInitAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInitVarExpressionListParserRuleCall_3_0 = (RuleCall)cInitAssignment_3.eContents().get(0);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cAlternatives_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_0_0 = (Keyword)cGroup_4_0.eContents().get(0);
		private final Assignment cCondAssignment_4_0_1 = (Assignment)cGroup_4_0.eContents().get(1);
		private final RuleCall cCondExpressionParserRuleCall_4_0_1_0 = (RuleCall)cCondAssignment_4_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_0_2 = (Keyword)cGroup_4_0.eContents().get(2);
		private final Assignment cIterateAssignment_4_0_3 = (Assignment)cGroup_4_0.eContents().get(3);
		private final RuleCall cIterateExpressionListParserRuleCall_4_0_3_0 = (RuleCall)cIterateAssignment_4_0_3.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cAlternatives_4.eContents().get(1);
		private final Assignment cInLoopAssignment_4_1_0 = (Assignment)cGroup_4_1.eContents().get(0);
		private final Keyword cInLoopInKeyword_4_1_0_0 = (Keyword)cInLoopAssignment_4_1_0.eContents().get(0);
		private final Assignment cIterateAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cIterateExpressionParserRuleCall_4_1_1_0 = (RuleCall)cIterateAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cBodyAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBodyStatementParserRuleCall_6_0 = (RuleCall)cBodyAssignment_6.eContents().get(0);
		
		//ForStatement:
		//  {ForStatement} "for" "(" init=VarExpressionList? (";" cond=Expression? ";" iterate=
		//  ExpressionList?|inLoop?="in" iterate=Expression) ")" body=Statement; 
		//
		//// TODO: needs validation that expression list only has one entry and is a LHS value
		//// if inLoop == true. Needs validation that RHS is a collection item if inLoop == true.
		////
		public ParserRule getRule() { return rule; }

		//{ForStatement} "for" "(" init=VarExpressionList? (";" cond=Expression? ";" iterate=
		//ExpressionList?|inLoop?="in" iterate=Expression) ")" body=Statement
		public Group getGroup() { return cGroup; }

		//{ForStatement}
		public Action getForStatementAction_0() { return cForStatementAction_0; }

		//"for"
		public Keyword getForKeyword_1() { return cForKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//init=VarExpressionList?
		public Assignment getInitAssignment_3() { return cInitAssignment_3; }

		//VarExpressionList
		public RuleCall getInitVarExpressionListParserRuleCall_3_0() { return cInitVarExpressionListParserRuleCall_3_0; }

		//";" cond=Expression? ";" iterate=ExpressionList?|inLoop?="in" iterate=Expression
		public Alternatives getAlternatives_4() { return cAlternatives_4; }

		//";" cond=Expression? ";" iterate=ExpressionList?
		public Group getGroup_4_0() { return cGroup_4_0; }

		//";"
		public Keyword getSemicolonKeyword_4_0_0() { return cSemicolonKeyword_4_0_0; }

		//cond=Expression?
		public Assignment getCondAssignment_4_0_1() { return cCondAssignment_4_0_1; }

		//Expression
		public RuleCall getCondExpressionParserRuleCall_4_0_1_0() { return cCondExpressionParserRuleCall_4_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4_0_2() { return cSemicolonKeyword_4_0_2; }

		//iterate=ExpressionList?
		public Assignment getIterateAssignment_4_0_3() { return cIterateAssignment_4_0_3; }

		//ExpressionList
		public RuleCall getIterateExpressionListParserRuleCall_4_0_3_0() { return cIterateExpressionListParserRuleCall_4_0_3_0; }

		//inLoop?="in" iterate=Expression
		public Group getGroup_4_1() { return cGroup_4_1; }

		//inLoop?="in"
		public Assignment getInLoopAssignment_4_1_0() { return cInLoopAssignment_4_1_0; }

		//"in"
		public Keyword getInLoopInKeyword_4_1_0_0() { return cInLoopInKeyword_4_1_0_0; }

		//iterate=Expression
		public Assignment getIterateAssignment_4_1_1() { return cIterateAssignment_4_1_1; }

		//Expression
		public RuleCall getIterateExpressionParserRuleCall_4_1_1_0() { return cIterateExpressionParserRuleCall_4_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//body=Statement
		public Assignment getBodyAssignment_6() { return cBodyAssignment_6; }

		//Statement
		public RuleCall getBodyStatementParserRuleCall_6_0() { return cBodyStatementParserRuleCall_6_0; }
	}

	public class DoWhileStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoWhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConditionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConditionExpressionParserRuleCall_4_0 = (RuleCall)cConditionAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//DoWhileStatement:
		//  "do" statement=Statement "while" "(" condition=Expression ")" ";";
		public ParserRule getRule() { return rule; }

		//"do" statement=Statement "while" "(" condition=Expression ")" ";"
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//condition=Expression
		public Assignment getConditionAssignment_4() { return cConditionAssignment_4; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_4_0() { return cConditionExpressionParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class ReturnStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReturnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cReturnAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReturnExpressionParserRuleCall_1_0 = (RuleCall)cReturnAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ReturnStatement:
		//  "return" return=Expression ";";
		public ParserRule getRule() { return rule; }

		//"return" return=Expression ";"
		public Group getGroup() { return cGroup; }

		//"return"
		public Keyword getReturnKeyword_0() { return cReturnKeyword_0; }

		//return=Expression
		public Assignment getReturnAssignment_1() { return cReturnAssignment_1; }

		//Expression
		public RuleCall getReturnExpressionParserRuleCall_1_0() { return cReturnExpressionParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class FunctionStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParamsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParamsIDTerminalRuleCall_3_0_0 = (RuleCall)cParamsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParamsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParamsIDTerminalRuleCall_3_1_1_0 = (RuleCall)cParamsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cStatementsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cStatementsStatementsParserRuleCall_6_0 = (RuleCall)cStatementsAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//FunctionStatement:
		//  "function" name=ID "(" (params+=ID ("," params+=ID)*) ")" "{" statements=Statements "}";
		public ParserRule getRule() { return rule; }

		//"function" name=ID "(" (params+=ID ("," params+=ID)*) ")" "{" statements=Statements "}"
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//params+=ID ("," params+=ID)*
		public Group getGroup_3() { return cGroup_3; }

		//params+=ID
		public Assignment getParamsAssignment_3_0() { return cParamsAssignment_3_0; }

		//ID
		public RuleCall getParamsIDTerminalRuleCall_3_0_0() { return cParamsIDTerminalRuleCall_3_0_0; }

		//("," params+=ID)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//params+=ID
		public Assignment getParamsAssignment_3_1_1() { return cParamsAssignment_3_1_1; }

		//ID
		public RuleCall getParamsIDTerminalRuleCall_3_1_1_0() { return cParamsIDTerminalRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }

		//statements=Statements
		public Assignment getStatementsAssignment_6() { return cStatementsAssignment_6; }

		//Statements
		public RuleCall getStatementsStatementsParserRuleCall_6_0() { return cStatementsStatementsParserRuleCall_6_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}

	public class IfStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCondAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCondExpressionParserRuleCall_2_0 = (RuleCall)cCondAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenStatementParserRuleCall_4_0 = (RuleCall)cThenAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cElseAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cElseStatementParserRuleCall_5_1_0 = (RuleCall)cElseAssignment_5_1.eContents().get(0);
		
		//IfStatement:
		//  "if" "(" cond=Expression ")" then=Statement ("else" else=Statement)?;
		public ParserRule getRule() { return rule; }

		//"if" "(" cond=Expression ")" then=Statement ("else" else=Statement)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//cond=Expression
		public Assignment getCondAssignment_2() { return cCondAssignment_2; }

		//Expression
		public RuleCall getCondExpressionParserRuleCall_2_0() { return cCondExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//then=Statement
		public Assignment getThenAssignment_4() { return cThenAssignment_4; }

		//Statement
		public RuleCall getThenStatementParserRuleCall_4_0() { return cThenStatementParserRuleCall_4_0; }

		//("else" else=Statement)?
		public Group getGroup_5() { return cGroup_5; }

		//"else"
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }

		//else=Statement
		public Assignment getElseAssignment_5_1() { return cElseAssignment_5_1; }

		//Statement
		public RuleCall getElseStatementParserRuleCall_5_1_0() { return cElseStatementParserRuleCall_5_1_0; }
	}

	public class LabelStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LabelStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		
		//LabelStatement:
		//  "@" name=ID ":" statement=Statement;
		public ParserRule getRule() { return rule; }

		//"@" name=ID ":" statement=Statement
		public Group getGroup() { return cGroup; }

		//"@"
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }
	}

	public class ThrowStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ThrowStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cThrowKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ThrowStatement:
		//  "throw" expr=Expression ";";
		public ParserRule getRule() { return rule; }

		//"throw" expr=Expression ";"
		public Group getGroup() { return cGroup; }

		//"throw"
		public Keyword getThrowKeyword_0() { return cThrowKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class TryCatchStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TryCatchStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTryKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTryBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTryBlockCompoundStatementParserRuleCall_1_0 = (RuleCall)cTryBlockAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cCatchBlockAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final RuleCall cCatchBlockCatchBlockParserRuleCall_2_0_0_0 = (RuleCall)cCatchBlockAssignment_2_0_0.eContents().get(0);
		private final Assignment cFinallyBlockAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cFinallyBlockFinallyBlockParserRuleCall_2_0_1_0 = (RuleCall)cFinallyBlockAssignment_2_0_1.eContents().get(0);
		private final Assignment cFinallyAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cFinallyFinallyBlockParserRuleCall_2_1_0 = (RuleCall)cFinallyAssignment_2_1.eContents().get(0);
		
		//TryCatchStatement:
		//  "try" tryBlock=CompoundStatement (catchBlock=CatchBlock finallyBlock=FinallyBlock?|
		//  finally=FinallyBlock);
		public ParserRule getRule() { return rule; }

		//"try" tryBlock=CompoundStatement (catchBlock=CatchBlock finallyBlock=FinallyBlock?|
		//finally=FinallyBlock)
		public Group getGroup() { return cGroup; }

		//"try"
		public Keyword getTryKeyword_0() { return cTryKeyword_0; }

		//tryBlock=CompoundStatement
		public Assignment getTryBlockAssignment_1() { return cTryBlockAssignment_1; }

		//CompoundStatement
		public RuleCall getTryBlockCompoundStatementParserRuleCall_1_0() { return cTryBlockCompoundStatementParserRuleCall_1_0; }

		//catchBlock=CatchBlock finallyBlock=FinallyBlock?|finally=FinallyBlock
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//catchBlock=CatchBlock finallyBlock=FinallyBlock?
		public Group getGroup_2_0() { return cGroup_2_0; }

		//catchBlock=CatchBlock
		public Assignment getCatchBlockAssignment_2_0_0() { return cCatchBlockAssignment_2_0_0; }

		//CatchBlock
		public RuleCall getCatchBlockCatchBlockParserRuleCall_2_0_0_0() { return cCatchBlockCatchBlockParserRuleCall_2_0_0_0; }

		//finallyBlock=FinallyBlock?
		public Assignment getFinallyBlockAssignment_2_0_1() { return cFinallyBlockAssignment_2_0_1; }

		//FinallyBlock
		public RuleCall getFinallyBlockFinallyBlockParserRuleCall_2_0_1_0() { return cFinallyBlockFinallyBlockParserRuleCall_2_0_1_0; }

		//finally=FinallyBlock
		public Assignment getFinallyAssignment_2_1() { return cFinallyAssignment_2_1; }

		//FinallyBlock
		public RuleCall getFinallyFinallyBlockParserRuleCall_2_1_0() { return cFinallyFinallyBlockParserRuleCall_2_1_0; }
	}

	public class CatchBlockElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CatchBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCatchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVariableAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariableIDTerminalRuleCall_2_0 = (RuleCall)cVariableAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cCatchBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCatchBlockCompoundStatementParserRuleCall_4_0 = (RuleCall)cCatchBlockAssignment_4.eContents().get(0);
		
		//CatchBlock:
		//  "catch" "(" variable=ID ")" catchBlock=CompoundStatement;
		public ParserRule getRule() { return rule; }

		//"catch" "(" variable=ID ")" catchBlock=CompoundStatement
		public Group getGroup() { return cGroup; }

		//"catch"
		public Keyword getCatchKeyword_0() { return cCatchKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//variable=ID
		public Assignment getVariableAssignment_2() { return cVariableAssignment_2; }

		//ID
		public RuleCall getVariableIDTerminalRuleCall_2_0() { return cVariableIDTerminalRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//catchBlock=CompoundStatement
		public Assignment getCatchBlockAssignment_4() { return cCatchBlockAssignment_4; }

		//CompoundStatement
		public RuleCall getCatchBlockCompoundStatementParserRuleCall_4_0() { return cCatchBlockCompoundStatementParserRuleCall_4_0; }
	}

	public class FinallyBlockElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FinallyBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFinallyKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFinallyBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFinallyBlockCompoundStatementParserRuleCall_1_0 = (RuleCall)cFinallyBlockAssignment_1.eContents().get(0);
		
		//FinallyBlock:
		//  "finally" finallyBlock=CompoundStatement;
		public ParserRule getRule() { return rule; }

		//"finally" finallyBlock=CompoundStatement
		public Group getGroup() { return cGroup; }

		//"finally"
		public Keyword getFinallyKeyword_0() { return cFinallyKeyword_0; }

		//finallyBlock=CompoundStatement
		public Assignment getFinallyBlockAssignment_1() { return cFinallyBlockAssignment_1; }

		//CompoundStatement
		public RuleCall getFinallyBlockCompoundStatementParserRuleCall_1_0() { return cFinallyBlockCompoundStatementParserRuleCall_1_0; }
	}

	public class WithStatementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WithStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWithKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementStatementParserRuleCall_4_0 = (RuleCall)cStatementAssignment_4.eContents().get(0);
		
		//WithStatement:
		//  "with" "(" expr=Expression ")" statement=Statement; 
		//		
		//                
		//		
		/// * EXPRESSIONS * /
		public ParserRule getRule() { return rule; }

		//"with" "(" expr=Expression ")" statement=Statement
		public Group getGroup() { return cGroup; }

		//"with"
		public Keyword getWithKeyword_0() { return cWithKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//expr=Expression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//statement=Statement
		public Assignment getStatementAssignment_4() { return cStatementAssignment_4; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_4_0() { return cStatementStatementParserRuleCall_4_0; }
	}

	public class SyntaxElementElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SyntaxElement");
		private final RuleCall cExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SyntaxElement:
		//  Expression; 
		//		
		/// * EXPRESSIONS * /
		public ParserRule getRule() { return rule; }

		//Expression
		public RuleCall getExpressionParserRuleCall() { return cExpressionParserRuleCall; }
	}

	public class VarExpressionListElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VarExpressionList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExprAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExprVarExpressionParserRuleCall_0_0 = (RuleCall)cExprAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExprAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExprVarExpressionParserRuleCall_1_1_0 = (RuleCall)cExprAssignment_1_1.eContents().get(0);
		
		//VarExpressionList:
		//  expr+=VarExpression ("," expr+=VarExpression)*;
		public ParserRule getRule() { return rule; }

		//expr+=VarExpression ("," expr+=VarExpression)*
		public Group getGroup() { return cGroup; }

		//expr+=VarExpression
		public Assignment getExprAssignment_0() { return cExprAssignment_0; }

		//VarExpression
		public RuleCall getExprVarExpressionParserRuleCall_0_0() { return cExprVarExpressionParserRuleCall_0_0; }

		//("," expr+=VarExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//expr+=VarExpression
		public Assignment getExprAssignment_1_1() { return cExprAssignment_1_1; }

		//VarExpression
		public RuleCall getExprVarExpressionParserRuleCall_1_1_0() { return cExprVarExpressionParserRuleCall_1_1_0; }
	}

	public class ExpressionListElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExprAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExprExpressionParserRuleCall_0_0 = (RuleCall)cExprAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExprAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_1_0 = (RuleCall)cExprAssignment_1_1.eContents().get(0);
		
		//ExpressionList returns Expression:
		//  expr+=Expression ("," expr+=Expression)*; 
		//                    
		//
		//// Assignment is optional i JS
		//// Also makes it possible to use VarExpression in a for(var a in xxx) loop
		////
		public ParserRule getRule() { return rule; }

		//expr+=Expression ("," expr+=Expression)*
		public Group getGroup() { return cGroup; }

		//expr+=Expression
		public Assignment getExprAssignment_0() { return cExprAssignment_0; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_0_0() { return cExprExpressionParserRuleCall_0_0; }

		//("," expr+=Expression)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//expr+=Expression
		public Assignment getExprAssignment_1_1() { return cExprAssignment_1_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_1_0() { return cExprExpressionParserRuleCall_1_1_0; }
	}

	public class VarExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VarExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cVarKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cEqualsSignKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cValueAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_2_1_0 = (RuleCall)cValueAssignment_1_2_1.eContents().get(0);
		
		//VarExpression:
		//  Expression|"var" name=ID ("=" value=Expression)?; 
		//
		//// Assignment is optional i JS
		//// Also makes it possible to use VarExpression in a for(var a in xxx) loop
		////
		public ParserRule getRule() { return rule; }

		//Expression|"var" name=ID ("=" value=Expression)? 
		//
		//// Assignment is optional i JS
		//// Also makes it possible to use VarExpression in a for(var a in xxx) loop
		////
		public Alternatives getAlternatives() { return cAlternatives; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//"var" name=ID ("=" value=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//"var"
		public Keyword getVarKeyword_1_0() { return cVarKeyword_1_0; }

		//name=ID
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_1_0() { return cNameIDTerminalRuleCall_1_1_0; }

		//("=" value=Expression)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"="
		public Keyword getEqualsSignKeyword_1_2_0() { return cEqualsSignKeyword_1_2_0; }

		//value=Expression
		public Assignment getValueAssignment_1_2_1() { return cValueAssignment_1_2_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_2_1_0() { return cValueExpressionParserRuleCall_1_2_1_0; }
	}

	public class ExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cValueExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//  ValueExpression;
		public ParserRule getRule() { return rule; }

		//ValueExpression
		public RuleCall getValueExpressionParserRuleCall() { return cValueExpressionParserRuleCall; }
	}

	public class ValueExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueAssignmentExpressionParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//ValueExpression:
		//  value=AssignmentExpression; 
		//
		// 
		//	  
		//	
		//
		////TODO: This is left associative, should be right...
		////AssignmentExpression returns Expression:
		////	 ChainExpression ({AssignmentOperation.left+=current} op=("=" | "+=" | "-=" | "*=" | "/=" | "%=" )
		////		right+=ChainExpression)*
		////	;
		public ParserRule getRule() { return rule; }

		//value=AssignmentExpression
		public Assignment getValueAssignment() { return cValueAssignment; }

		//AssignmentExpression
		public RuleCall getValueAssignmentExpressionParserRuleCall_0() { return cValueAssignmentExpressionParserRuleCall_0; }
	}

	public class AssignmentExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cChainExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAssignmentOperationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpPlusSignEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpHyphenMinusEqualsSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpAsteriskEqualsSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Keyword cOpSolidusEqualsSignKeyword_1_1_0_4 = (Keyword)cOpAlternatives_1_1_0.eContents().get(4);
		private final Keyword cOpPercentSignEqualsSignKeyword_1_1_0_5 = (Keyword)cOpAlternatives_1_1_0.eContents().get(5);
		private final Keyword cOpLessThanSignLessThanSignEqualsSignKeyword_1_1_0_6 = (Keyword)cOpAlternatives_1_1_0.eContents().get(6);
		private final Keyword cOpGreaterThanSignGreaterThanSignEqualsSignKeyword_1_1_0_7 = (Keyword)cOpAlternatives_1_1_0.eContents().get(7);
		private final Keyword cOpGreaterThanSignGreaterThanSignGreaterThanSignEqualsSignKeyword_1_1_0_8 = (Keyword)cOpAlternatives_1_1_0.eContents().get(8);
		private final Keyword cOpAmpersandEqualsSignKeyword_1_1_0_9 = (Keyword)cOpAlternatives_1_1_0.eContents().get(9);
		private final Keyword cOpCircumflexAccentEqualsSignKeyword_1_1_0_10 = (Keyword)cOpAlternatives_1_1_0.eContents().get(10);
		private final Keyword cOpVerticalLineEqualsSignKeyword_1_1_0_11 = (Keyword)cOpAlternatives_1_1_0.eContents().get(11);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAssignmentExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AssignmentExpression returns Expression:
		//  ChainExpression ({AssignmentOperation.left=current} op=( "=" | "+=" | "-=" | "*=" | "/=" |
		//  "%=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" ) right=AssignmentExpression)?; 
		//
		////TODO: This is left associative, should be right...
		////AssignmentExpression returns Expression:
		////	 ChainExpression ({AssignmentOperation.left+=current} op=("=" | "+=" | "-=" | "*=" | "/=" | "%=" )
		////		right+=ChainExpression)*
		////	;
		public ParserRule getRule() { return rule; }

		//ChainExpression ({AssignmentOperation.left=current} op=( "=" | "+=" | "-=" | "*=" | "/=" |
		//"%=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" ) right=AssignmentExpression)?
		public Group getGroup() { return cGroup; }

		//ChainExpression
		public RuleCall getChainExpressionParserRuleCall_0() { return cChainExpressionParserRuleCall_0; }

		//({AssignmentOperation.left=current} op=( "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" |
		//">>>=" | "&=" | "^=" | "|=" ) right=AssignmentExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{AssignmentOperation.left=current}
		public Action getAssignmentOperationLeftAction_1_0() { return cAssignmentOperationLeftAction_1_0; }

		//op=( "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" )
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"="|"+="|"-="|"*="|"/="|"%="|"<<="|">>="|">>>="|"&="|"^="|"|="
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"="
		public Keyword getOpEqualsSignKeyword_1_1_0_0() { return cOpEqualsSignKeyword_1_1_0_0; }

		//"+="
		public Keyword getOpPlusSignEqualsSignKeyword_1_1_0_1() { return cOpPlusSignEqualsSignKeyword_1_1_0_1; }

		//"-="
		public Keyword getOpHyphenMinusEqualsSignKeyword_1_1_0_2() { return cOpHyphenMinusEqualsSignKeyword_1_1_0_2; }

		//"*="
		public Keyword getOpAsteriskEqualsSignKeyword_1_1_0_3() { return cOpAsteriskEqualsSignKeyword_1_1_0_3; }

		//"/="
		public Keyword getOpSolidusEqualsSignKeyword_1_1_0_4() { return cOpSolidusEqualsSignKeyword_1_1_0_4; }

		//"%="
		public Keyword getOpPercentSignEqualsSignKeyword_1_1_0_5() { return cOpPercentSignEqualsSignKeyword_1_1_0_5; }

		//"<<="
		public Keyword getOpLessThanSignLessThanSignEqualsSignKeyword_1_1_0_6() { return cOpLessThanSignLessThanSignEqualsSignKeyword_1_1_0_6; }

		//">>="
		public Keyword getOpGreaterThanSignGreaterThanSignEqualsSignKeyword_1_1_0_7() { return cOpGreaterThanSignGreaterThanSignEqualsSignKeyword_1_1_0_7; }

		//">>>="
		public Keyword getOpGreaterThanSignGreaterThanSignGreaterThanSignEqualsSignKeyword_1_1_0_8() { return cOpGreaterThanSignGreaterThanSignGreaterThanSignEqualsSignKeyword_1_1_0_8; }

		//"&="
		public Keyword getOpAmpersandEqualsSignKeyword_1_1_0_9() { return cOpAmpersandEqualsSignKeyword_1_1_0_9; }

		//"^="
		public Keyword getOpCircumflexAccentEqualsSignKeyword_1_1_0_10() { return cOpCircumflexAccentEqualsSignKeyword_1_1_0_10; }

		//"|="
		public Keyword getOpVerticalLineEqualsSignKeyword_1_1_0_11() { return cOpVerticalLineEqualsSignKeyword_1_1_0_11; }

		//right=AssignmentExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AssignmentExpression
		public RuleCall getRightAssignmentExpressionParserRuleCall_1_2_0() { return cRightAssignmentExpressionParserRuleCall_1_2_0; }
	}

	public class ChainExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChainExpression");
		private final RuleCall cChainedExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ChainExpression returns Expression:
		//  ChainedExpression; 
		//
		//
		//    
		//	  //({ChainExpression.first=current} ',' next=ChainedExpression)*
		public ParserRule getRule() { return rule; }

		//ChainedExpression 
		//	  //({ChainExpression.first=current} ',' next=ChainedExpression)*
		public RuleCall getChainedExpressionParserRuleCall() { return cChainedExpressionParserRuleCall; }
	}

	public class ChainedExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChainedExpression");
		private final RuleCall cIfExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ChainedExpression returns Expression:
		//  IfExpression;
		public ParserRule getRule() { return rule; }

		//IfExpression
		public RuleCall getIfExpressionParserRuleCall() { return cIfExpressionParserRuleCall; }
	}

	public class IfExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIfExpressionConditionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cThenPartAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cThenPartChainedExpressionParserRuleCall_1_2_0 = (RuleCall)cThenPartAssignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cElsePartAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cElsePartChainedExpressionParserRuleCall_1_4_0 = (RuleCall)cElsePartAssignment_1_4.eContents().get(0);
		
		//IfExpression returns Expression:
		//  OrExpression ({IfExpression.condition=current} "?" thenPart=ChainedExpression ":"
		//  elsePart=ChainedExpression)?;
		public ParserRule getRule() { return rule; }

		//OrExpression ({IfExpression.condition=current} "?" thenPart=ChainedExpression ":"
		//elsePart=ChainedExpression)?
		public Group getGroup() { return cGroup; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }

		//({IfExpression.condition=current} "?" thenPart=ChainedExpression ":" elsePart=
		//ChainedExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{IfExpression.condition=current}
		public Action getIfExpressionConditionAction_1_0() { return cIfExpressionConditionAction_1_0; }

		//"?"
		public Keyword getQuestionMarkKeyword_1_1() { return cQuestionMarkKeyword_1_1; }

		//thenPart=ChainedExpression
		public Assignment getThenPartAssignment_1_2() { return cThenPartAssignment_1_2; }

		//ChainedExpression
		public RuleCall getThenPartChainedExpressionParserRuleCall_1_2_0() { return cThenPartChainedExpressionParserRuleCall_1_2_0; }

		//":"
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }

		//elsePart=ChainedExpression
		public Assignment getElsePartAssignment_1_4() { return cElsePartAssignment_1_4; }

		//ChainedExpression
		public RuleCall getElsePartChainedExpressionParserRuleCall_1_4_0() { return cElsePartChainedExpressionParserRuleCall_1_4_0; }
	}

	public class OrExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBooleanOperationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorVerticalLineVerticalLineKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//OrExpression returns Expression:
		//  AndExpression ({BooleanOperation.left=current} operator="||" right=AndExpression)*;
		public ParserRule getRule() { return rule; }

		//AndExpression ({BooleanOperation.left=current} operator="||" right=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({BooleanOperation.left=current} operator="||" right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{BooleanOperation.left=current}
		public Action getBooleanOperationLeftAction_1_0() { return cBooleanOperationLeftAction_1_0; }

		//operator="||"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"||"
		public Keyword getOperatorVerticalLineVerticalLineKeyword_1_1_0() { return cOperatorVerticalLineVerticalLineKeyword_1_1_0; }

		//right=AndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBitwiseExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBooleanOperationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorAmpersandAmpersandKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBitwiseExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndExpression returns Expression:
		//  BitwiseExpression ({BooleanOperation.left=current} operator="&&" right=
		//  BitwiseExpression)*;
		public ParserRule getRule() { return rule; }

		//BitwiseExpression ({BooleanOperation.left=current} operator="&&" right=
		//BitwiseExpression)*
		public Group getGroup() { return cGroup; }

		//BitwiseExpression
		public RuleCall getBitwiseExpressionParserRuleCall_0() { return cBitwiseExpressionParserRuleCall_0; }

		//({BooleanOperation.left=current} operator="&&" right=BitwiseExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{BooleanOperation.left=current}
		public Action getBooleanOperationLeftAction_1_0() { return cBooleanOperationLeftAction_1_0; }

		//operator="&&"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"&&"
		public Keyword getOperatorAmpersandAmpersandKeyword_1_1_0() { return cOperatorAmpersandAmpersandKeyword_1_1_0; }

		//right=BitwiseExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BitwiseExpression
		public RuleCall getRightBitwiseExpressionParserRuleCall_1_2_0() { return cRightBitwiseExpressionParserRuleCall_1_2_0; }
	}

	public class BitwiseExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitwiseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperationCallLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperatorAlternatives_1_1_0 = (Alternatives)cOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cOperatorAmpersandKeyword_1_1_0_0 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOperatorCircumflexAccentKeyword_1_1_0_1 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOperatorVerticalLineKeyword_1_1_0_2 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(2);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRelationalExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BitwiseExpression returns Expression:
		//  RelationalExpression ({OperationCall.left=current} operator=( "&" | "^" | "|" ) right=
		//  RelationalExpression)*;
		public ParserRule getRule() { return rule; }

		//RelationalExpression ({OperationCall.left=current} operator=( "&" | "^" | "|" ) right=
		//RelationalExpression)*
		public Group getGroup() { return cGroup; }

		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }

		//({OperationCall.left=current} operator=( "&" | "^" | "|" ) right=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OperationCall.left=current}
		public Action getOperationCallLeftAction_1_0() { return cOperationCallLeftAction_1_0; }

		//operator=( "&" | "^" | "|" )
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"&"|"^"|"|"
		public Alternatives getOperatorAlternatives_1_1_0() { return cOperatorAlternatives_1_1_0; }

		//"&"
		public Keyword getOperatorAmpersandKeyword_1_1_0_0() { return cOperatorAmpersandKeyword_1_1_0_0; }

		//"^"
		public Keyword getOperatorCircumflexAccentKeyword_1_1_0_1() { return cOperatorCircumflexAccentKeyword_1_1_0_1; }

		//"|"
		public Keyword getOperatorVerticalLineKeyword_1_1_0_2() { return cOperatorVerticalLineKeyword_1_1_0_2; }

		//right=RelationalExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//RelationalExpression
		public RuleCall getRightRelationalExpressionParserRuleCall_1_2_0() { return cRightRelationalExpressionParserRuleCall_1_2_0; }
	}

	public class RelationalExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBooleanOperationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperatorAlternatives_1_1_0 = (Alternatives)cOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cOperatorTildeEqualsSignKeyword_1_1_0_0 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOperatorEqualsSignEqualsSignKeyword_1_1_0_1 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOperatorEqualsSignEqualsSignEqualsSignKeyword_1_1_0_2 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOperatorExclamationMarkEqualsSignKeyword_1_1_0_3 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(3);
		private final Keyword cOperatorExclamationMarkEqualsSignEqualsSignKeyword_1_1_0_4 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(4);
		private final Keyword cOperatorGreaterThanSignEqualsSignKeyword_1_1_0_5 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(5);
		private final Keyword cOperatorLessThanSignEqualsSignKeyword_1_1_0_6 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(6);
		private final Keyword cOperatorGreaterThanSignKeyword_1_1_0_7 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(7);
		private final Keyword cOperatorLessThanSignKeyword_1_1_0_8 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(8);
		private final Keyword cOperatorEqualsSignEqualsSignFullStopKeyword_1_1_0_9 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(9);
		private final Keyword cOperatorInstanceofKeyword_1_1_0_10 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(10);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//RelationalExpression returns Expression:
		//  AdditiveExpression ({BooleanOperation.left=current} operator=( "~=" | "==" | "===" | "!="
		//  | "!==" | ">=" | "<=" | ">" | "<" | "==." | "instanceof" ) right=AdditiveExpression)*;
		public ParserRule getRule() { return rule; }

		//AdditiveExpression ({BooleanOperation.left=current} operator=( "~=" | "==" | "===" | "!="
		//| "!==" | ">=" | "<=" | ">" | "<" | "==." | "instanceof" ) right=AdditiveExpression)*
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//({BooleanOperation.left=current} operator=( "~=" | "==" | "===" | "!=" | "!==" | ">=" | "<=" |
		//">" | "<" | "==." | "instanceof" ) right=AdditiveExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{BooleanOperation.left=current}
		public Action getBooleanOperationLeftAction_1_0() { return cBooleanOperationLeftAction_1_0; }

		//operator=( "~=" | "==" | "===" | "!=" | "!==" | ">=" | "<=" | ">" | "<" | "==." | "instanceof" )
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"~="|"=="|"==="|"!="|"!=="|">="|"<="|">"|"<"|"==."|"instanceof"
		public Alternatives getOperatorAlternatives_1_1_0() { return cOperatorAlternatives_1_1_0; }

		//"~="
		public Keyword getOperatorTildeEqualsSignKeyword_1_1_0_0() { return cOperatorTildeEqualsSignKeyword_1_1_0_0; }

		//"=="
		public Keyword getOperatorEqualsSignEqualsSignKeyword_1_1_0_1() { return cOperatorEqualsSignEqualsSignKeyword_1_1_0_1; }

		//"==="
		public Keyword getOperatorEqualsSignEqualsSignEqualsSignKeyword_1_1_0_2() { return cOperatorEqualsSignEqualsSignEqualsSignKeyword_1_1_0_2; }

		//"!="
		public Keyword getOperatorExclamationMarkEqualsSignKeyword_1_1_0_3() { return cOperatorExclamationMarkEqualsSignKeyword_1_1_0_3; }

		//"!=="
		public Keyword getOperatorExclamationMarkEqualsSignEqualsSignKeyword_1_1_0_4() { return cOperatorExclamationMarkEqualsSignEqualsSignKeyword_1_1_0_4; }

		//">="
		public Keyword getOperatorGreaterThanSignEqualsSignKeyword_1_1_0_5() { return cOperatorGreaterThanSignEqualsSignKeyword_1_1_0_5; }

		//"<="
		public Keyword getOperatorLessThanSignEqualsSignKeyword_1_1_0_6() { return cOperatorLessThanSignEqualsSignKeyword_1_1_0_6; }

		//">"
		public Keyword getOperatorGreaterThanSignKeyword_1_1_0_7() { return cOperatorGreaterThanSignKeyword_1_1_0_7; }

		//"<"
		public Keyword getOperatorLessThanSignKeyword_1_1_0_8() { return cOperatorLessThanSignKeyword_1_1_0_8; }

		//"==."
		public Keyword getOperatorEqualsSignEqualsSignFullStopKeyword_1_1_0_9() { return cOperatorEqualsSignEqualsSignFullStopKeyword_1_1_0_9; }

		//"instanceof"
		public Keyword getOperatorInstanceofKeyword_1_1_0_10() { return cOperatorInstanceofKeyword_1_1_0_10; }

		//right=AdditiveExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AdditiveExpression
		public RuleCall getRightAdditiveExpressionParserRuleCall_1_2_0() { return cRightAdditiveExpressionParserRuleCall_1_2_0; }
	}

	public class AdditiveExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperationCallParamsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cNameAlternatives_1_1_0 = (Alternatives)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cNamePlusSignKeyword_1_1_0_0 = (Keyword)cNameAlternatives_1_1_0.eContents().get(0);
		private final Keyword cNameHyphenMinusKeyword_1_1_0_1 = (Keyword)cNameAlternatives_1_1_0.eContents().get(1);
		private final Assignment cParamsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cParamsMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cParamsAssignment_1_2.eContents().get(0);
		
		//AdditiveExpression returns Expression:
		//  MultiplicativeExpression ({OperationCall.params+=current} name=( "+" | "-" ) params+=
		//  MultiplicativeExpression)*;
		public ParserRule getRule() { return rule; }

		//MultiplicativeExpression ({OperationCall.params+=current} name=( "+" | "-" ) params+=
		//MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({OperationCall.params+=current} name=( "+" | "-" ) params+=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OperationCall.params+=current}
		public Action getOperationCallParamsAction_1_0() { return cOperationCallParamsAction_1_0; }

		//name=( "+" | "-" )
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }

		//"+"|"-"
		public Alternatives getNameAlternatives_1_1_0() { return cNameAlternatives_1_1_0; }

		//"+"
		public Keyword getNamePlusSignKeyword_1_1_0_0() { return cNamePlusSignKeyword_1_1_0_0; }

		//"-"
		public Keyword getNameHyphenMinusKeyword_1_1_0_1() { return cNameHyphenMinusKeyword_1_1_0_1; }

		//params+=MultiplicativeExpression
		public Assignment getParamsAssignment_1_2() { return cParamsAssignment_1_2; }

		//MultiplicativeExpression
		public RuleCall getParamsMultiplicativeExpressionParserRuleCall_1_2_0() { return cParamsMultiplicativeExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicativeExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryOrInfixExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperationCallParamsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cNameAlternatives_1_1_0 = (Alternatives)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cNameAsteriskKeyword_1_1_0_0 = (Keyword)cNameAlternatives_1_1_0.eContents().get(0);
		private final Keyword cNameSolidusKeyword_1_1_0_1 = (Keyword)cNameAlternatives_1_1_0.eContents().get(1);
		private final Keyword cNamePercentSignKeyword_1_1_0_2 = (Keyword)cNameAlternatives_1_1_0.eContents().get(2);
		private final Assignment cParamsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cParamsUnaryOrInfixExpressionParserRuleCall_1_2_0 = (RuleCall)cParamsAssignment_1_2.eContents().get(0);
		
		//MultiplicativeExpression returns Expression:
		//  UnaryOrInfixExpression ({OperationCall.params+=current} name=( "*" | "/" | "%" ) params+=
		//  UnaryOrInfixExpression)*;
		public ParserRule getRule() { return rule; }

		//UnaryOrInfixExpression ({OperationCall.params+=current} name=( "*" | "/" | "%" ) params+=
		//UnaryOrInfixExpression)*
		public Group getGroup() { return cGroup; }

		//UnaryOrInfixExpression
		public RuleCall getUnaryOrInfixExpressionParserRuleCall_0() { return cUnaryOrInfixExpressionParserRuleCall_0; }

		//({OperationCall.params+=current} name=( "*" | "/" | "%" ) params+=UnaryOrInfixExpression
		//)*
		public Group getGroup_1() { return cGroup_1; }

		//{OperationCall.params+=current}
		public Action getOperationCallParamsAction_1_0() { return cOperationCallParamsAction_1_0; }

		//name=( "*" | "/" | "%" )
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }

		//"*"|"/"|"%"
		public Alternatives getNameAlternatives_1_1_0() { return cNameAlternatives_1_1_0; }

		//"*"
		public Keyword getNameAsteriskKeyword_1_1_0_0() { return cNameAsteriskKeyword_1_1_0_0; }

		//"/"
		public Keyword getNameSolidusKeyword_1_1_0_1() { return cNameSolidusKeyword_1_1_0_1; }

		//"%"
		public Keyword getNamePercentSignKeyword_1_1_0_2() { return cNamePercentSignKeyword_1_1_0_2; }

		//params+=UnaryOrInfixExpression
		public Assignment getParamsAssignment_1_2() { return cParamsAssignment_1_2; }

		//UnaryOrInfixExpression
		public RuleCall getParamsUnaryOrInfixExpressionParserRuleCall_1_2_0() { return cParamsUnaryOrInfixExpressionParserRuleCall_1_2_0; }
	}

	public class UnaryOrInfixExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOrInfixExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPostopExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//UnaryOrInfixExpression returns Expression:
		//  UnaryExpression|PostopExpression;
		public ParserRule getRule() { return rule; }

		//UnaryExpression|PostopExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }

		//PostopExpression
		public RuleCall getPostopExpressionParserRuleCall_1() { return cPostopExpressionParserRuleCall_1; }
	}

	public class UnaryExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final Keyword cNameExclamationMarkKeyword_0_0_0 = (Keyword)cNameAlternatives_0_0.eContents().get(0);
		private final Keyword cNameHyphenMinusKeyword_0_0_1 = (Keyword)cNameAlternatives_0_0.eContents().get(1);
		private final Keyword cNamePlusSignPlusSignKeyword_0_0_2 = (Keyword)cNameAlternatives_0_0.eContents().get(2);
		private final Keyword cNameHyphenMinusHyphenMinusKeyword_0_0_3 = (Keyword)cNameAlternatives_0_0.eContents().get(3);
		private final Keyword cNameTypeofKeyword_0_0_4 = (Keyword)cNameAlternatives_0_0.eContents().get(4);
		private final Keyword cNameDeleteKeyword_0_0_5 = (Keyword)cNameAlternatives_0_0.eContents().get(5);
		private final Keyword cNameTildeKeyword_0_0_6 = (Keyword)cNameAlternatives_0_0.eContents().get(6);
		private final Assignment cParamsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParamsPostopExpressionParserRuleCall_1_0 = (RuleCall)cParamsAssignment_1.eContents().get(0);
		
		//UnaryExpression returns OperationCall:
		//  name=( "!" | "-" | "++" | "--" | "typeof" | "delete" | "~" ) params+=PostopExpression;
		public ParserRule getRule() { return rule; }

		//name=( "!" | "-" | "++" | "--" | "typeof" | "delete" | "~" ) params+=PostopExpression
		public Group getGroup() { return cGroup; }

		//name=( "!" | "-" | "++" | "--" | "typeof" | "delete" | "~" )
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"!"|"-"|"++"|"--"|"typeof"|"delete"|"~"
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }

		//"!"
		public Keyword getNameExclamationMarkKeyword_0_0_0() { return cNameExclamationMarkKeyword_0_0_0; }

		//"-"
		public Keyword getNameHyphenMinusKeyword_0_0_1() { return cNameHyphenMinusKeyword_0_0_1; }

		//"++"
		public Keyword getNamePlusSignPlusSignKeyword_0_0_2() { return cNamePlusSignPlusSignKeyword_0_0_2; }

		//"--"
		public Keyword getNameHyphenMinusHyphenMinusKeyword_0_0_3() { return cNameHyphenMinusHyphenMinusKeyword_0_0_3; }

		//"typeof"
		public Keyword getNameTypeofKeyword_0_0_4() { return cNameTypeofKeyword_0_0_4; }

		//"delete"
		public Keyword getNameDeleteKeyword_0_0_5() { return cNameDeleteKeyword_0_0_5; }

		//"~"
		public Keyword getNameTildeKeyword_0_0_6() { return cNameTildeKeyword_0_0_6; }

		//params+=PostopExpression
		public Assignment getParamsAssignment_1() { return cParamsAssignment_1; }

		//PostopExpression
		public RuleCall getParamsPostopExpressionParserRuleCall_1_0() { return cParamsPostopExpressionParserRuleCall_1_0; }
	}

	public class PostopExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostopExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPostOpCallTargetAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cNameAlternatives_1_1_0 = (Alternatives)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cNameHyphenMinusHyphenMinusKeyword_1_1_0_0 = (Keyword)cNameAlternatives_1_1_0.eContents().get(0);
		private final Keyword cNamePlusSignPlusSignKeyword_1_1_0_1 = (Keyword)cNameAlternatives_1_1_0.eContents().get(1);
		
		//PostopExpression returns Expression:
		//  InfixExpression ({PostOpCall.target=current} name=( "--" | "++" ))?;
		public ParserRule getRule() { return rule; }

		//InfixExpression ({PostOpCall.target=current} name=( "--" | "++" ))?
		public Group getGroup() { return cGroup; }

		//InfixExpression
		public RuleCall getInfixExpressionParserRuleCall_0() { return cInfixExpressionParserRuleCall_0; }

		//({PostOpCall.target=current} name=( "--" | "++" ))?
		public Group getGroup_1() { return cGroup_1; }

		//{PostOpCall.target=current}
		public Action getPostOpCallTargetAction_1_0() { return cPostOpCallTargetAction_1_0; }

		//name=( "--" | "++" )
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }

		//"--"|"++"
		public Alternatives getNameAlternatives_1_1_0() { return cNameAlternatives_1_1_0; }

		//"--"
		public Keyword getNameHyphenMinusHyphenMinusKeyword_1_1_0_0() { return cNameHyphenMinusHyphenMinusKeyword_1_1_0_0; }

		//"++"
		public Keyword getNamePlusSignPlusSignKeyword_1_1_0_1() { return cNamePlusSignPlusSignKeyword_1_1_0_1; }
	}

	public class InfixExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCallExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cOperationCallTargetAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cNameAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_1_0_2_0 = (RuleCall)cNameAssignment_1_0_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_0_3 = (Keyword)cGroup_1_0.eContents().get(3);
		private final Group cGroup_1_0_4 = (Group)cGroup_1_0.eContents().get(4);
		private final Assignment cParamsAssignment_1_0_4_0 = (Assignment)cGroup_1_0_4.eContents().get(0);
		private final RuleCall cParamsParameterParserRuleCall_1_0_4_0_0 = (RuleCall)cParamsAssignment_1_0_4_0.eContents().get(0);
		private final Group cGroup_1_0_4_1 = (Group)cGroup_1_0_4.eContents().get(1);
		private final Keyword cCommaKeyword_1_0_4_1_0 = (Keyword)cGroup_1_0_4_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_0_4_1_1 = (Assignment)cGroup_1_0_4_1.eContents().get(1);
		private final RuleCall cParamsParameterParserRuleCall_1_0_4_1_1_0 = (RuleCall)cParamsAssignment_1_0_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_0_5 = (Keyword)cGroup_1_0.eContents().get(5);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cAtCallTargetAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cIndexAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cIndexExpressionParserRuleCall_1_1_2_0 = (RuleCall)cIndexAssignment_1_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_3 = (Keyword)cGroup_1_1.eContents().get(3);
		private final Group cGroup_1_1_4 = (Group)cGroup_1_1.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_1_1_4_0 = (Keyword)cGroup_1_1_4.eContents().get(0);
		private final Group cGroup_1_1_4_1 = (Group)cGroup_1_1_4.eContents().get(1);
		private final Assignment cParamsAssignment_1_1_4_1_0 = (Assignment)cGroup_1_1_4_1.eContents().get(0);
		private final RuleCall cParamsParameterParserRuleCall_1_1_4_1_0_0 = (RuleCall)cParamsAssignment_1_1_4_1_0.eContents().get(0);
		private final Group cGroup_1_1_4_1_1 = (Group)cGroup_1_1_4_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_4_1_1_0 = (Keyword)cGroup_1_1_4_1_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_1_4_1_1_1 = (Assignment)cGroup_1_1_4_1_1.eContents().get(1);
		private final RuleCall cParamsParameterParserRuleCall_1_1_4_1_1_1_0 = (RuleCall)cParamsAssignment_1_1_4_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_1_4_2 = (Keyword)cGroup_1_1_4.eContents().get(2);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cFeatureCallTargetAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cFullStopKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cTypeAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cTypeIDTerminalRuleCall_1_2_2_0 = (RuleCall)cTypeAssignment_1_2_2.eContents().get(0);
		
		//InfixExpression returns Expression:
		//  CallExpression ({OperationCall.target=current} "." name=ID "(" (params+=Parameter (","
		//  params+=Parameter)*)? ")"|{AtCall.target=current} "[" index=Expression "]" ("(" (
		//  params+=Parameter ("," params+=Parameter)*)? ")")?|{FeatureCall.target=current} "."
		//  type=ID)*;
		public ParserRule getRule() { return rule; }

		//CallExpression ({OperationCall.target=current} "." name=ID "(" (params+=Parameter (","
		//params+=Parameter)*)? ")"|{AtCall.target=current} "[" index=Expression "]" ("(" (
		//params+=Parameter ("," params+=Parameter)*)? ")")?|{FeatureCall.target=current} "."
		//type=ID)*
		public Group getGroup() { return cGroup; }

		//CallExpression
		public RuleCall getCallExpressionParserRuleCall_0() { return cCallExpressionParserRuleCall_0; }

		//({OperationCall.target=current} "." name=ID "(" (params+=Parameter ("," params+=
		//Parameter)*)? ")"|{AtCall.target=current} "[" index=Expression "]" ("(" (params+=
		//Parameter ("," params+=Parameter)*)? ")")?|{FeatureCall.target=current} "." type=ID)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{OperationCall.target=current} "." name=ID "(" (params+=Parameter ("," params+=
		//Parameter)*)? ")"
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{OperationCall.target=current}
		public Action getOperationCallTargetAction_1_0_0() { return cOperationCallTargetAction_1_0_0; }

		//"."
		public Keyword getFullStopKeyword_1_0_1() { return cFullStopKeyword_1_0_1; }

		//name=ID
		public Assignment getNameAssignment_1_0_2() { return cNameAssignment_1_0_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_2_0() { return cNameIDTerminalRuleCall_1_0_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0_3() { return cLeftParenthesisKeyword_1_0_3; }

		//(params+=Parameter ("," params+=Parameter)*)?
		public Group getGroup_1_0_4() { return cGroup_1_0_4; }

		//params+=Parameter
		public Assignment getParamsAssignment_1_0_4_0() { return cParamsAssignment_1_0_4_0; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_1_0_4_0_0() { return cParamsParameterParserRuleCall_1_0_4_0_0; }

		//("," params+=Parameter)*
		public Group getGroup_1_0_4_1() { return cGroup_1_0_4_1; }

		//","
		public Keyword getCommaKeyword_1_0_4_1_0() { return cCommaKeyword_1_0_4_1_0; }

		//params+=Parameter
		public Assignment getParamsAssignment_1_0_4_1_1() { return cParamsAssignment_1_0_4_1_1; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_1_0_4_1_1_0() { return cParamsParameterParserRuleCall_1_0_4_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_0_5() { return cRightParenthesisKeyword_1_0_5; }

		//{AtCall.target=current} "[" index=Expression "]" ("(" (params+=Parameter ("," params+=
		//Parameter)*)? ")")?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{AtCall.target=current}
		public Action getAtCallTargetAction_1_1_0() { return cAtCallTargetAction_1_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1_1() { return cLeftSquareBracketKeyword_1_1_1; }

		//index=Expression
		public Assignment getIndexAssignment_1_1_2() { return cIndexAssignment_1_1_2; }

		//Expression
		public RuleCall getIndexExpressionParserRuleCall_1_1_2_0() { return cIndexExpressionParserRuleCall_1_1_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_1_3() { return cRightSquareBracketKeyword_1_1_3; }

		//("(" (params+=Parameter ("," params+=Parameter)*)? ")")?
		public Group getGroup_1_1_4() { return cGroup_1_1_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1_4_0() { return cLeftParenthesisKeyword_1_1_4_0; }

		//(params+=Parameter ("," params+=Parameter)*)?
		public Group getGroup_1_1_4_1() { return cGroup_1_1_4_1; }

		//params+=Parameter
		public Assignment getParamsAssignment_1_1_4_1_0() { return cParamsAssignment_1_1_4_1_0; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_1_1_4_1_0_0() { return cParamsParameterParserRuleCall_1_1_4_1_0_0; }

		//("," params+=Parameter)*
		public Group getGroup_1_1_4_1_1() { return cGroup_1_1_4_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_4_1_1_0() { return cCommaKeyword_1_1_4_1_1_0; }

		//params+=Parameter
		public Assignment getParamsAssignment_1_1_4_1_1_1() { return cParamsAssignment_1_1_4_1_1_1; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_1_1_4_1_1_1_0() { return cParamsParameterParserRuleCall_1_1_4_1_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_1_4_2() { return cRightParenthesisKeyword_1_1_4_2; }

		//{FeatureCall.target=current} "." type=ID
		public Group getGroup_1_2() { return cGroup_1_2; }

		//{FeatureCall.target=current}
		public Action getFeatureCallTargetAction_1_2_0() { return cFeatureCallTargetAction_1_2_0; }

		//"."
		public Keyword getFullStopKeyword_1_2_1() { return cFullStopKeyword_1_2_1; }

		//type=ID
		public Assignment getTypeAssignment_1_2_2() { return cTypeAssignment_1_2_2; }

		//ID
		public RuleCall getTypeIDTerminalRuleCall_1_2_2_0() { return cTypeIDTerminalRuleCall_1_2_2_0; }
	}

	public class CallExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperationCallTargetAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cParamsAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cParamsParameterParserRuleCall_1_2_0_0 = (RuleCall)cParamsAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cParamsParameterParserRuleCall_1_2_1_1_0 = (RuleCall)cParamsAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//CallExpression returns Expression:
		//  PrimaryExpression ({OperationCall.target=current} "(" (params+=Parameter ("," params
		//  +=Parameter)*)? ")")*;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression ({OperationCall.target=current} "(" (params+=Parameter ("," params
		//+=Parameter)*)? ")")*
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//({OperationCall.target=current} "(" (params+=Parameter ("," params+=Parameter)*)? ")"
		//)*
		public Group getGroup_1() { return cGroup_1; }

		//{OperationCall.target=current}
		public Action getOperationCallTargetAction_1_0() { return cOperationCallTargetAction_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//(params+=Parameter ("," params+=Parameter)*)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//params+=Parameter
		public Assignment getParamsAssignment_1_2_0() { return cParamsAssignment_1_2_0; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_1_2_0_0() { return cParamsParameterParserRuleCall_1_2_0_0; }

		//("," params+=Parameter)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//","
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }

		//params+=Parameter
		public Assignment getParamsAssignment_1_2_1_1() { return cParamsAssignment_1_2_1_1; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_1_2_1_1_0() { return cParamsParameterParserRuleCall_1_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class PrimaryExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstructorCallExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVariableValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPropertyValueParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cKeywordVariablesParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cParanthesizedExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//PrimaryExpression returns Expression:
		//  Literal|ConstructorCallExpression|VariableValue|PropertyValue|KeywordVariables|
		//  ParanthesizedExpression; 
		//		
		//    
		//	   
		////	| FeatureCall
		public ParserRule getRule() { return rule; }

		//Literal|ConstructorCallExpression|VariableValue|PropertyValue|KeywordVariables|
		//ParanthesizedExpression 
		//		
		//    
		//	   
		////	| FeatureCall
		public Alternatives getAlternatives() { return cAlternatives; }

		//Literal    
		////	| FeatureCall
		public RuleCall getLiteralParserRuleCall_0() { return cLiteralParserRuleCall_0; }

		//ConstructorCallExpression
		public RuleCall getConstructorCallExpressionParserRuleCall_1() { return cConstructorCallExpressionParserRuleCall_1; }

		//VariableValue
		public RuleCall getVariableValueParserRuleCall_2() { return cVariableValueParserRuleCall_2; }

		//PropertyValue
		public RuleCall getPropertyValueParserRuleCall_3() { return cPropertyValueParserRuleCall_3; }

		//KeywordVariables
		public RuleCall getKeywordVariablesParserRuleCall_4() { return cKeywordVariablesParserRuleCall_4; }

		//ParanthesizedExpression
		public RuleCall getParanthesizedExpressionParserRuleCall_5() { return cParanthesizedExpressionParserRuleCall_5; }
	}

	public class PropertyValueElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyValue");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNamePIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//PropertyValue:
		//  name=PID;
		public ParserRule getRule() { return rule; }

		//name=PID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_0() { return cNamePIDTerminalRuleCall_0; }
	}

	public class VariableValueElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableValue");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VariableValue:
		//  name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class KeywordVariablesElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "KeywordVariables");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final Keyword cNameGroupKeyword_0_0 = (Keyword)cNameAlternatives_0.eContents().get(0);
		private final Keyword cNameLayoutKeyword_0_1 = (Keyword)cNameAlternatives_0.eContents().get(1);
		private final Keyword cNamePropertiesKeyword_0_2 = (Keyword)cNameAlternatives_0.eContents().get(2);
		
		//KeywordVariables:
		//  name=( "group" | "layout" | "properties" ); 
		//                  
		//
		////FeatureCall:
		////	OperationCall
		////	;
		////	
		////OperationCall 
		////	: name=(ID|PID) "(" (params+=Parameter ("," params+=Parameter)*)? ")" 
		////	;
		public ParserRule getRule() { return rule; }

		//name=( "group" | "layout" | "properties" )
		public Assignment getNameAssignment() { return cNameAssignment; }

		//"group"|"layout"|"properties"
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }

		//"group"
		public Keyword getNameGroupKeyword_0_0() { return cNameGroupKeyword_0_0; }

		//"layout"
		public Keyword getNameLayoutKeyword_0_1() { return cNameLayoutKeyword_0_1; }

		//"properties"
		public Keyword getNamePropertiesKeyword_0_2() { return cNamePropertiesKeyword_0_2; }
	}

	public class ConstructorCallExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstructorCallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNewKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClassAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cClassQualifiedNameParserRuleCall_1_0 = (RuleCall)cClassAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParamsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParamsParameterParserRuleCall_3_0_0 = (RuleCall)cParamsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParamsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParamsParameterParserRuleCall_3_1_1_0 = (RuleCall)cParamsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ConstructorCallExpression:
		//  "new" class=QualifiedName "(" (params+=Parameter ("," params+=Parameter)*)? ")"; 
		//
		////FeatureCall:
		////	OperationCall
		////	;
		////	
		////OperationCall 
		////	: name=(ID|PID) "(" (params+=Parameter ("," params+=Parameter)*)? ")" 
		////	;
		public ParserRule getRule() { return rule; }

		//"new" class=QualifiedName "(" (params+=Parameter ("," params+=Parameter)*)? ")"
		public Group getGroup() { return cGroup; }

		//"new"
		public Keyword getNewKeyword_0() { return cNewKeyword_0; }

		//class=QualifiedName
		public Assignment getClassAssignment_1() { return cClassAssignment_1; }

		//QualifiedName
		public RuleCall getClassQualifiedNameParserRuleCall_1_0() { return cClassQualifiedNameParserRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(params+=Parameter ("," params+=Parameter)*)?
		public Group getGroup_3() { return cGroup_3; }

		//params+=Parameter
		public Assignment getParamsAssignment_3_0() { return cParamsAssignment_3_0; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_3_0_0() { return cParamsParameterParserRuleCall_3_0_0; }

		//("," params+=Parameter)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//params+=Parameter
		public Assignment getParamsAssignment_3_1_1() { return cParamsAssignment_3_1_1; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_3_1_1_0() { return cParamsParameterParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class LiteralElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRegexpLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLiteralArrayParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralObjectParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLiteralFunctionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Literal:
		//  ValueLiteral|RegexpLiteral|LiteralArray|LiteralObject|LiteralFunction;
		public ParserRule getRule() { return rule; }

		//ValueLiteral|RegexpLiteral|LiteralArray|LiteralObject|LiteralFunction
		public Alternatives getAlternatives() { return cAlternatives; }

		//ValueLiteral
		public RuleCall getValueLiteralParserRuleCall_0() { return cValueLiteralParserRuleCall_0; }

		//RegexpLiteral
		public RuleCall getRegexpLiteralParserRuleCall_1() { return cRegexpLiteralParserRuleCall_1; }

		//LiteralArray
		public RuleCall getLiteralArrayParserRuleCall_2() { return cLiteralArrayParserRuleCall_2; }

		//LiteralObject
		public RuleCall getLiteralObjectParserRuleCall_3() { return cLiteralObjectParserRuleCall_3; }

		//LiteralFunction
		public RuleCall getLiteralFunctionParserRuleCall_4() { return cLiteralFunctionParserRuleCall_4; }
	}

	public class LiteralArrayElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralArray");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cElementAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cElementExpressionParserRuleCall_1_0_0 = (RuleCall)cElementAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cElementAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cElementExpressionParserRuleCall_1_1_1_0 = (RuleCall)cElementAssignment_1_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//LiteralArray:
		//  "[" (element+=Expression ("," element+=Expression)*)? "]";
		public ParserRule getRule() { return rule; }

		//"[" (element+=Expression ("," element+=Expression)*)? "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//(element+=Expression ("," element+=Expression)*)?
		public Group getGroup_1() { return cGroup_1; }

		//element+=Expression
		public Assignment getElementAssignment_1_0() { return cElementAssignment_1_0; }

		//Expression
		public RuleCall getElementExpressionParserRuleCall_1_0_0() { return cElementExpressionParserRuleCall_1_0_0; }

		//("," element+=Expression)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//element+=Expression
		public Assignment getElementAssignment_1_1_1() { return cElementAssignment_1_1_1; }

		//Expression
		public RuleCall getElementExpressionParserRuleCall_1_1_1_0() { return cElementExpressionParserRuleCall_1_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class LiteralObjectElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cFeaturesAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cFeaturesFeatureParserRuleCall_1_0_0 = (RuleCall)cFeaturesAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cFeaturesAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cFeaturesFeatureParserRuleCall_1_1_1_0 = (RuleCall)cFeaturesAssignment_1_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//LiteralObject:
		//  "{" (features+=Feature ("," features+=Feature)*)? "}";
		public ParserRule getRule() { return rule; }

		//"{" (features+=Feature ("," features+=Feature)*)? "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//(features+=Feature ("," features+=Feature)*)?
		public Group getGroup_1() { return cGroup_1; }

		//features+=Feature
		public Assignment getFeaturesAssignment_1_0() { return cFeaturesAssignment_1_0; }

		//Feature
		public RuleCall getFeaturesFeatureParserRuleCall_1_0_0() { return cFeaturesFeatureParserRuleCall_1_0_0; }

		//("," features+=Feature)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//features+=Feature
		public Assignment getFeaturesAssignment_1_1_1() { return cFeaturesAssignment_1_1_1; }

		//Feature
		public RuleCall getFeaturesFeatureParserRuleCall_1_1_1_0() { return cFeaturesFeatureParserRuleCall_1_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class LiteralFunctionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParamsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParamsIDTerminalRuleCall_2_0_0 = (RuleCall)cParamsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParamsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParamsIDTerminalRuleCall_2_1_1_0 = (RuleCall)cParamsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cStatementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cStatementsStatementsParserRuleCall_5_0 = (RuleCall)cStatementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//LiteralFunction:
		//  "function" "(" (params+=ID ("," params+=ID)*) ")" "{" statements=Statements "}";
		public ParserRule getRule() { return rule; }

		//"function" "(" (params+=ID ("," params+=ID)*) ")" "{" statements=Statements "}"
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//params+=ID ("," params+=ID)*
		public Group getGroup_2() { return cGroup_2; }

		//params+=ID
		public Assignment getParamsAssignment_2_0() { return cParamsAssignment_2_0; }

		//ID
		public RuleCall getParamsIDTerminalRuleCall_2_0_0() { return cParamsIDTerminalRuleCall_2_0_0; }

		//("," params+=ID)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//params+=ID
		public Assignment getParamsAssignment_2_1_1() { return cParamsAssignment_2_1_1; }

		//ID
		public RuleCall getParamsIDTerminalRuleCall_2_1_1_0() { return cParamsIDTerminalRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//statements=Statements
		public Assignment getStatementsAssignment_5() { return cStatementsAssignment_5; }

		//Statements
		public RuleCall getStatementsStatementsParserRuleCall_5_0() { return cStatementsStatementsParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class FeatureElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Feature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0_0 = (RuleCall)cNameAlternatives_0_0.eContents().get(0);
		private final RuleCall cNamePIDTerminalRuleCall_0_0_1 = (RuleCall)cNameAlternatives_0_0.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0_2 = (RuleCall)cNameAlternatives_0_0.eContents().get(2);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Feature:
		//  name=( ID | PID | STRING ) ":" value=Expression;
		public ParserRule getRule() { return rule; }

		//name=( ID | PID | STRING ) ":" value=Expression
		public Group getGroup() { return cGroup; }

		//name=( ID | PID | STRING )
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID|PID|STRING
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0_0() { return cNameIDTerminalRuleCall_0_0_0; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_0_0_1() { return cNamePIDTerminalRuleCall_0_0_1; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0_2() { return cNameSTRINGTerminalRuleCall_0_0_2; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//value=Expression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_0() { return cValueExpressionParserRuleCall_2_0; }
	}

	public class ValueLiteralElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntegerLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNullLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVoidLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStringLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cRealLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//ValueLiteral:
		//  BooleanLiteral|IntegerLiteral|NullLiteral|VoidLiteral|StringLiteral|RealLiteral; 
		//
		//
		//	   
		//	   
		//	        // null == defined but null, void is undefined
		public ParserRule getRule() { return rule; }

		//BooleanLiteral|IntegerLiteral|NullLiteral|VoidLiteral|StringLiteral|RealLiteral 
		//
		//
		//	   
		//	   
		//	        // null == defined but null, void is undefined
		public Alternatives getAlternatives() { return cAlternatives; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_0() { return cBooleanLiteralParserRuleCall_0; }

		//IntegerLiteral
		public RuleCall getIntegerLiteralParserRuleCall_1() { return cIntegerLiteralParserRuleCall_1; }

		//NullLiteral
		public RuleCall getNullLiteralParserRuleCall_2() { return cNullLiteralParserRuleCall_2; }

		//VoidLiteral     // null == defined but null, void is undefined
		public RuleCall getVoidLiteralParserRuleCall_3() { return cVoidLiteralParserRuleCall_3; }

		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_4() { return cStringLiteralParserRuleCall_4; }

		//RealLiteral
		public RuleCall getRealLiteralParserRuleCall_5() { return cRealLiteralParserRuleCall_5; }
	}

	public class BooleanLiteralElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cValAlternatives_0 = (Alternatives)cValAssignment.eContents().get(0);
		private final Keyword cValTrueKeyword_0_0 = (Keyword)cValAlternatives_0.eContents().get(0);
		private final Keyword cValFalseKeyword_0_1 = (Keyword)cValAlternatives_0.eContents().get(1);
		
		//BooleanLiteral:
		//  val=( "true" | "false" );
		public ParserRule getRule() { return rule; }

		//val=( "true" | "false" )
		public Assignment getValAssignment() { return cValAssignment; }

		//"true"|"false"
		public Alternatives getValAlternatives_0() { return cValAlternatives_0; }

		//"true"
		public Keyword getValTrueKeyword_0_0() { return cValTrueKeyword_0_0; }

		//"false"
		public Keyword getValFalseKeyword_0_1() { return cValFalseKeyword_0_1; }
	}

	public class IntegerLiteralElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValINTTerminalRuleCall_0_0 = (RuleCall)cValAssignment_0.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//IntegerLiteral:
		//  val=INT|HEX;
		public ParserRule getRule() { return rule; }

		//val=INT|HEX
		public Alternatives getAlternatives() { return cAlternatives; }

		//val=INT
		public Assignment getValAssignment_0() { return cValAssignment_0; }

		//INT
		public RuleCall getValINTTerminalRuleCall_0_0() { return cValINTTerminalRuleCall_0_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1() { return cHEXTerminalRuleCall_1; }
	}

	public class NullLiteralElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NullLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cValNullKeyword_0 = (Keyword)cValAssignment.eContents().get(0);
		
		//NullLiteral:
		//  val="null";
		public ParserRule getRule() { return rule; }

		//val="null"
		public Assignment getValAssignment() { return cValAssignment; }

		//"null"
		public Keyword getValNullKeyword_0() { return cValNullKeyword_0; }
	}

	public class VoidLiteralElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VoidLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cValVoidKeyword_0 = (Keyword)cValAssignment.eContents().get(0);
		
		//VoidLiteral:
		//  val="void";
		public ParserRule getRule() { return rule; }

		//val="void"
		public Assignment getValAssignment() { return cValAssignment; }

		//"void"
		public Keyword getValVoidKeyword_0() { return cValVoidKeyword_0; }
	}

	public class StringLiteralElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValSTRINGTerminalRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//StringLiteral:
		//  val=STRING;
		public ParserRule getRule() { return rule; }

		//val=STRING
		public Assignment getValAssignment() { return cValAssignment; }

		//STRING
		public RuleCall getValSTRINGTerminalRuleCall_0() { return cValSTRINGTerminalRuleCall_0; }
	}

	public class RealLiteralElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RealLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValREALTerminalRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//RealLiteral:
		//  val=REAL;
		public ParserRule getRule() { return rule; }

		//val=REAL
		public Assignment getValAssignment() { return cValAssignment; }

		//REAL
		public RuleCall getValREALTerminalRuleCall_0() { return cValREALTerminalRuleCall_0; }
	}

	public class RegexpLiteralElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RegexpLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValREGEXTerminalRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//RegexpLiteral:
		//  val=REGEX;
		public ParserRule getRule() { return rule; }

		//val=REGEX
		public Assignment getValAssignment() { return cValAssignment; }

		//REGEX
		public RuleCall getValREGEXTerminalRuleCall_0() { return cValREGEXTerminalRuleCall_0; }
	}

	public class ParanthesizedExpressionElements implements IParserRuleAccess {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParanthesizedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParanthesizedExpression returns Expression:
		//  "(" Expression ")";
		public ParserRule getRule() { return rule; }

		//"(" Expression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	
	
	public class VisibilityElements implements IEnumRuleAccess {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Visibility");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPublicEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPublicPublicKeyword_0_0 = (Keyword)cPublicEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPrivateEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPrivatePrivateKeyword_1_0 = (Keyword)cPrivateEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Visibility:
		//  public | private;
		public EnumRule getRule() { return rule; }

		//public | private
		public Alternatives getAlternatives() { return cAlternatives; }

		//public
		public EnumLiteralDeclaration getPublicEnumLiteralDeclaration_0() { return cPublicEnumLiteralDeclaration_0; }

		//"public"
		public Keyword getPublicPublicKeyword_0_0() { return cPublicPublicKeyword_0_0; }

		//private
		public EnumLiteralDeclaration getPrivateEnumLiteralDeclaration_1() { return cPrivateEnumLiteralDeclaration_1; }

		//"private"
		public Keyword getPrivatePrivateKeyword_1_0() { return cPrivatePrivateKeyword_1_0; }
	}

	public class AssertionScopeElements implements IEnumRuleAccess {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionScope");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPreconditionEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPreconditionPreconditionKeyword_0_0 = (Keyword)cPreconditionEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPostconditionEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPostconditionPostconditionKeyword_1_0 = (Keyword)cPostconditionEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AssertionScope:
		//  precondition | postcondition;
		public EnumRule getRule() { return rule; }

		//precondition | postcondition
		public Alternatives getAlternatives() { return cAlternatives; }

		//precondition
		public EnumLiteralDeclaration getPreconditionEnumLiteralDeclaration_0() { return cPreconditionEnumLiteralDeclaration_0; }

		//"precondition"
		public Keyword getPreconditionPreconditionKeyword_0_0() { return cPreconditionPreconditionKeyword_0_0; }

		//postcondition
		public EnumLiteralDeclaration getPostconditionEnumLiteralDeclaration_1() { return cPostconditionEnumLiteralDeclaration_1; }

		//"postcondition"
		public Keyword getPostconditionPostconditionKeyword_1_0() { return cPostconditionPostconditionKeyword_1_0; }
	}

	public class ExecutionModeElements implements IEnumRuleAccess {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ExecutionMode");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cParallelEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cParallelParallelKeyword_0_0 = (Keyword)cParallelEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSequentialEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSequentialSequentialKeyword_1_0 = (Keyword)cSequentialEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ExecutionMode:
		//  parallel | sequential; 
		//   	         
		//
		//// Version, and VersionRange
		//// TODO: make it into a datatype and have better rules, syntax coloring (now integer parts are colored grey, other parts are not colored), etc.
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public EnumRule getRule() { return rule; }

		//parallel | sequential 
		//   	         
		//
		//// Version, and VersionRange
		//// TODO: make it into a datatype and have better rules, syntax coloring (now integer parts are colored grey, other parts are not colored), etc.
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public Alternatives getAlternatives() { return cAlternatives; }

		//parallel
		public EnumLiteralDeclaration getParallelEnumLiteralDeclaration_0() { return cParallelEnumLiteralDeclaration_0; }

		//"parallel"
		public Keyword getParallelParallelKeyword_0_0() { return cParallelParallelKeyword_0_0; }

		//sequential
		public EnumLiteralDeclaration getSequentialEnumLiteralDeclaration_1() { return cSequentialEnumLiteralDeclaration_1; }

		//"sequential"
		public Keyword getSequentialSequentialKeyword_1_0() { return cSequentialSequentialKeyword_1_0; }
	}
	
	private BeeModelElements pBeeModel;
	private TerminalRule tID;
	private TerminalRule tPID;
	private TerminalRule tREGEX;
	private TerminalRule tSTRING;
	private TerminalRule tML_COMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tHEX;
	private TerminalRule tINT;
	private TerminalRule tREAL;
	private TerminalRule tANY_OTHER;
	private QualifiedNameElements pQualifiedName;
	private HIDDENBUGElements pHIDDENBUG;
	private PROPElements pPROP;
	private PropertyNameElements pPropertyName;
	private EscapedQualifiedNameElements pEscapedQualifiedName;
	private InterfaceNameElements pInterfaceName;
	private CompoundNameElements pCompoundName;
	private UnitNameElements pUnitName;
	private PartNameElements pPartName;
	private VisibilityElements unknownRuleVisibility;
	private AssertionScopeElements unknownRuleAssertionScope;
	private ExecutionModeElements unknownRuleExecutionMode;
	private SeparatorElements pSeparator;
	private AlfanumSymElements pAlfanumSym;
	private VersionElements pVersion;
	private VersionRangeElements pVersionRange;
	private ImportElements pImport;
	private UnitElements pUnit;
	private ProvidedCapabilityElements pProvidedCapability;
	private RequiredCapabilityElements pRequiredCapability;
	private NamedPropertyStatementsElements pNamedPropertyStatements;
	private PropertyStatementsElements pPropertyStatements;
	private PropertyStatementElements pPropertyStatement;
	private UnsetPropertyStatementElements pUnsetPropertyStatement;
	private AnnotationStatementElements pAnnotationStatement;
	private PropertyExpressionElements pPropertyExpression;
	private SynchronizationElements pSynchronization;
	private SynchronizedPartElements pSynchronizedPart;
	private PathGroupElements pPathGroup;
	private PathExpressionElements pPathExpression;
	private ExprStatementElements pExprStatement;
	private PathElements pPath;
	private PrerequisiteElements pPrerequisite;
	private ClosureElements pClosure;
	private PrerequisiteEntryElements pPrerequisiteEntry;
	private PartInSelfElements pPartInSelf;
	private CapabilityReferencedPartElements pCapabilityReferencedPart;
	private CompoundReferencesElements pCompoundReferences;
	private PartElements pPart;
	private ParameterElements pParameter;
	private LayoutElements pLayout;
	private ActionInputGroupElements pActionInputGroup;
	private RepositoryConfigurationElements pRepositoryConfiguration;
	private URIElements pURI;
	private NamedAdviceElements pNamedAdvice;
	private AdviceElements pAdvice;
	private CompoundAdviceElements pCompoundAdvice;
	private AdviceStatementElements pAdviceStatement;
	private AdvicePathElements pAdvicePath;
	private AdvicePathSeparatorElements pAdvicePathSeparator;
	private AdvicePathChildrenElements pAdvicePathChildren;
	private AdvicePathElementElements pAdvicePathElement;
	private WildcardNodeElements pWildcardNode;
	private FilterElements pFilter;
	private PreConditionAssertElements pPreConditionAssert;
	private PostConditionAssertElements pPostConditionAssert;
	private AssertionExpressionElements pAssertionExpression;
	private StatementElements pStatement;
	private BreakStatementElements pBreakStatement;
	private ContinueStatementElements pContinueStatement;
	private CompoundStatementElements pCompoundStatement;
	private StatementsElements pStatements;
	private WhileStatementElements pWhileStatement;
	private SwitchStatementElements pSwitchStatement;
	private CaseElements pCase;
	private ForStatementElements pForStatement;
	private DoWhileStatementElements pDoWhileStatement;
	private ReturnStatementElements pReturnStatement;
	private FunctionStatementElements pFunctionStatement;
	private IfStatementElements pIfStatement;
	private LabelStatementElements pLabelStatement;
	private ThrowStatementElements pThrowStatement;
	private TryCatchStatementElements pTryCatchStatement;
	private CatchBlockElements pCatchBlock;
	private FinallyBlockElements pFinallyBlock;
	private WithStatementElements pWithStatement;
	private SyntaxElementElements pSyntaxElement;
	private VarExpressionListElements pVarExpressionList;
	private ExpressionListElements pExpressionList;
	private VarExpressionElements pVarExpression;
	private ExpressionElements pExpression;
	private ValueExpressionElements pValueExpression;
	private AssignmentExpressionElements pAssignmentExpression;
	private ChainExpressionElements pChainExpression;
	private ChainedExpressionElements pChainedExpression;
	private IfExpressionElements pIfExpression;
	private OrExpressionElements pOrExpression;
	private AndExpressionElements pAndExpression;
	private BitwiseExpressionElements pBitwiseExpression;
	private RelationalExpressionElements pRelationalExpression;
	private AdditiveExpressionElements pAdditiveExpression;
	private MultiplicativeExpressionElements pMultiplicativeExpression;
	private UnaryOrInfixExpressionElements pUnaryOrInfixExpression;
	private UnaryExpressionElements pUnaryExpression;
	private PostopExpressionElements pPostopExpression;
	private InfixExpressionElements pInfixExpression;
	private CallExpressionElements pCallExpression;
	private PrimaryExpressionElements pPrimaryExpression;
	private PropertyValueElements pPropertyValue;
	private VariableValueElements pVariableValue;
	private KeywordVariablesElements pKeywordVariables;
	private ConstructorCallExpressionElements pConstructorCallExpression;
	private LiteralElements pLiteral;
	private LiteralArrayElements pLiteralArray;
	private LiteralObjectElements pLiteralObject;
	private LiteralFunctionElements pLiteralFunction;
	private FeatureElements pFeature;
	private ValueLiteralElements pValueLiteral;
	private BooleanLiteralElements pBooleanLiteral;
	private IntegerLiteralElements pIntegerLiteral;
	private NullLiteralElements pNullLiteral;
	private VoidLiteralElements pVoidLiteral;
	private StringLiteralElements pStringLiteral;
	private RealLiteralElements pRealLiteral;
	private RegexpLiteralElements pRegexpLiteral;
	private ParanthesizedExpressionElements pParanthesizedExpression;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public BeeLangGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//BeeModel:
	//  imports+=Import* body=Unit; 
	//                
	//
	//// Redeclare the default ID without the ^ keyword escape mechanism, and including
	//// the JS $ char which is allowed in the first position.
	////
	public BeeModelElements getBeeModelAccess() {
		return (pBeeModel != null) ? pBeeModel : (pBeeModel = new BeeModelElements());
	}
	
	public ParserRule getBeeModelRule() {
		return getBeeModelAccess().getRule();
	}

	//terminal ID:
	//  ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "0".."9" | "_")*; 
	//
	//// Redeclare the default ID without the ^ keyword escape mechanism, and including
	//// the JS $ char which is allowed in the first position.
	////
	//          
	//
	//// Property Names start with $ and are qualified. Must be handled by lexer as
	//// a.b.c is otherwise ambigous in expressions.
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal PID:
	//  "$" ID ("." ID)*; 
	//
	//// Property Names start with $ and are qualified. Must be handled by lexer as
	//// a.b.c is otherwise ambigous in expressions.
	//
	//              
	//
	//// JS Regexp - but cheating by using @ instead of / because of inability to push back terminators
	//// and / clashes with / in math.
	////
	public TerminalRule getPIDRule() {
		return (tPID != null) ? tPID : (tPID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PID"));
	} 

	//terminal REGEX:
	//  "~/" ("\\" ("/" | "f" | "n" | "r" | "t" | "v" | "\\" | "." | "*" | "+" | "?" | "w" | "W" | "s" | "S" | "d" | "D" |
	//  "b" | "|" | "{" | "}" | "[" | "]" | "(" | ")" | "0".."7" "0".."7" "0".."7" | "x" ("0".."9" | "a".."f" |
	//  "A".."F") ("0".."9" | "a".."f" | "A".."F") | "c" "A".."Z") | !("\\" | "/" | " " | "\t" | "\r" | "\n"
	//  ))* "/" ("g" | "m" | "i")?; 
	//
	//// JS Regexp - but cheating by using @ instead of / because of inability to push back terminators
	//// and / clashes with / in math.
	////
	//   
	//	        
	//					  
	//					
	//					   
	//					       
	//					    
	//				
	//			      
	//			
	//
	//// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
	//// A string converter may need to handle the u, x, and octal escapes.
	//// Regular java string handles XXXX , and gives syntax error if
	//// format is not ok, the other two remains, and possibly the null.
	public TerminalRule getREGEXRule() {
		return (tREGEX != null) ? tREGEX : (tREGEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REGEX"));
	} 

	//terminal STRING:
	//  "\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "x" | "0" | "\"" | "\'" | "\\") | !("\\" | "\"" | "\r" | "\n")
	//  )* "\"" | "\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "x" | "0" | "\"" | "\'" | "\\") | !("\\" | "\'" |
	//  "\r" | "\n"))* "\'"; 
	//
	//// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
	//// A string converter may need to handle the u, x, and octal escapes.
	//// Regular java string handles XXXX , and gives syntax error if
	//// format is not ok, the other two remains, and possibly the null.
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal ML_COMMENT:
	//  "/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//terminal SL_COMMENT:
	//  "//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal WS:
	//  (" " | "\t" | "\r" | "\n")+; 
	//        
	//
	//// TODO: Should return EInt, but uncerain if converter handles hex
	////
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal HEX:
	//  "0" ("x" | "X") ("0".."9" | "a".."f" | "A".."F")+; 
	//
	//// TODO: Should return EInt, but uncerain if converter handles hex
	////
	//          
	//
	//// A JS integer is one of
	//// 0
	//// 0(0..7)*
	//// 0(x|X)(0-91-fA-F)*
	//// Validation can handle the octal case, and illegal 08, 09 00 sequencese
	//// TODO: converter must handle octal case if we want to support it.
	////
	public TerminalRule getHEXRule() {
		return (tHEX != null) ? tHEX : (tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX"));
	} 

	//terminal INT returns ecore::EInt:
	//  "0".."9"+; 
	//
	//// A JS integer is one of
	//// 0
	//// 0(0..7)*
	//// 0(x|X)(0-91-fA-F)*
	//// Validation can handle the octal case, and illegal 08, 09 00 sequencese
	//// TODO: converter must handle octal case if we want to support it.
	////
	//        
	//
	//// TODO: should be a floating point value and have a converter
	//// and check for illegal INT sequences "000" etc.
	//// Suppressing REAL without a decimal (INT '.') as well as ('.' INT) as
	//// a real otherwise can look as part of an Qualified name ('a'.e+1), the
	//// combination 'n.n' is not valid in a name.
	////
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//terminal REAL:
	//  (INT "." INT | INT "." | "." INT | INT) (("e" | "E") ("-" | "+") INT)?; 
	//
	//// TODO: should be a floating point value and have a converter
	//// and check for illegal INT sequences "000" etc.
	//// Suppressing REAL without a decimal (INT '.') as well as ('.' INT) as
	//// a real otherwise can look as part of an Qualified name ('a'.e+1), the
	//// combination 'n.n' is not valid in a name.
	////
	public TerminalRule getREALRule() {
		return (tREAL != null) ? tREAL : (tREAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REAL"));
	} 

	//terminal ANY_OTHER:
	//  .; 
	//
	//
	//        
	//
	//// Qualified name
	//// TODO: Needs to disallow whie space between ID and '.', and no embedded comments. A bug in xtext prevents using hidden() here.
	////
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 

	//QualifiedName returns ecore::EString hidden ( ):
	//  ID (INT|HEX|ID)* ("." ID (INT|HEX|ID)*)* HIDDENBUG; 
	//
	//// Qualified name
	//// TODO: Needs to disallow whie space between ID and '.', and no embedded comments. A bug in xtext prevents using hidden() here.
	////
	public QualifiedNameElements getQualifiedNameAccess() {
		return (pQualifiedName != null) ? pQualifiedName : (pQualifiedName = new QualifiedNameElements());
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//HIDDENBUG returns ecore::EString hidden ( WS , SL_COMMENT , ML_COMMENT ):
	//  "~~~~~"?; 
	//            // TODO: REPLACE HACK WHEN HIDDEN WORKS.
	//
	//
	//// Declare Property ID to include '.'
	public HIDDENBUGElements getHIDDENBUGAccess() {
		return (pHIDDENBUG != null) ? pHIDDENBUG : (pHIDDENBUG = new HIDDENBUGElements());
	}
	
	public ParserRule getHIDDENBUGRule() {
		return getHIDDENBUGAccess().getRule();
	}

	//PROP returns ecore::EString hidden ( ):
	//  "$" "{" QualifiedName "}";   // TODO: REPLACE HACK WHEN HIDDEN WORKS.
	//
	//
	//// Declare Property ID to include '.'
	public PROPElements getPROPAccess() {
		return (pPROP != null) ? pPROP : (pPROP = new PROPElements());
	}
	
	public ParserRule getPROPRule() {
		return getPROPAccess().getRule();
	}

	//PropertyName returns ecore::EString:
	//  PID;
	public PropertyNameElements getPropertyNameAccess() {
		return (pPropertyName != null) ? pPropertyName : (pPropertyName = new PropertyNameElements());
	}
	
	public ParserRule getPropertyNameRule() {
		return getPropertyNameAccess().getRule();
	}

	//EscapedQualifiedName returns ecore::EString:
	//  STRING|QualifiedName;
	public EscapedQualifiedNameElements getEscapedQualifiedNameAccess() {
		return (pEscapedQualifiedName != null) ? pEscapedQualifiedName : (pEscapedQualifiedName = new EscapedQualifiedNameElements());
	}
	
	public ParserRule getEscapedQualifiedNameRule() {
		return getEscapedQualifiedNameAccess().getRule();
	}

	//InterfaceName returns ecore::EString:
	//  QualifiedName; 
	//    
	//
	//// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
	//// do not allow being broken across lines.
	////
	public InterfaceNameElements getInterfaceNameAccess() {
		return (pInterfaceName != null) ? pInterfaceName : (pInterfaceName = new InterfaceNameElements());
	}
	
	public ParserRule getInterfaceNameRule() {
		return getInterfaceNameAccess().getRule();
	}

	//CompoundName returns ecore::EString:
	//  EscapedQualifiedName "/" EscapedQualifiedName; 
	//
	//// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
	//// do not allow being broken across lines.
	////
	//          
	//
	//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
	public CompoundNameElements getCompoundNameAccess() {
		return (pCompoundName != null) ? pCompoundName : (pCompoundName = new CompoundNameElements());
	}
	
	public ParserRule getCompoundNameRule() {
		return getCompoundNameAccess().getRule();
	}

	//UnitName returns ecore::EString:
	//  EscapedQualifiedName; 
	//
	//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
	public UnitNameElements getUnitNameAccess() {
		return (pUnitName != null) ? pUnitName : (pUnitName = new UnitNameElements());
	}
	
	public ParserRule getUnitNameRule() {
		return getUnitNameAccess().getRule();
	}

	//PartName returns ecore::EString:
	//  EscapedQualifiedName;
	public PartNameElements getPartNameAccess() {
		return (pPartName != null) ? pPartName : (pPartName = new PartNameElements());
	}
	
	public ParserRule getPartNameRule() {
		return getPartNameAccess().getRule();
	}

	//enum Visibility:
	//  public | private;
	public VisibilityElements getVisibilityAccess() {
		return (unknownRuleVisibility != null) ? unknownRuleVisibility : (unknownRuleVisibility = new VisibilityElements());
	}
	
	public EnumRule getVisibilityRule() {
		return getVisibilityAccess().getRule();
	}

	//enum AssertionScope:
	//  precondition | postcondition;
	public AssertionScopeElements getAssertionScopeAccess() {
		return (unknownRuleAssertionScope != null) ? unknownRuleAssertionScope : (unknownRuleAssertionScope = new AssertionScopeElements());
	}
	
	public EnumRule getAssertionScopeRule() {
		return getAssertionScopeAccess().getRule();
	}

	//enum ExecutionMode:
	//  parallel | sequential; 
	//   	         
	//
	//// Version, and VersionRange
	//// TODO: make it into a datatype and have better rules, syntax coloring (now integer parts are colored grey, other parts are not colored), etc.
	//// TODO: uncertain if the set of allowed chars is definitive.
	////
	public ExecutionModeElements getExecutionModeAccess() {
		return (unknownRuleExecutionMode != null) ? unknownRuleExecutionMode : (unknownRuleExecutionMode = new ExecutionModeElements());
	}
	
	public EnumRule getExecutionModeRule() {
		return getExecutionModeAccess().getRule();
	}

	//Separator returns ecore::EString:
	//  "."|"-"|"!"|"@"|"$"|"%"|"&"|"+"|"="|"*"|"<"|">"|":"|"?"; 
	//
	//// Version, and VersionRange
	//// TODO: make it into a datatype and have better rules, syntax coloring (now integer parts are colored grey, other parts are not colored), etc.
	//// TODO: uncertain if the set of allowed chars is definitive.
	////
	public SeparatorElements getSeparatorAccess() {
		return (pSeparator != null) ? pSeparator : (pSeparator = new SeparatorElements());
	}
	
	public ParserRule getSeparatorRule() {
		return getSeparatorAccess().getRule();
	}

	//AlfanumSym returns ecore::EString:
	//  (ID|INT|HEX|REAL) (Separator|ID|INT|HEX|REAL)*;
	public AlfanumSymElements getAlfanumSymAccess() {
		return (pAlfanumSym != null) ? pAlfanumSym : (pAlfanumSym = new AlfanumSymElements());
	}
	
	public ParserRule getAlfanumSymRule() {
		return getAlfanumSymAccess().getRule();
	}

	//Version returns ecore::EString:
	//  STRING|AlfanumSym; 
	//
	//
	//	    
	//	  
	//	
	//
	/// *
	// ** VersionRange TODO: Uses two instances of Version. This works because use of [ ]  ( ) in Version must be 
	// ** escaped with " ". Omni
	// ** version uses version strings with \[ when a range is presented/parsed in string format.
	// * /
	public VersionElements getVersionAccess() {
		return (pVersion != null) ? pVersion : (pVersion = new VersionElements());
	}
	
	public ParserRule getVersionRule() {
		return getVersionAccess().getRule();
	}

	//VersionRange returns ecore::EString:
	//  ("["|"(") Version ("," Version)? ("]"|")")|Version; 
	//
	/// *
	// ** VersionRange TODO: Uses two instances of Version. This works because use of [ ]  ( ) in Version must be 
	// ** escaped with " ". Omni
	// ** version uses version strings with \[ when a range is presented/parsed in string format.
	// * /
	//
	//	              
	//	  
	//	
	//
	/// *
	// ** Import
	// ** TODO: Is specified as import of URI, a String, should be QID
	// * /
	public VersionRangeElements getVersionRangeAccess() {
		return (pVersionRange != null) ? pVersionRange : (pVersionRange = new VersionRangeElements());
	}
	
	public ParserRule getVersionRangeRule() {
		return getVersionRangeAccess().getRule();
	}

	//Import:
	//  "import" importClass=QualifiedName ".*"? ";"; 
	//
	/// *
	// ** Import
	// ** TODO: Is specified as import of URI, a String, should be QID
	// * /	
	//  
	//	         
	//		
	/// * UNIT - the body (compare to java class)
	// * /
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	//Unit returns BuildUnit hidden ( WS , ML_COMMENT , SL_COMMENT ):
	//  executionMode=ExecutionMode? "unit" name=UnitName? ("version" version=Version)? (
	//  "implements" implements+=InterfaceName ("," implements+=InterfaceName)*)? "{" (
	//  "properties" propertyStatements+=NamedPropertyStatements)* ("provides" "{" (
	//  providedCapability+=ProvidedCapability ";")+ "}"|"provides" providedCapability+=
	//  ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=RequiredCapability ";")
	//  + "}"|"requires" requiredCapabilities+=RequiredCapability ";"|"meta" "requires" "{" (
	//  metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"meta" "requires"
	//  metaRequiredCapabilities+=RequiredCapability ";"|"advice" advice+=NamedAdvice|
	//  "sequential" "{" synchronize+=Synchronization+ "}"|"sequential" synchronize+=
	//  Synchronization|parts+=Part|"repositories" "{" repositoryConfig+=
	//  RepositoryConfiguration* "}")* "}";  
	//		
	/// * UNIT - the body (compare to java class)
	// * /	
	//            
	//	    
	//	          
	//		           
	//	
	//			 //-- PROPERTIES
	//			 // goes first, because they may be used in the other clauses.
	//			 //
	//			          
	//		
	//		 	 //-- PROVIDES
	//			               
	//			          
	//			//-- REQUIRES & META REQUIRES
	//			               
	//			          
	//			                  
	//			            
	//			//--ADVICE
	//			       
	//			//--SYNCHRONIZE
	//			                  
	//			           
	//			//--PARTS
	//			         			
	//			//-- REPOSITORIES
	public UnitElements getUnitAccess() {
		return (pUnit != null) ? pUnit : (pUnit = new UnitElements());
	}
	
	public ParserRule getUnitRule() {
		return getUnitAccess().getRule();
	}

	//ProvidedCapability:
	//  ("when" filter=Filter)? interface=QualifiedName "/" name=QualifiedName ("/" version=
	//  Version)?;
	public ProvidedCapabilityElements getProvidedCapabilityAccess() {
		return (pProvidedCapability != null) ? pProvidedCapability : (pProvidedCapability = new ProvidedCapabilityElements());
	}
	
	public ParserRule getProvidedCapabilityRule() {
		return getProvidedCapabilityAccess().getRule();
	}

	//RequiredCapability:
	//  ("when" filter=Filter)? interface=QualifiedName "/" name=QualifiedName ("/" range=
	//  VersionRange)?; 
	//                   
	//
	//// An optionally named sequence of property statements
	public RequiredCapabilityElements getRequiredCapabilityAccess() {
		return (pRequiredCapability != null) ? pRequiredCapability : (pRequiredCapability = new RequiredCapabilityElements());
	}
	
	public ParserRule getRequiredCapabilityRule() {
		return getRequiredCapabilityAccess().getRule();
	}

	//NamedPropertyStatements returns PropertyStatements:
	//  name=ID? statements=PropertyStatements; 
	//
	//// An optionally named sequence of property statements
	//    
	//	             
	//	
	//
	//// Sequence of property statements
	public NamedPropertyStatementsElements getNamedPropertyStatementsAccess() {
		return (pNamedPropertyStatements != null) ? pNamedPropertyStatements : (pNamedPropertyStatements = new NamedPropertyStatementsElements());
	}
	
	public ParserRule getNamedPropertyStatementsRule() {
		return getNamedPropertyStatementsAccess().getRule();
	}

	//PropertyStatements returns PropertyStatement:
	//  "{" (("when" filter=Filter)? (statements+=UnsetPropertyStatement|statements+=
	//  PropertyStatement|statements+=PropertyStatements))* "}"; 
	//
	//// Sequence of property statements
	public PropertyStatementsElements getPropertyStatementsAccess() {
		return (pPropertyStatements != null) ? pPropertyStatements : (pPropertyStatements = new PropertyStatementsElements());
	}
	
	public ParserRule getPropertyStatementsRule() {
		return getPropertyStatementsAccess().getRule();
	}

	//PropertyStatement:
	//  immutable?="immutable"? key=PropertyName op=( "=" | "+=" | "-=" | "*=" | "/=" ) value=
	//  PropertyExpression ";";
	public PropertyStatementElements getPropertyStatementAccess() {
		return (pPropertyStatement != null) ? pPropertyStatement : (pPropertyStatement = new PropertyStatementElements());
	}
	
	public ParserRule getPropertyStatementRule() {
		return getPropertyStatementAccess().getRule();
	}

	//UnsetPropertyStatement returns PropertyStatement:
	//  "unset" unsetProperties+=PropertyName ";"; 
	//
	//    
	//	             
	//	
	//
	//// identical to nested properties statement, but used to get a separate data type
	public UnsetPropertyStatementElements getUnsetPropertyStatementAccess() {
		return (pUnsetPropertyStatement != null) ? pUnsetPropertyStatement : (pUnsetPropertyStatement = new UnsetPropertyStatementElements());
	}
	
	public ParserRule getUnsetPropertyStatementRule() {
		return getUnsetPropertyStatementAccess().getRule();
	}

	//AnnotationStatement returns PropertyStatement:
	//  ("when" filter=Filter)? immutable?="immutable"? key=PropertyName op=( "=" | "+=" | "-=" |
	//  "*=" | "/=" ) value=PropertyExpression ";"; 
	//
	//// identical to nested properties statement, but used to get a separate data type
	public AnnotationStatementElements getAnnotationStatementAccess() {
		return (pAnnotationStatement != null) ? pAnnotationStatement : (pAnnotationStatement = new AnnotationStatementElements());
	}
	
	public ParserRule getAnnotationStatementRule() {
		return getAnnotationStatementAccess().getRule();
	}

	//PropertyExpression:
	//  Expression;
	public PropertyExpressionElements getPropertyExpressionAccess() {
		return (pPropertyExpression != null) ? pPropertyExpression : (pPropertyExpression = new PropertyExpressionElements());
	}
	
	public ParserRule getPropertyExpressionRule() {
		return getPropertyExpressionAccess().getRule();
	}

	//Synchronization:
	//  partrefs+=SynchronizedPart ("," partrefs+=SynchronizedPart)+ ";";  
	//
	// 
	//	                // at least 2
	public SynchronizationElements getSynchronizationAccess() {
		return (pSynchronization != null) ? pSynchronization : (pSynchronization = new SynchronizationElements());
	}
	
	public ParserRule getSynchronizationRule() {
		return getSynchronizationAccess().getRule();
	}

	//SynchronizedPart returns ecore::EString:
	//  CompoundName ("#" PartName)?|PartName; 
	//	
	//
	//	      
	//	  
	//	
	//	
	//
	//// NOT NEEDED - action can specify a layout and return it	
	////Artifacts returns ArtifactsPart 
	////	: (visibility = Visibility)? 'artifacts' name=PartName
	////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
	////		(asserts += PostConditionAssert)?
	////		'{' (paths += PathGroup)* '}'
	////	;
	//	
	/// * PATH GROUP
	// * TODO: Allow basePath without paths?
	// * TODO: generated structure is wrong . should be in sequence, basepath and expr are out of band !!
	// * /
	public SynchronizedPartElements getSynchronizedPartAccess() {
		return (pSynchronizedPart != null) ? pSynchronizedPart : (pSynchronizedPart = new SynchronizedPartElements());
	}
	
	public ParserRule getSynchronizedPartRule() {
		return getSynchronizedPartAccess().getRule();
	}

	//PathGroup:
	//  ("when" filter=Filter)? (paths+=PathExpression (("," paths+=PathExpression)*|
	//  firstIsBase?="[" paths+=PathExpression ("," paths+=PathExpression)* "]") ";"|
	//  "annotations" "{" ("unset" unsetProperties+=PropertyName ";"|setProperties+=
	//  AnnotationStatement)+ "}"); 
	//	
	//
	//// NOT NEEDED - action can specify a layout and return it	
	////Artifacts returns ArtifactsPart 
	////	: (visibility = Visibility)? 'artifacts' name=PartName
	////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
	////		(asserts += PostConditionAssert)?
	////		'{' (paths += PathGroup)* '}'
	////	;
	//	
	/// * PATH GROUP
	// * TODO: Allow basePath without paths?
	// * TODO: generated structure is wrong . should be in sequence, basepath and expr are out of band !!
	// * /
	// 
	//	     
	//		   
	//		           
	//		                
	//		      
	////		| basePath=PathExpression '[' paths+=PathExpression (',' paths+=PathExpression)* ']' ';'
	////		| ('expr' pathExpressions += Expression ';' )
	public PathGroupElements getPathGroupAccess() {
		return (pPathGroup != null) ? pPathGroup : (pPathGroup = new PathGroupElements());
	}
	
	public ParserRule getPathGroupRule() {
		return getPathGroupAccess().getRule();
	}

	//PathExpression:
	//  Path|ExprStatement;
	public PathExpressionElements getPathExpressionAccess() {
		return (pPathExpression != null) ? pPathExpression : (pPathExpression = new PathExpressionElements());
	}
	
	public ParserRule getPathExpressionRule() {
		return getPathExpressionAccess().getRule();
	}

	//ExprStatement:
	//  "expr" "(" expression=Expression ")"; 
	//
	//                  
	//
	/// *
	// * A path can be written without quotes if it consists of safe chars 
	// * TODO: repace use of ID with better definition.
	// * TODO: Validation of path syntax (MS, n*x) ?
	// * /
	public ExprStatementElements getExprStatementAccess() {
		return (pExprStatement != null) ? pExprStatement : (pExprStatement = new ExprStatementElements());
	}
	
	public ParserRule getExprStatementRule() {
		return getExprStatementAccess().getRule();
	}

	//Path returns ecore::EString hidden ( ):
	//  STRING|"/"? QualifiedName ("/" QualifiedName)* "/"?; 
	//
	/// *
	// * A path can be written without quotes if it consists of safe chars 
	// * TODO: repace use of ID with better definition.
	// * TODO: Validation of path syntax (MS, n*x) ?
	// * /
	//  
	//	  
	//	            // HIDDENBUG
	//	 
	//
	////Group returns GroupPart 
	////	: (visibility = Visibility)?
	////	  (executionMode = ExecutionMode)?
	////	  'group' name=PartName
	////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
	////		(asserts += PreConditionAssert)?
	////		(asserts += PostConditionAssert)?
	////		'{' ( prerequisites += Prerequisite )*
	////		'}'
	////	;
	public PathElements getPathAccess() {
		return (pPath != null) ? pPath : (pPath = new PathElements());
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}

	//Prerequisite:
	//  (surpressed?="hidden"? ("when" filter=Filter)? (alias=ID "=")? (partReference=
	//  PrerequisiteEntry closure=Closure?)) ";"; 
	//
	////Group returns GroupPart 
	////	: (visibility = Visibility)?
	////	  (executionMode = ExecutionMode)?
	////	  'group' name=PartName
	////		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
	////		(asserts += PreConditionAssert)?
	////		(asserts += PostConditionAssert)?
	////		'{' ( prerequisites += Prerequisite )*
	////		'}'
	////	;
	//
	//
	//	                   
	//	       / *| (partReference=ExprStatement) * /
	public PrerequisiteElements getPrerequisiteAccess() {
		return (pPrerequisite != null) ? pPrerequisite : (pPrerequisite = new PrerequisiteElements());
	}
	
	public ParserRule getPrerequisiteRule() {
		return getPrerequisiteAccess().getRule();
	}

	//Closure:
	//  "with" "{" ("properties" "{" ("unset" unsetProperties+=PropertyName ";"|setProperties
	//  +=PropertyStatement)+ "}"|"advice" advice+=CompoundAdvice)* "}";
	public ClosureElements getClosureAccess() {
		return (pClosure != null) ? pClosure : (pClosure = new ClosureElements());
	}
	
	public ParserRule getClosureRule() {
		return getClosureAccess().getRule();
	}

	//PrerequisiteEntry:
	//  PartInSelf|CapabilityReferencedPart|CompoundReferences|ExprStatement;
	public PrerequisiteEntryElements getPrerequisiteEntryAccess() {
		return (pPrerequisiteEntry != null) ? pPrerequisiteEntry : (pPrerequisiteEntry = new PrerequisiteEntryElements());
	}
	
	public ParserRule getPrerequisiteEntryRule() {
		return getPrerequisiteEntryAccess().getRule();
	}

	//PartInSelf:
	//  partName=PartName; 
	//	
	//	      // i.e. self#partName
	public PartInSelfElements getPartInSelfAccess() {
		return (pPartInSelf != null) ? pPartInSelf : (pPartInSelf = new PartInSelfElements());
	}
	
	public ParserRule getPartInSelfRule() {
		return getPartInSelfAccess().getRule();
	}

	//CapabilityReferencedPart:
	//  interface=InterfaceName "/" name=UnitName ("/" range=VersionRange)? "#" partName=
	//  PartName|interface=InterfaceName "/" name=UnitName ("/" range=VersionRange)?;
	public CapabilityReferencedPartElements getCapabilityReferencedPartAccess() {
		return (pCapabilityReferencedPart != null) ? pCapabilityReferencedPart : (pCapabilityReferencedPart = new CapabilityReferencedPartElements());
	}
	
	public ParserRule getCapabilityReferencedPartRule() {
		return getCapabilityReferencedPartAccess().getRule();
	}

	//CompoundReferences:
	//  "{" prerequisites+=Prerequisite* "}";
	public CompoundReferencesElements getCompoundReferencesAccess() {
		return (pCompoundReferences != null) ? pCompoundReferences : (pCompoundReferences = new CompoundReferencesElements());
	}
	
	public ParserRule getCompoundReferencesRule() {
		return getCompoundReferencesAccess().getRule();
	}

	//Part:
	//  visibility=Visibility? executionMode=ExecutionMode? PartName ("provides"
	//  providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
	//  ProvidedCapability)*)? asserts+=PreConditionAssert? asserts+=PostConditionAssert?
	//  "{" ("properties" properties+=PropertyStatements)? advice=Advice? resultGroup=
	//  ActionInputGroup? layout+=Layout* statements=Statements "}"; 
	//          
	//          
	//	 / *'part'* /   
	////	 'actor' QualifiedName '(' (actorParameters += Parameter (',' actorParameters += Parameter)*)? ')'
	public PartElements getPartAccess() {
		return (pPart != null) ? pPart : (pPart = new PartElements());
	}
	
	public ParserRule getPartRule() {
		return getPartAccess().getRule();
	}

	//Parameter:
	//  val=Expression;
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//Layout:
	//  ("when" filter=Filter)? "layout" name=QualifiedName? asserts+=PostConditionAssert?
	//  "{" paths+=PathGroup* "}"; 
	//	
	//    
	//	            
	////		(asserts += PreConditionAssert)? // precondition does not make sense
	public LayoutElements getLayoutAccess() {
		return (pLayout != null) ? pLayout : (pLayout = new LayoutElements());
	}
	
	public ParserRule getLayoutRule() {
		return getLayoutAccess().getRule();
	}

	//ActionInputGroup:
	//  "group" asserts+=PreConditionAssert? asserts+=PostConditionAssert? "{" prerequisites
	//  +=Prerequisite* "}";
	public ActionInputGroupElements getActionInputGroupAccess() {
		return (pActionInputGroup != null) ? pActionInputGroup : (pActionInputGroup = new ActionInputGroupElements());
	}
	
	public ParserRule getActionInputGroupRule() {
		return getActionInputGroupAccess().getRule();
	}

	//RepositoryConfiguration:
	//  (location=URI|"resolver" resolverClass=QualifiedName) advice=CompoundAdvice? ";"; 
	//
	//
	//	              
	//	
	//
	/// *
	// ** URI TODO: Would like to have better parsing of URL - don't know if possible to push this to lexer
	// ** as we may want to support namespaces (using 'ns:' prefix) (for importing b3 files, common advice, rules etc.).
	// ** The ':' clashes with 'scheme:' which is the only known part in an opaque URI. 
	// * /
	public RepositoryConfigurationElements getRepositoryConfigurationAccess() {
		return (pRepositoryConfiguration != null) ? pRepositoryConfiguration : (pRepositoryConfiguration = new RepositoryConfigurationElements());
	}
	
	public ParserRule getRepositoryConfigurationRule() {
		return getRepositoryConfigurationAccess().getRule();
	}

	//URI returns ecore::EString:
	//  STRING; 
	//
	/// *
	// ** URI TODO: Would like to have better parsing of URL - don't know if possible to push this to lexer
	// ** as we may want to support namespaces (using 'ns:' prefix) (for importing b3 files, common advice, rules etc.).
	// ** The ':' clashes with 'scheme:' which is the only known part in an opaque URI. 
	// * /
	//    
	//	
	//
	/// * ADVICE
	// ** TODO: Had to use '?' instead if '*', and '??' intead of '**' as these operators are intermixed with / which sometimes
	// ** makes them look like comments. (Forbidding // comments is not the wanted sollution). 
	// **
	// * /
	public URIElements getURIAccess() {
		return (pURI != null) ? pURI : (pURI = new URIElements());
	}
	
	public ParserRule getURIRule() {
		return getURIAccess().getRule();
	}

	//NamedAdvice:
	//  name=ID? advice=CompoundAdvice; 
	//
	/// * ADVICE
	// ** TODO: Had to use '?' instead if '*', and '??' intead of '**' as these operators are intermixed with / which sometimes
	// ** makes them look like comments. (Forbidding // comments is not the wanted sollution). 
	// **
	// * /
	public NamedAdviceElements getNamedAdviceAccess() {
		return (pNamedAdvice != null) ? pNamedAdvice : (pNamedAdvice = new NamedAdviceElements());
	}
	
	public ParserRule getNamedAdviceRule() {
		return getNamedAdviceAccess().getRule();
	}

	//Advice:
	//  "advice" CompoundAdvice;
	public AdviceElements getAdviceAccess() {
		return (pAdvice != null) ? pAdvice : (pAdvice = new AdviceElements());
	}
	
	public ParserRule getAdviceRule() {
		return getAdviceAccess().getRule();
	}

	//CompoundAdvice:
	//  "{" (advice+=AdviceStatement ";")* "}";
	public CompoundAdviceElements getCompoundAdviceAccess() {
		return (pCompoundAdvice != null) ? pCompoundAdvice : (pCompoundAdvice = new CompoundAdviceElements());
	}
	
	public ParserRule getCompoundAdviceRule() {
		return getCompoundAdviceAccess().getRule();
	}

	//AdviceStatement:
	//  path=AdvicePath ("=" value=Expression|advice=CompoundAdvice);
	public AdviceStatementElements getAdviceStatementAccess() {
		return (pAdviceStatement != null) ? pAdviceStatement : (pAdviceStatement = new AdviceStatementElements());
	}
	
	public ParserRule getAdviceStatementRule() {
		return getAdviceStatementAccess().getRule();
	}

	//AdvicePath:
	//  pathElements+=AdvicePathSeparator? pathElements+=AdvicePathElement (pathElements+=
	//  AdvicePathSeparator pathElement+=AdvicePathElement)*;
	public AdvicePathElements getAdvicePathAccess() {
		return (pAdvicePath != null) ? pAdvicePath : (pAdvicePath = new AdvicePathElements());
	}
	
	public ParserRule getAdvicePathRule() {
		return getAdvicePathAccess().getRule();
	}

	//AdvicePathSeparator returns AdvicePathElement:
	//  AdvicePathChildren;
	public AdvicePathSeparatorElements getAdvicePathSeparatorAccess() {
		return (pAdvicePathSeparator != null) ? pAdvicePathSeparator : (pAdvicePathSeparator = new AdvicePathSeparatorElements());
	}
	
	public ParserRule getAdvicePathSeparatorRule() {
		return getAdvicePathSeparatorAccess().getRule();
	}

	//AdvicePathChildren:
	//  {AdvicePathChildren} "/";
	public AdvicePathChildrenElements getAdvicePathChildrenAccess() {
		return (pAdvicePathChildren != null) ? pAdvicePathChildren : (pAdvicePathChildren = new AdvicePathChildrenElements());
	}
	
	public ParserRule getAdvicePathChildrenRule() {
		return getAdvicePathChildrenAccess().getRule();
	}

	//AdvicePathElement:
	//  node=( QualifiedName | WildcardNode | "." ) ("[" predicate=Expression "]")?|node="..";
	public AdvicePathElementElements getAdvicePathElementAccess() {
		return (pAdvicePathElement != null) ? pAdvicePathElement : (pAdvicePathElement = new AdvicePathElementElements());
	}
	
	public ParserRule getAdvicePathElementRule() {
		return getAdvicePathElementAccess().getRule();
	}

	//WildcardNode returns ecore::EString:
	//  "?" "?"?;
	public WildcardNodeElements getWildcardNodeAccess() {
		return (pWildcardNode != null) ? pWildcardNode : (pWildcardNode = new WildcardNodeElements());
	}
	
	public ParserRule getWildcardNodeRule() {
		return getWildcardNodeAccess().getRule();
	}

	//Filter:
	//  "(" predicate=Expression ")"; 
	//
	//              
	//
	/// * ASSERTS * /
	public FilterElements getFilterAccess() {
		return (pFilter != null) ? pFilter : (pFilter = new FilterElements());
	}
	
	public ParserRule getFilterRule() {
		return getFilterAccess().getRule();
	}

	//PreConditionAssert:
	//  scope="precondition" "{" asserts+=AssertionExpression* "}"; 
	//
	/// * ASSERTS * /
	public PreConditionAssertElements getPreConditionAssertAccess() {
		return (pPreConditionAssert != null) ? pPreConditionAssert : (pPreConditionAssert = new PreConditionAssertElements());
	}
	
	public ParserRule getPreConditionAssertRule() {
		return getPreConditionAssertAccess().getRule();
	}

	//PostConditionAssert:
	//  scope="postcondition" "{" asserts+=AssertionExpression* "}";
	public PostConditionAssertElements getPostConditionAssertAccess() {
		return (pPostConditionAssert != null) ? pPostConditionAssert : (pPostConditionAssert = new PostConditionAssertElements());
	}
	
	public ParserRule getPostConditionAssertRule() {
		return getPostConditionAssertAccess().getRule();
	}

	//AssertionExpression:
	//  "assert" expr=Expression ("," message=STRING)? ";"; 
	//
	//             
	//
	//
	/// * STATEMENTS * /
	public AssertionExpressionElements getAssertionExpressionAccess() {
		return (pAssertionExpression != null) ? pAssertionExpression : (pAssertionExpression = new AssertionExpressionElements());
	}
	
	public ParserRule getAssertionExpressionRule() {
		return getAssertionExpressionAccess().getRule();
	}

	//Statement:
	//  IfStatement|SwitchStatement|WhileStatement|ForStatement|DoWhileStatement|
	//  CompoundStatement|VarExpression? ";"|BreakStatement|ContinueStatement|
	//  ReturnStatement|FunctionStatement|LabelStatement|ThrowStatement|
	//  TryCatchStatement|WithStatement; 
	//
	/// * STATEMENTS * /
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//BreakStatement:
	//  {BreakStatement} "break" label=ID? ";";
	public BreakStatementElements getBreakStatementAccess() {
		return (pBreakStatement != null) ? pBreakStatement : (pBreakStatement = new BreakStatementElements());
	}
	
	public ParserRule getBreakStatementRule() {
		return getBreakStatementAccess().getRule();
	}

	//ContinueStatement:
	//  {ContinueStatement} "continue" label=ID? ";";
	public ContinueStatementElements getContinueStatementAccess() {
		return (pContinueStatement != null) ? pContinueStatement : (pContinueStatement = new ContinueStatementElements());
	}
	
	public ParserRule getContinueStatementRule() {
		return getContinueStatementAccess().getRule();
	}

	//CompoundStatement:
	//  "{" statements=Statements "}";
	public CompoundStatementElements getCompoundStatementAccess() {
		return (pCompoundStatement != null) ? pCompoundStatement : (pCompoundStatement = new CompoundStatementElements());
	}
	
	public ParserRule getCompoundStatementRule() {
		return getCompoundStatementAccess().getRule();
	}

	//Statements:
	//  statements+=Statement+;
	public StatementsElements getStatementsAccess() {
		return (pStatements != null) ? pStatements : (pStatements = new StatementsElements());
	}
	
	public ParserRule getStatementsRule() {
		return getStatementsAccess().getRule();
	}

	//WhileStatement:
	//  "while" "(" condition=Expression ")" body=Statement;
	public WhileStatementElements getWhileStatementAccess() {
		return (pWhileStatement != null) ? pWhileStatement : (pWhileStatement = new WhileStatementElements());
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}

	//SwitchStatement:
	//  "switch" "(" switchExpr=VarExpression ")" "{" case+=Case* ("default" ":" statements=
	//  Statements?)? "}";
	public SwitchStatementElements getSwitchStatementAccess() {
		return (pSwitchStatement != null) ? pSwitchStatement : (pSwitchStatement = new SwitchStatementElements());
	}
	
	public ParserRule getSwitchStatementRule() {
		return getSwitchStatementAccess().getRule();
	}

	//Case:
	//  "case" condition=ValueLiteral ":" statements=Statements?; 
	//		
	//        
	//
	//// TODO: needs validation that expression list only has one entry and is a LHS value
	//// if inLoop == true. Needs validation that RHS is a collection item if inLoop == true.
	////
	public CaseElements getCaseAccess() {
		return (pCase != null) ? pCase : (pCase = new CaseElements());
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}

	//ForStatement:
	//  {ForStatement} "for" "(" init=VarExpressionList? (";" cond=Expression? ";" iterate=
	//  ExpressionList?|inLoop?="in" iterate=Expression) ")" body=Statement; 
	//
	//// TODO: needs validation that expression list only has one entry and is a LHS value
	//// if inLoop == true. Needs validation that RHS is a collection item if inLoop == true.
	////
	public ForStatementElements getForStatementAccess() {
		return (pForStatement != null) ? pForStatement : (pForStatement = new ForStatementElements());
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}

	//DoWhileStatement:
	//  "do" statement=Statement "while" "(" condition=Expression ")" ";";
	public DoWhileStatementElements getDoWhileStatementAccess() {
		return (pDoWhileStatement != null) ? pDoWhileStatement : (pDoWhileStatement = new DoWhileStatementElements());
	}
	
	public ParserRule getDoWhileStatementRule() {
		return getDoWhileStatementAccess().getRule();
	}

	//ReturnStatement:
	//  "return" return=Expression ";";
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//FunctionStatement:
	//  "function" name=ID "(" (params+=ID ("," params+=ID)*) ")" "{" statements=Statements "}";
	public FunctionStatementElements getFunctionStatementAccess() {
		return (pFunctionStatement != null) ? pFunctionStatement : (pFunctionStatement = new FunctionStatementElements());
	}
	
	public ParserRule getFunctionStatementRule() {
		return getFunctionStatementAccess().getRule();
	}

	//IfStatement:
	//  "if" "(" cond=Expression ")" then=Statement ("else" else=Statement)?;
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//LabelStatement:
	//  "@" name=ID ":" statement=Statement;
	public LabelStatementElements getLabelStatementAccess() {
		return (pLabelStatement != null) ? pLabelStatement : (pLabelStatement = new LabelStatementElements());
	}
	
	public ParserRule getLabelStatementRule() {
		return getLabelStatementAccess().getRule();
	}

	//ThrowStatement:
	//  "throw" expr=Expression ";";
	public ThrowStatementElements getThrowStatementAccess() {
		return (pThrowStatement != null) ? pThrowStatement : (pThrowStatement = new ThrowStatementElements());
	}
	
	public ParserRule getThrowStatementRule() {
		return getThrowStatementAccess().getRule();
	}

	//TryCatchStatement:
	//  "try" tryBlock=CompoundStatement (catchBlock=CatchBlock finallyBlock=FinallyBlock?|
	//  finally=FinallyBlock);
	public TryCatchStatementElements getTryCatchStatementAccess() {
		return (pTryCatchStatement != null) ? pTryCatchStatement : (pTryCatchStatement = new TryCatchStatementElements());
	}
	
	public ParserRule getTryCatchStatementRule() {
		return getTryCatchStatementAccess().getRule();
	}

	//CatchBlock:
	//  "catch" "(" variable=ID ")" catchBlock=CompoundStatement;
	public CatchBlockElements getCatchBlockAccess() {
		return (pCatchBlock != null) ? pCatchBlock : (pCatchBlock = new CatchBlockElements());
	}
	
	public ParserRule getCatchBlockRule() {
		return getCatchBlockAccess().getRule();
	}

	//FinallyBlock:
	//  "finally" finallyBlock=CompoundStatement;
	public FinallyBlockElements getFinallyBlockAccess() {
		return (pFinallyBlock != null) ? pFinallyBlock : (pFinallyBlock = new FinallyBlockElements());
	}
	
	public ParserRule getFinallyBlockRule() {
		return getFinallyBlockAccess().getRule();
	}

	//WithStatement:
	//  "with" "(" expr=Expression ")" statement=Statement; 
	//		
	//                
	//		
	/// * EXPRESSIONS * /
	public WithStatementElements getWithStatementAccess() {
		return (pWithStatement != null) ? pWithStatement : (pWithStatement = new WithStatementElements());
	}
	
	public ParserRule getWithStatementRule() {
		return getWithStatementAccess().getRule();
	}

	//SyntaxElement:
	//  Expression; 
	//		
	/// * EXPRESSIONS * /
	public SyntaxElementElements getSyntaxElementAccess() {
		return (pSyntaxElement != null) ? pSyntaxElement : (pSyntaxElement = new SyntaxElementElements());
	}
	
	public ParserRule getSyntaxElementRule() {
		return getSyntaxElementAccess().getRule();
	}

	//VarExpressionList:
	//  expr+=VarExpression ("," expr+=VarExpression)*;
	public VarExpressionListElements getVarExpressionListAccess() {
		return (pVarExpressionList != null) ? pVarExpressionList : (pVarExpressionList = new VarExpressionListElements());
	}
	
	public ParserRule getVarExpressionListRule() {
		return getVarExpressionListAccess().getRule();
	}

	//ExpressionList returns Expression:
	//  expr+=Expression ("," expr+=Expression)*; 
	//                    
	//
	//// Assignment is optional i JS
	//// Also makes it possible to use VarExpression in a for(var a in xxx) loop
	////
	public ExpressionListElements getExpressionListAccess() {
		return (pExpressionList != null) ? pExpressionList : (pExpressionList = new ExpressionListElements());
	}
	
	public ParserRule getExpressionListRule() {
		return getExpressionListAccess().getRule();
	}

	//VarExpression:
	//  Expression|"var" name=ID ("=" value=Expression)?; 
	//
	//// Assignment is optional i JS
	//// Also makes it possible to use VarExpression in a for(var a in xxx) loop
	////
	public VarExpressionElements getVarExpressionAccess() {
		return (pVarExpression != null) ? pVarExpression : (pVarExpression = new VarExpressionElements());
	}
	
	public ParserRule getVarExpressionRule() {
		return getVarExpressionAccess().getRule();
	}

	//Expression:
	//  ValueExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//ValueExpression:
	//  value=AssignmentExpression; 
	//
	// 
	//	  
	//	
	//
	////TODO: This is left associative, should be right...
	////AssignmentExpression returns Expression:
	////	 ChainExpression ({AssignmentOperation.left+=current} op=("=" | "+=" | "-=" | "*=" | "/=" | "%=" )
	////		right+=ChainExpression)*
	////	;
	public ValueExpressionElements getValueExpressionAccess() {
		return (pValueExpression != null) ? pValueExpression : (pValueExpression = new ValueExpressionElements());
	}
	
	public ParserRule getValueExpressionRule() {
		return getValueExpressionAccess().getRule();
	}

	//AssignmentExpression returns Expression:
	//  ChainExpression ({AssignmentOperation.left=current} op=( "=" | "+=" | "-=" | "*=" | "/=" |
	//  "%=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" ) right=AssignmentExpression)?; 
	//
	////TODO: This is left associative, should be right...
	////AssignmentExpression returns Expression:
	////	 ChainExpression ({AssignmentOperation.left+=current} op=("=" | "+=" | "-=" | "*=" | "/=" | "%=" )
	////		right+=ChainExpression)*
	////	;
	public AssignmentExpressionElements getAssignmentExpressionAccess() {
		return (pAssignmentExpression != null) ? pAssignmentExpression : (pAssignmentExpression = new AssignmentExpressionElements());
	}
	
	public ParserRule getAssignmentExpressionRule() {
		return getAssignmentExpressionAccess().getRule();
	}

	//ChainExpression returns Expression:
	//  ChainedExpression; 
	//
	//
	//    
	//	  //({ChainExpression.first=current} ',' next=ChainedExpression)*
	public ChainExpressionElements getChainExpressionAccess() {
		return (pChainExpression != null) ? pChainExpression : (pChainExpression = new ChainExpressionElements());
	}
	
	public ParserRule getChainExpressionRule() {
		return getChainExpressionAccess().getRule();
	}

	//ChainedExpression returns Expression:
	//  IfExpression;
	public ChainedExpressionElements getChainedExpressionAccess() {
		return (pChainedExpression != null) ? pChainedExpression : (pChainedExpression = new ChainedExpressionElements());
	}
	
	public ParserRule getChainedExpressionRule() {
		return getChainedExpressionAccess().getRule();
	}

	//IfExpression returns Expression:
	//  OrExpression ({IfExpression.condition=current} "?" thenPart=ChainedExpression ":"
	//  elsePart=ChainedExpression)?;
	public IfExpressionElements getIfExpressionAccess() {
		return (pIfExpression != null) ? pIfExpression : (pIfExpression = new IfExpressionElements());
	}
	
	public ParserRule getIfExpressionRule() {
		return getIfExpressionAccess().getRule();
	}

	//OrExpression returns Expression:
	//  AndExpression ({BooleanOperation.left=current} operator="||" right=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//AndExpression returns Expression:
	//  BitwiseExpression ({BooleanOperation.left=current} operator="&&" right=
	//  BitwiseExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//BitwiseExpression returns Expression:
	//  RelationalExpression ({OperationCall.left=current} operator=( "&" | "^" | "|" ) right=
	//  RelationalExpression)*;
	public BitwiseExpressionElements getBitwiseExpressionAccess() {
		return (pBitwiseExpression != null) ? pBitwiseExpression : (pBitwiseExpression = new BitwiseExpressionElements());
	}
	
	public ParserRule getBitwiseExpressionRule() {
		return getBitwiseExpressionAccess().getRule();
	}

	//RelationalExpression returns Expression:
	//  AdditiveExpression ({BooleanOperation.left=current} operator=( "~=" | "==" | "===" | "!="
	//  | "!==" | ">=" | "<=" | ">" | "<" | "==." | "instanceof" ) right=AdditiveExpression)*;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	//AdditiveExpression returns Expression:
	//  MultiplicativeExpression ({OperationCall.params+=current} name=( "+" | "-" ) params+=
	//  MultiplicativeExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	//MultiplicativeExpression returns Expression:
	//  UnaryOrInfixExpression ({OperationCall.params+=current} name=( "*" | "/" | "%" ) params+=
	//  UnaryOrInfixExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return (pMultiplicativeExpression != null) ? pMultiplicativeExpression : (pMultiplicativeExpression = new MultiplicativeExpressionElements());
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	//UnaryOrInfixExpression returns Expression:
	//  UnaryExpression|PostopExpression;
	public UnaryOrInfixExpressionElements getUnaryOrInfixExpressionAccess() {
		return (pUnaryOrInfixExpression != null) ? pUnaryOrInfixExpression : (pUnaryOrInfixExpression = new UnaryOrInfixExpressionElements());
	}
	
	public ParserRule getUnaryOrInfixExpressionRule() {
		return getUnaryOrInfixExpressionAccess().getRule();
	}

	//UnaryExpression returns OperationCall:
	//  name=( "!" | "-" | "++" | "--" | "typeof" | "delete" | "~" ) params+=PostopExpression;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//PostopExpression returns Expression:
	//  InfixExpression ({PostOpCall.target=current} name=( "--" | "++" ))?;
	public PostopExpressionElements getPostopExpressionAccess() {
		return (pPostopExpression != null) ? pPostopExpression : (pPostopExpression = new PostopExpressionElements());
	}
	
	public ParserRule getPostopExpressionRule() {
		return getPostopExpressionAccess().getRule();
	}

	//InfixExpression returns Expression:
	//  CallExpression ({OperationCall.target=current} "." name=ID "(" (params+=Parameter (","
	//  params+=Parameter)*)? ")"|{AtCall.target=current} "[" index=Expression "]" ("(" (
	//  params+=Parameter ("," params+=Parameter)*)? ")")?|{FeatureCall.target=current} "."
	//  type=ID)*;
	public InfixExpressionElements getInfixExpressionAccess() {
		return (pInfixExpression != null) ? pInfixExpression : (pInfixExpression = new InfixExpressionElements());
	}
	
	public ParserRule getInfixExpressionRule() {
		return getInfixExpressionAccess().getRule();
	}

	//CallExpression returns Expression:
	//  PrimaryExpression ({OperationCall.target=current} "(" (params+=Parameter ("," params
	//  +=Parameter)*)? ")")*;
	public CallExpressionElements getCallExpressionAccess() {
		return (pCallExpression != null) ? pCallExpression : (pCallExpression = new CallExpressionElements());
	}
	
	public ParserRule getCallExpressionRule() {
		return getCallExpressionAccess().getRule();
	}

	//PrimaryExpression returns Expression:
	//  Literal|ConstructorCallExpression|VariableValue|PropertyValue|KeywordVariables|
	//  ParanthesizedExpression; 
	//		
	//    
	//	   
	////	| FeatureCall
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//PropertyValue:
	//  name=PID;
	public PropertyValueElements getPropertyValueAccess() {
		return (pPropertyValue != null) ? pPropertyValue : (pPropertyValue = new PropertyValueElements());
	}
	
	public ParserRule getPropertyValueRule() {
		return getPropertyValueAccess().getRule();
	}

	//VariableValue:
	//  name=ID;
	public VariableValueElements getVariableValueAccess() {
		return (pVariableValue != null) ? pVariableValue : (pVariableValue = new VariableValueElements());
	}
	
	public ParserRule getVariableValueRule() {
		return getVariableValueAccess().getRule();
	}

	//KeywordVariables:
	//  name=( "group" | "layout" | "properties" ); 
	//                  
	//
	////FeatureCall:
	////	OperationCall
	////	;
	////	
	////OperationCall 
	////	: name=(ID|PID) "(" (params+=Parameter ("," params+=Parameter)*)? ")" 
	////	;
	public KeywordVariablesElements getKeywordVariablesAccess() {
		return (pKeywordVariables != null) ? pKeywordVariables : (pKeywordVariables = new KeywordVariablesElements());
	}
	
	public ParserRule getKeywordVariablesRule() {
		return getKeywordVariablesAccess().getRule();
	}

	//ConstructorCallExpression:
	//  "new" class=QualifiedName "(" (params+=Parameter ("," params+=Parameter)*)? ")"; 
	//
	////FeatureCall:
	////	OperationCall
	////	;
	////	
	////OperationCall 
	////	: name=(ID|PID) "(" (params+=Parameter ("," params+=Parameter)*)? ")" 
	////	;
	public ConstructorCallExpressionElements getConstructorCallExpressionAccess() {
		return (pConstructorCallExpression != null) ? pConstructorCallExpression : (pConstructorCallExpression = new ConstructorCallExpressionElements());
	}
	
	public ParserRule getConstructorCallExpressionRule() {
		return getConstructorCallExpressionAccess().getRule();
	}

	//Literal:
	//  ValueLiteral|RegexpLiteral|LiteralArray|LiteralObject|LiteralFunction;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//LiteralArray:
	//  "[" (element+=Expression ("," element+=Expression)*)? "]";
	public LiteralArrayElements getLiteralArrayAccess() {
		return (pLiteralArray != null) ? pLiteralArray : (pLiteralArray = new LiteralArrayElements());
	}
	
	public ParserRule getLiteralArrayRule() {
		return getLiteralArrayAccess().getRule();
	}

	//LiteralObject:
	//  "{" (features+=Feature ("," features+=Feature)*)? "}";
	public LiteralObjectElements getLiteralObjectAccess() {
		return (pLiteralObject != null) ? pLiteralObject : (pLiteralObject = new LiteralObjectElements());
	}
	
	public ParserRule getLiteralObjectRule() {
		return getLiteralObjectAccess().getRule();
	}

	//LiteralFunction:
	//  "function" "(" (params+=ID ("," params+=ID)*) ")" "{" statements=Statements "}";
	public LiteralFunctionElements getLiteralFunctionAccess() {
		return (pLiteralFunction != null) ? pLiteralFunction : (pLiteralFunction = new LiteralFunctionElements());
	}
	
	public ParserRule getLiteralFunctionRule() {
		return getLiteralFunctionAccess().getRule();
	}

	//Feature:
	//  name=( ID | PID | STRING ) ":" value=Expression;
	public FeatureElements getFeatureAccess() {
		return (pFeature != null) ? pFeature : (pFeature = new FeatureElements());
	}
	
	public ParserRule getFeatureRule() {
		return getFeatureAccess().getRule();
	}

	//ValueLiteral:
	//  BooleanLiteral|IntegerLiteral|NullLiteral|VoidLiteral|StringLiteral|RealLiteral; 
	//
	//
	//	   
	//	   
	//	        // null == defined but null, void is undefined
	public ValueLiteralElements getValueLiteralAccess() {
		return (pValueLiteral != null) ? pValueLiteral : (pValueLiteral = new ValueLiteralElements());
	}
	
	public ParserRule getValueLiteralRule() {
		return getValueLiteralAccess().getRule();
	}

	//BooleanLiteral:
	//  val=( "true" | "false" );
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//IntegerLiteral:
	//  val=INT|HEX;
	public IntegerLiteralElements getIntegerLiteralAccess() {
		return (pIntegerLiteral != null) ? pIntegerLiteral : (pIntegerLiteral = new IntegerLiteralElements());
	}
	
	public ParserRule getIntegerLiteralRule() {
		return getIntegerLiteralAccess().getRule();
	}

	//NullLiteral:
	//  val="null";
	public NullLiteralElements getNullLiteralAccess() {
		return (pNullLiteral != null) ? pNullLiteral : (pNullLiteral = new NullLiteralElements());
	}
	
	public ParserRule getNullLiteralRule() {
		return getNullLiteralAccess().getRule();
	}

	//VoidLiteral:
	//  val="void";
	public VoidLiteralElements getVoidLiteralAccess() {
		return (pVoidLiteral != null) ? pVoidLiteral : (pVoidLiteral = new VoidLiteralElements());
	}
	
	public ParserRule getVoidLiteralRule() {
		return getVoidLiteralAccess().getRule();
	}

	//StringLiteral:
	//  val=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return (pStringLiteral != null) ? pStringLiteral : (pStringLiteral = new StringLiteralElements());
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//RealLiteral:
	//  val=REAL;
	public RealLiteralElements getRealLiteralAccess() {
		return (pRealLiteral != null) ? pRealLiteral : (pRealLiteral = new RealLiteralElements());
	}
	
	public ParserRule getRealLiteralRule() {
		return getRealLiteralAccess().getRule();
	}

	//RegexpLiteral:
	//  val=REGEX;
	public RegexpLiteralElements getRegexpLiteralAccess() {
		return (pRegexpLiteral != null) ? pRegexpLiteral : (pRegexpLiteral = new RegexpLiteralElements());
	}
	
	public ParserRule getRegexpLiteralRule() {
		return getRegexpLiteralAccess().getRule();
	}

	//ParanthesizedExpression returns Expression:
	//  "(" Expression ")";
	public ParanthesizedExpressionElements getParanthesizedExpressionAccess() {
		return (pParanthesizedExpression != null) ? pParanthesizedExpression : (pParanthesizedExpression = new ParanthesizedExpressionElements());
	}
	
	public ParserRule getParanthesizedExpressionRule() {
		return getParanthesizedExpressionAccess().getRule();
	}
}
