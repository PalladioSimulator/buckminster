grammar org.eclipse.b3.BeeLang with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate beeLang "http://www.eclipse.org/b3/BeeLang"
BeeModel : (imports += Import)* body = Unit ;

// Redeclare the default ID without the ^ keyword escape mechanism, and including
// the JS $ char which is allowed in the first position.
//
terminal ID : (('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|('0'..'9')|'_')* ;

// Property Names start with $ and are qualified. Must be handled by lexer as
// a.b.c is otherwise ambigous in expressions.

terminal PID : '$' ID ('.' ID)* ;

// JS Regexp - but cheating by using @ instead of / because of inability to push back terminators
// and / clashes with / in math.
//
terminal REGEX 
	: "~/" ( '\\' ('/'|'f'|'n'|'r'|'t'|'v'|'\\'|'.'|'*'|'+'|'?'
					| 'w'|'W'|'s'|'S'|'d'|'D'|'b'
					|'|'|'{'|'}'|'['|']'|'('|')'
					| (('0'..'7')('0'..'7')('0'..'7')) 
					| ('x' (('0'..'9')|('a'..'f')|('A'..'F')) (('0'..'9')|('a'..'f')|('A'..'F'))) 
					| ('c' ('A'..'Z'))
				)
			| (!('\\'|'/'|' '|'\t'|'\r'|'\n')))* "/" ('g'|'m'|'i')?
			;

// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
// A string converter may need to handle the u, x, and octal escapes.
// Regular java string handles XXXX , and gives syntax error if
// format is not ok, the other two remains, and possibly the null.
terminal STRING :
'"' ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|'"'|'\r'|'\n') )* '"' |
"'" ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|"'"|'\r'|'\n') )* "'";

terminal ML_COMMENT : '/*' -> '*/' ;
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS : (' '|'\t'|'\r'|'\n')+ ;

// TODO: Should return EInt, but std converter does not hand handles hex
//
terminal HEX : '0' ('x'|'X')(('0'..'9')|('a'..'f')|('A'..'F'))+ ;

// A JS integer is one of
// 0
// 0(0..7)*
// 0(x|X)(0-91-fA-F)*
// Validation can handle the octal case, and illegal 08, 09 00 sequencese
// TODO: converter must handle octal case if we want to support it.
//
terminal INT returns ecore::EInt: ('0'..'9')+;

// TODO: should be a floating point value and have a converter
// and check for illegal INT sequences "000" etc.
// Suppressing REAL without a decimal (INT '.') as well as ('.' INT) as
// a real otherwise can look as part of an Qualified name ('a'.e+1), the
// combination 'n.n' is not valid in a name.
//
terminal REAL : ((INT '.' INT)|(INT '.')|('.' INT) | INT) (('e'|'E')('-'|'+')INT)? ;


terminal ANY_OTHER : . ;

// Qualified name
// TODO: Needs to disallow whie space between ID and '.', and no embedded comments. A bug in xtext prevents using hidden() here.
//
QualifiedName hidden(): ID (INT|HEX|ID)* ('.' ID (INT|HEX|ID)*)* HIDDENBUG;
HIDDENBUG hidden(WS, SL_COMMENT, ML_COMMENT): ('~~~~~')? ; // TODO: REPLACE HACK WHEN HIDDEN WORKS.


// Declare Property ID to include '.'
PROP hidden(): '$' '{' QualifiedName '}' ;

PropertyName : PID ;
EscapedQualifiedName:  STRING | QualifiedName;
InterfaceName: QualifiedName ;

// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
// do not allow being broken across lines.
//
CompoundName : EscapedQualifiedName '/' EscapedQualifiedName ;

// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
UnitName : EscapedQualifiedName;
PartName : EscapedQualifiedName;

enum Visibility 	: public | private ;
enum ExecutionMode 	: parallel | sequential ;


// Version, and VersionRange
// TODO: make it into a datatype and have better rules, syntax coloring (now integer parts are colored grey, other parts are not colored), etc.
// TODO: uncertain if the set of allowed chars is definitive.
//
Separator : '.' | '-' | '!' | '@' | '$' | '%' | '&' |'+' | '=' | '*' | '<' | '>' | ':' | '?';
AlfanumSym : (ID | INT |HEX|REAL) (Separator|ID|INT|HEX|REAL)* ;

Version returns Version
	: original=STRING  
	| original=AlfanumSym
	;

/*
** VersionRange TODO: Uses two instances of Version. This works because use of [ ]  ( ) in Version must be 
** escaped with " ". Omni
** version uses version strings with \[ when a range is presented/parsed in string format.
*/
VersionRange returns VersionRange
	: minLimit=('[' | '(') min=Version (',' max=Version)? maxLimit=(']'|')')
	| min=Version
	;

/*
** Import
** TODO: Is specified as import of URI, a String, should be QID
*/	
Import :
	'import' importClass=QualifiedName ('.*')? ';' ; 
		
/* UNIT - the body (compare to java class)
*/	
Unit returns BuildUnit hidden(WS, ML_COMMENT, SL_COMMENT) :
	(executionMode = ExecutionMode)?
	'unit' (name=UnitName)? ('version' version = Version)?
		('implements' implements += InterfaceName (',' implements+=InterfaceName)*)? 
	'{'
		(	//-- PROPERTIES
			// goes first, because they may be used in the other clauses.
			//
			  ('properties'  CompoundPropertyOperation += NamedPropertyStatements)
		)*
		( 	//-- PROVIDES
			  ('provides' '{' (providedCapabilities += ProvidedCapability ';')+ '}')
			| ('provides' providedCapabilities += ProvidedCapability ';')
			//-- REQUIRES & META REQUIRES
			| ('requires' '{' (requiredCapabilities += RequiredCapability ';')+ '}')
			| ('requires' requiredCapabilities += RequiredCapability ';')
			| ('meta' 'requires' '{' (metaRequiredCapabilities += RequiredCapability ';')+ '}' )
			| ('meta' 'requires' metaRequiredCapabilities += RequiredCapability ';')
			//--ADVICE
			| ('advice' advice+=NamedAdvice )
			//--SYNCHRONIZE
			| ('sequential' '{' (synchronizations += Synchronization )+  '}' )
			| ('sequential' synchronizations += Synchronization  )
			//--PARTS
			| (parts += Part )			
			//-- REPOSITORIES
			| ('repositories' '{' (repositoryConfigurations+=RepositoryConfiguration)* '}' )
		)*
	'}';
	

	
ProvidedCapability : ('when' filter=Filter)? interface=QualifiedName '/' name=QualifiedName  ('/' version=Version)?  ;
RequiredCapability : ('when' filter=Filter)? interface=QualifiedName '/' name=QualifiedName ('/' range=VersionRange)?  ;

// An optionally named sequence of property statements
NamedPropertyStatements returns NamedProperties
	: (name = ID)? body = CompoundPropertyOperation 
	;

// Sequence of possibly filtered property statements	
CompoundPropertyOperation returns CompoundPropertyOperation
	:  '{' (operations += PropertyOperation)* '}'
	;

// For model generation, to get supertype correct
PropertyOperation 
	: FilteredPropertyOperation 
	| SetPropertyOperation 
	| UnsetPropertyOperation 
	| CompoundPropertyOperation
	;

FilteredPropertyOperation returns FilteredPropertyOperation
	: 'when' filter=Filter
		body=(SetPropertyOperation | UnsetPropertyOperation | CompoundPropertyOperation) 
	;

SetPropertyOperation returns SetPropertyOperation
	: ( (immutable ?= 'immutable')? key=PropertyName op=AssignmentOperator value=Expression ';')
	;

UnsetPropertyOperation returns UnsetPropertyOperation
	: ('unset' key = PropertyName ';' )
	;

Synchronization 
	: (partrefs += SynchronizedPart)(',' partrefs += SynchronizedPart)+ ';' // at least 2
	;
	
SynchronizedPart
	: CompoundName ('#' PartName)?
	| PartName
	;
	
/* PATH GROUP */
PathGroup : paths+=PathVectorElement* ('annotations' annotations = CompoundPropertyOperation)? ;

PathVectorElement returns PathVectorElement
	: FilteredPathVector
	| BasePathVector
	| UnbasedPathVector
	;
	
FilteredPathVector returns FilteredPathVector 
	: 'when' filter=Filter body=(BasePathVector|UnbasedPathVector|CompoundPathVector) 
	;

BasePathVector returns PathVector
	: basePath=Path '[' ( paths+=Path (',' paths+=Path)*)? ']' ';'
	;

UnbasedPathVector returns PathVector
	: paths+=Path (',' paths+=Path)* ';'
	;
	
CompoundPathVector returns CompoundPathVector: '{' body+=PathVectorElement* '}' ;

/*
* A path can be written without quotes if it consists of safe chars 
* TODO: repace use of ID with better definition.
* TODO: Validation of path syntax (MS, n*x) ?
*/
Path hidden()
	: STRING
	| ('/')? QualifiedName ('/' QualifiedName)* ('/')? // HIDDENBUG
	;

Prerequisite
	: ((surpressed ?= 'hidden')? ('when' filter=Filter )? (alias=ID '=')? ((partReference=PrerequisiteEntry) 
	 (closure = Closure)?)) ';'
	;
	
Closure : 'with' '{'
			('properties' properties = CompoundPropertyOperation )? 
			( 'advice' advice = CompoundAdvice)?
		'}'
		;
		
PrerequisiteEntry 
	: PartInSelf
	| CapabilityReferencedPart
	| CompoundReferences
	;
	
PartInSelf	: partName=PartName  // i.e. self#partName
	;
	
CapabilityReferencedPart
	: interface=InterfaceName '/' name=UnitName ('/' range=VersionRange)? '#' partName=PartName
	| interface=InterfaceName '/' name=UnitName ('/' range=VersionRange)?
	;
	
CompoundReferences
	: '{' (prerequisites += Prerequisite)* '}'
	;
Part returns Part: (visibility = Visibility)?
      (executionMode = ExecutionMode)?
	 PartName
		( 'provides' providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)*  )?
	(preCondition = PreCondition)?
	(postCondition = PostCondition)?
	 '{'
		('properties' properties = CompoundPropertyOperation)?
	     ( advice = Advice )?
	     ( group = Group )? 
	     ( layout = Layout )?
	     (statements = Statements)?
	 '}'
	;

Parameter : val = Expression ;
	
Layout returns Layout
	: 'layout' (postCondition = PostCondition)? '{' (body = PathGroup)? '}' 
	;
	
Group
	: 'group' (preCondition = PreCondition)? (postCondition = PostCondition)?	 
		'{' (prerequisites += Prerequisite)* '}'
	;

RepositoryConfiguration
	: (location=URI | 'resolver' resolverClass=QualifiedName ) (advice=CompoundAdvice)? ';'
	;

/*
** URI TODO: Would like to have better parsing of URL - don't know if possible to push this to lexer
** as we may want to support namespaces (using 'ns:' prefix) (for importing b3 files, common advice, rules etc.).
** The ':' clashes with 'scheme:' which is the only known part in an opaque URI. 
*/
URI : STRING
	;

/* ADVICE
** TODO: Had to use '?' instead if '*', and '??' intead of '**' as these operators are intermixed with / which sometimes
** makes them look like comments. (Forbidding // comments is not the wanted sollution). 
**
*/
NamedAdvice 
	: (name=ID)? advice=CompoundAdvice ;

Advice : 'advice' CompoundAdvice ;

CompoundAdvice : '{' (advice += AdviceStatement ';')* '}' ;

AdviceStatement :  path = AdvicePath ((op=AssignmentOperator value=Expression) | advice=CompoundAdvice) ;

// a | ** | [foo==bar] | .. | a 
// a:**:[foo==bar]:..:a
	
AdvicePath
	: (absolute?=':')? selectors+=Selector (':' selectors+=Selector)* 
	;

Selector returns Selector
	: DiscriminatingSelector | MultiNodeSelector | NodeSelector 
	;
MultiNodeSelector returns Selector
	: NameSelector | ThisSelector | ChildrenSelector | AncestorSelector | RegexpSelector
	;
DiscriminatingSelector returns Selector
	: selector=MultiNodeSelector '[' predicate=Expression ']' 
	;
NodeSelector returns Selector
	: ParentSelector 
	;

	 
NameSelector returns NameSelector: name=QualifiedName ;
ThisSelector returns ThisSelector: {ThisSelector} '.' ;
ParentSelector returns ParentSelector: {ParentSelector} '..' ;
ChildrenSelector returns ChildrenSelector: {ChildrenSelector} '*' ;
AncestorSelector returns AncestorSelector: {AncestorSelector} '**' ;
RegexpSelector returns RegexpSelector: {RegexpSelector} pattern=REGEX ;

WildcardNode : '*' ('*')? ;

Filter : '(' predicate = Expression ')' ;

/* ASSERTS */
PreCondition : "precondition" '{' (asserts += AssertionExpression)* '}' ;
PostCondition : "postcondition" '{' (asserts += AssertionExpression)* '}' ;

AssertionExpression : 'assert' expr=Expression (',' message=STRING)? ';' 
;

/* STATEMENTS */
Statement
	: IfStatement
	| SwitchStatement
	| WhileStatement
	| ForStatement
	| DoWhileStatement
	| CompoundStatement
	| (VarExpression)? ';'
	| BreakStatement
	| ContinueStatement
	| ReturnStatement
	| FunctionStatement
	| LabelStatement
	| ThrowStatement
	| TryCatchStatement
	| WithStatement
	;
	
BreakStatement : {BreakStatement} 'break' (label=ID)? ';' ;
ContinueStatement : {ContinueStatement} 'continue' (label=ID)? ';' ;

CompoundStatement : '{' statements = Statements '}' ;

Statements : (statements += Statement)+ ;

WhileStatement : 'while' '(' condition=Expression ')' body=Statement ;

SwitchStatement
	: "switch" "(" switchExpr=VarExpression ")"
		"{" case+=Case* ("default" ":" (statements=Statements)?)? "}";
		
Case: "case" condition=ValueLiteral ":" (statements=Statements)?;

// TODO: needs validation that expression list only has one entry and is a LHS value
// if inLoop == true. Needs validation that RHS is a collection item if inLoop == true.
//
ForStatement : {ForStatement} "for" '(' (init=VarExpressionList)? 
	( (regular ?= ';' (cond=Expression)? ';' (iterate=ExpressionList)?) 
	| ("in" iterate=Expression )
	)
	')'  
	body = Statement
	;
	
DoWhileStatement : 'do' statement = Statement 'while' '(' condition=Expression ')' ';' ;


ReturnStatement 
	: 'return' return=Expression ';'
	;
FunctionStatement
	: "function" name=ID '(' (params += ID (',' params += ID)*) ')' 
		'{' statements = Statements '}'
	;

IfStatement 
	: "if" '(' cond = Expression ')' then = Statement ("else" else= Statement)?
	;
	
LabelStatement :  name=ID ":" statement = Statement ;

ThrowStatement: "throw" expr=Expression ";" ;

TryCatchStatement 
	: "try" tryBlock = CompoundStatement 
		((catchBlock = CatchBlock (finallyBlock=FinallyBlock)?) | finally=FinallyBlock)
		;
		
CatchBlock: "catch" '(' variable = ID ')' catchBlock = CompoundStatement ;
FinallyBlock: "finally" finallyBlock = CompoundStatement ;
		
WithStatement : "with" '(' expr=Expression ')' statement = Statement;
		
/* EXPRESSIONS */
enum AssignmentOperator 
	: SET = '=' 		| SET_PLUS ='+='	| SET_MINUS ='-='		| SET_MUL='*='	| SET_DIV='/='
	| SET_MOD= "%=" 	| SET_AND = "&=" 	| SET_XOR = "^=" 		| SET_OR= "|=" 
	| SET_LSHIFT="<<=" 	| SET_RSHIFT=">>=" 	| SET_RSHIFT_0= ">>>=" 
	;
	
enum RelationalOperator 
	: EQ_MATCHES="~=" 	| EQ="==" 		| EQ_IDENTITY="==="	| EQ_NOT="!=" 	| EQ_NOT_IDENTITY="!=="
	| EQ_GTEQ=">=" 		| EQ_LEEQ="<=" 	| EQ_GT=">" 		| EQ_LT= "<"
	| EQ_INSTANCEOF="instanceof" 
	;

VarExpressionList : expr +=VarExpression ( ',' expr+=VarExpression)* ;
ExpressionList : expr +=Expression ( ',' expr += Expression)* ;

// Assignment is optional i JS
// Also makes it possible to use VarExpression in a for(var a in xxx) loop
//
VarExpression returns Expression: Expression | {VarExpression}'var' name=ID ('=' value=Expression)? ;


//Expression returns Expression: value = AssignmentExpression ;
Expression returns Expression: AssignmentExpression ;

AssignmentExpression returns Expression:
	 IfExpression ({AssignmentOperation.left=current} op=AssignmentOperator right=AssignmentExpression)?
	;

//ChainExpression returns Expression:
//	ChainedExpression //({ChainExpression.first=current} ',' next=ChainedExpression)*
//	;
	
ChainedExpression returns Expression:
	IfExpression;
 
IfExpression returns Expression:
	OrExpression ({IfExpression.condition=current} "?" thenPart=ChainedExpression ":" elsePart=ChainedExpression)?;
	 
OrExpression returns Expression:
	AndExpression ({BooleanOperation.left=current} operator="||" right=AndExpression)*;
	
AndExpression returns Expression:
	BitwiseExpression ({BooleanOperation.left=current} operator="&&" right=BitwiseExpression)*;

BitwiseExpression returns Expression :
	RelationalExpression ({OperationCall.params+=current} name=("&" | "^" | "|") params+=RelationalExpression)*;
	
RelationalExpression returns Expression:
	ShiftExpression ({RelationalOperation.left=current} operator=RelationalOperator right=ShiftExpression)*;

ShiftExpression returns Expression:
	AdditiveExpression ({OperationCall.params+=current} name=("<<" | ">>" | ">>>") params+=AdditiveExpression)*;
	
AdditiveExpression returns Expression:
	MultiplicativeExpression ({OperationCall.params+=current} name=("+" | "-") params+=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	UnaryOrInfixExpression ({OperationCall.params+=current} name=("*" | "/" | "%") params+=UnaryOrInfixExpression)*;

UnaryOrInfixExpression returns Expression
	: UnaryExpression 
	| PostopExpression
	; 

UnaryExpression :
	 {UnaryOperation} name=("!" | "-" | "++" | "--" | "typeof" | "delete" | "~") params+=PostopExpression;

PostopExpression returns Expression:
	InfixExpression ({OperationCall.postTarget=current} name = ("--" | "++"))?
	;

	
InfixExpression returns Expression:
	CallExpression ( 
	  	({OperationCall.target=current} "." name=ID  "(" (params+=Parameter ("," params+=Parameter)*)? ")")
	  |	({AtCall.target=current} '[' index=Expression ']'
	  		("(" (params+=Parameter ("," params+=Parameter)*)? ")")?) 	  
	  | ({FeatureCall.target=current} "." type=ID)
	)*;
	
CallExpression returns Expression: 
	PrimaryExpression ( 
		({OperationCall.target=current}"(" (params+=Parameter ("," params+=Parameter)*)? ")"))*
		;
		
PrimaryExpression returns Expression
	: Literal 
//	| FeatureCall 
	| ConstructorCallExpression
	| VariableValue
	| PropertyValue
	| KeywordVariables
	| ParanthesizedExpression
	;

PropertyValue returns  Expression: {PropertyValue} name = PID;
VariableValue returns  Expression: {VariableValue} name = ID ;
KeywordVariables returns  Expression: {KeywordVariable} name = ("group" | "layout" | "properties") ;

//FeatureCall:
//	OperationCall
//	;
//	
//OperationCall 
//	: name=(ID|PID) "(" (params+=Parameter ("," params+=Parameter)*)? ")" 
//	;

ConstructorCallExpression returns Expression
	: {CreatorCall} name='new' target=QualifiedName '(' (params+=Parameter ("," params+=Parameter)*)? ")" 
	;
	
Literal returns Expression
	: ValueLiteral
	| RegexpLiteral
	| LiteralArray
	| LiteralObject
	| LiteralFunction
	;
	
LiteralArray returns  Expression: {LiteralArray} '[' (element += Expression (',' element += Expression)* )? ']' ;
LiteralObject returns  Expression: {LiteralObject} '{' (features += Feature (',' features += Feature)* )? '}' ;
LiteralFunction returns Expression
	: {LiteralFunction} "function" '(' (parameters += ID (',' parameters += ID)*) ')' 
		'{' statements = Statements '}'
	;

Feature returns Feature: {Feature} name = (ID|PID|STRING) ':' value= Expression ;

ValueLiteral returns Expression
	: BooleanLiteral 
	| IntegerLiteral 
	| NullLiteral 
	| UndefinedLiteral
	| StringLiteral
	| RealLiteral
	| QueryLiteral
	;
	
BooleanLiteral returns  Expression: {BooleanLiteral} val=("true" | "false");
// TODO: Hex is a string until an int converter is written for it
IntegerLiteral returns  Expression: {IntegerLiteral} (ival = INT)|(sval=HEX);
NullLiteral	returns  Expression: {NullLiteral} val="null";
// Not a keyword in JS, but prevention of reassignment is wanted.
UndefinedLiteral returns  Expression: {UndefinedLiteral} val="undefined";
StringLiteral returns  Expression: {StringLiteral} val = STRING;
RealLiteral	returns  Expression: {RealLiteral} val = REAL;
RegexpLiteral returns Expression: {RegexpLiteral} val = REGEX;
QueryLiteral returns Expression: {QueryLiteral} '~{' val = AdvicePath '}' ;
	
ParanthesizedExpression returns Expression
	:  "(" Expression ")"
	;	


