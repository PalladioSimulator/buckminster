grammar org.eclipse.b3.BeeLang with org.eclipse.xtext.common.Terminals

generate beeLang "http://www.eclipse.org/b3/BeeLang"

BeeModel : (imports += Import)* body = Unit ;

// Redeclare the default ID without the ^ keyword escape mechanism
terminal ID : (('a'..'z')|('A'..'Z')|('_')) (('a'..'z')|('A'..'Z')|('0'..'9')|('_'))* ;

// Qualified name
// TODO: Needs to disallow whie space between ID and '.', and no embedded comments. A bug in xtext prevents using hidden() here.
//
QualifiedName hidden(): ID ('.' ID)* HIDDENBUG;
HIDDENBUG hidden(WS, SL_COMMENT, ML_COMMENT): ('~~~~~')? ; // TODO: REPLACE HACK WHEN HIDDEN WORKS.

EscapedQualifiedName:  STRING | QualifiedName;
InterfaceName: QualifiedName ;

// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
// do not allow being broken across lines.
//
CompoundName : EscapedQualifiedName '/' EscapedQualifiedName ;

// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
UnitName : EscapedQualifiedName;
PartName : EscapedQualifiedName;

enum Visibility 	: public | private ;
enum AssertionScope : precondition | postcondition ;
enum ExecutionMode 	: parallel | sequential ;

// Version, and VersionRange
// TODO: make it into a datatype and have better rules, syntax coloring (now integer parts are colored grey, other parts are not colored), etc.
// TODO: uncertain if the set of allowed chars is definitive.
//
Separator : '.' | '-' | '!' | '@' | '$' | '%' | '&' | '/' | '+' | '=' | '*' | '<' | '>' | ':' | '?';
AlfanumSym : (ID | INT) (Separator|ID|INT)* ;

Version
	: STRING
	| AlfanumSym
	;

/*
** VersionRange TODO: Uses two instances of Version. This works because use of [Ê]  ( ) must be escaped with " " in Version. Omni
** version uses version strings with \[ when a range is presented/parsed in string format.
*/
VersionRange
	: ('[' | '(') Version (',' Version)? (']'|')')
	| Version
	;

/*
** Import
** TODO: Is specified as import of URI, a String, should be QID
*/	
Import :
	'import' importClass=QualifiedName ('.*')? ';' ; 
		
/* UNIT - the body (compare to java class)
*/	
Unit returns BuildUnit hidden(WS, ML_COMMENT, SL_COMMENT) :
	(executionMode = ExecutionMode)?
	'unit' (name=UnitName)? ('version' version = Version)?
		('implements' implements += InterfaceName (',' implements+=InterfaceName)*)? 
	'{'
		(	//-- PROPERTIES
			// goes first, because they may be used in the other clauses.
			//
			  ('properties'  propertyStatements += NamedPropertyStatements)
//			| (propertyStatements += SinglePropertyStatement)
		)*
		( 	//-- PROVIDES
			  ('provides' '{' (providedCapability += ProvidedCapability ';')+ '}')
			| ('provides' providedCapability += ProvidedCapability ';')
			//-- REQUIRES & META REQUIRES
			| ('requires' '{' (requiredCapabilities += RequiredCapability ';')+ '}')
			| ('requires' requiredCapabilities += RequiredCapability ';')
			| ('meta' 'requires' '{' (metaRequiredCapabilities += RequiredCapability ';')+ '}' )
			| ('meta' 'requires' metaRequiredCapabilities += RequiredCapability ';')
			//--ADVICE
			| ('advice' advice+=NamedAdvice )
			//--SYNCHRONIZE
			| ('sequential' '{' (synchronize += Synchronization )+  '}' )
			| ('sequential' synchronize += Synchronization  )
			//--PARTS
			| (parts += BuildPart )			
			//-- REPOSITORIES
			| ('repositories' '{' (repositoryConfig+=RepositoryConfiguration)* '}' )
		)*
	'}';
	

	
ProvidedCapability : ('when' filter=Filter)? interface=QualifiedName '/' name=QualifiedName  ('/' version=Version)?  ;
RequiredCapability : ('when' filter=Filter)? interface=QualifiedName '/' name=QualifiedName ('/' range=VersionRange)?  ;

// An optionally named sequence of property statements
NamedPropertyStatements returns PropertyStatements
	: (name = QualifiedName)? statements = PropertyStatements ;
//		( (statements += UnsetPropertyStatement |  statements += PropertyStatement)* ) '}'
//	;

// Sequence of property statements	
PropertyStatements returns PropertyStatement
	:  '{' 
		( ('when' filter=Filter)? 
			  (statements += UnsetPropertyStatement 
			| statements += PropertyStatement
			| statements += PropertyStatements
		) 
		)* '}'
	;
	
PropertyStatement
	: ( (local ?= 'local' )? (immutable ?= 'immutable')? key=QualifiedName '=' value=PropertyExpression ';')
	;

UnsetPropertyStatement returns PropertyStatement
	:  ('unset' unsetProperties += QualifiedName ';' )
	;

// identical to nested properties statement, but used to get a separate data type
AnnotationStatement returns PropertyStatement
	: (('when' filter=Filter)? (immutable ?= 'immutable')? key=QualifiedName '=' value=PropertyExpression ';')
	;


PropertyExpression : Expression ; 

Synchronization 
	: (partrefs += SynchronizedPart)(',' partrefs += SynchronizedPart)+ ';' // at least 2
	;
	
SynchronizedPart
	: CompoundName ('#' PartName)?
	| PartName
	;
	
BuildPart 
	: Artifacts
	| Group
	| Action
	;
	
Artifacts returns ArtifactsPart 
	: (visibility = Visibility)? 'artifacts' name=PartName
		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		(asserts += PostConditionAssert)?
		'{' (paths += PathGroup)* '}'
	;
	
/* PATH GROUP
* TODO: Allow basePath without paths?
* TODO: generated structure is wrong . should be in sequence, basepath and expr are out of band !!
*/
PathGroup 
	: ('when' filter=Filter)? 
		( paths+=PathExpression 
		    ( ((',' paths+=PathExpression)* ) 
		    | (firstIsBase ?='[' paths+=PathExpression (',' paths+=PathExpression)* ']')
		    ) ';'
//		| basePath=PathExpression '[' paths+=PathExpression (',' paths+=PathExpression)* ']' ';'
//		| ('expr' pathExpressions += Expression ';' ) 
		| ('annotations' '{' ('unset' unsetProperties += QualifiedName ';' |  setProperties += AnnotationStatement)+ '}' )
		)
	;

PathExpression : Path | ExprStatement ;

ExprStatement : 'expr'  expression = Expression  ;

/*
* A path can be written without quotes if it consists of safe chars 
* TODO: repace use of ID with better definition.
* TODO: Validation of path syntax (MS, n*x) ?
*/
Path hidden()
	: STRING
	| ('/')? QualifiedName ('/' QualifiedName)* ('/')? // HIDDENBUG
	;

Group returns GroupPart 
	: (visibility = Visibility)?
	  (executionMode = ExecutionMode)?
	  'group' name=PartName
		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		(asserts += PreConditionAssert)?
		(asserts += PostConditionAssert)?
		'{' ( prerequisites += Prerequisite )*
		'}'
	;

Prerequisite
	: ((surpressed ?= 'hidden')? ('when' filter=Filter )? (alias=QualifiedName '=')? ((partReference=PrerequisiteEntry) 
	 (closure = Closure)?) /*| (partReference=ExprStatement) */) ';'
	;
	
Closure : 'with' '{'
			( ('properties' '{' ('unset' unsetProperties += QualifiedName ';' |  setProperties += PropertyStatement)+ '}' )
			| ( 'advice' advice += CompoundAdvice)
			)*
		'}'
		;
		
PrerequisiteEntry 
	: PartInSelf
	| CapabilityReferencedPart
	| CompoundReferences
	| ExprStatement
	;
	
PartInSelf	: partName=PartName  // i.e. self#partName
	;
	
CapabilityReferencedPart
	: interface=InterfaceName '/' name=UnitName ('/' range=VersionRange)? '#' partName=PartName
	| interface=InterfaceName '/' name=UnitName ('/' range=VersionRange)?
	;
	
CompoundReferences
	: '{' (prerequisites += Prerequisite)* '}'
	;

Action returns ActionPart
	: (visibility = Visibility)?
      (executionMode = ExecutionMode)?
	 'action' PartName
	 'actor' QualifiedName '(' (actorParameters += Parameter (',' actorParameters += Parameter)*)? 
	 	('...' actorParameters += AnonymousParameter (',' actorParameters += AnonymousParameter)*)?')'
		( 'provides' providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)*  )?
	(asserts += PreConditionAssert)?
	(asserts += PostConditionAssert)?
	 '{'
		('properties' properties += PropertyStatements)?
	     ( advice = Advice )?
	     ( resultGroup = ActionInputGroup )? 
	     ( layout += Layout )*
	 '}'
	;

Parameter
	: name=QualifiedName '=' value= Expression
	;
	
AnonymousParameter 
	: Expression
	;
	
Layout returns Layout
	: ('when' filter=Filter)?  'layout' (name=QualifiedName )? 
//		(asserts += PreConditionAssert)? // precondition does not make sense
		(asserts += PostConditionAssert)?
	
		'{' (paths += PathGroup)* '}' 
	;
	
ActionInputGroup
	: 'group'
		(asserts += PreConditionAssert)?
		(asserts += PostConditionAssert)?	 
		'{' (prerequisites += Prerequisite)* '}'
	;

RepositoryConfiguration
	: (location=URI | 'resolver' resolverClass=QualifiedName ) (advice=CompoundAdvice)? ';'
	;

/*
** URI TODO: Would like to have better parsing of URL - don't know if possible to push this to lexer
** as we may want to support namespaces (using 'ns:' prefix) (for importing b3 files, common advice, rules etc.).
** The ':' clashes with 'scheme:' which is the only known part in an opaque URI. 
*/
URI : STRING
	;

/* ADVICE
** TODO: Had to use '?' instead if '*', and '??' intead of '**' as these operators are intermixed with / which sometimes
** makes them look like comments. (Forbidding // comments is not the wanted sollution). 
**
*/
NamedAdvice 
	: (name=QualifiedName)? advice=CompoundAdvice ;

Advice : 'advice' CompoundAdvice ;

CompoundAdvice : '{' (advice += AdviceStatement ';')* '}' ;

AdviceStatement :  path = AdvicePath (('=' value=Expression) | advice=CompoundAdvice) ;
		
AdvicePath
	: (pathElements+=AdvicePathSeparator)? pathElements+=AdvicePathElement 
		(pathElements+=AdvicePathSeparator pathElement+=AdvicePathElement)* 
	;

AdvicePathSeparator returns AdvicePathElement
	: AdvicePathChildren
	;
AdvicePathChildren 
	: {AdvicePathChildren} "/"
	;

AdvicePathElement
	: node=(QualifiedName | WildcardNode | '.') ('[' predicate=Expression ']')? 
	| node='..'
	;
	
WildcardNode : '?' ('?')? ;

Filter : '(' predicate = Expression ')' ;

/* ASSERTS */
PreConditionAssert : scope="precondition" '{' (asserts += AssertionExpression)* '}' ;
PostConditionAssert : scope="postcondition" '{' (asserts += AssertionExpression)* '}' ;

AssertionExpression : 'assert' expr=Expression (',' message=STRING)? ';' 
;
/* EXPRESSIONS */
SyntaxElement : Expression ;

Expression 
	: ValueExpression
	;

ValueExpression
	: value=OrExpression 
	;
	
//LetExpression:
//	"let" identifier=ID "=" varExpr=Expression ":" target=Expression;
	
OrExpression returns Expression:
	AndExpression ({BooleanOperation.left=current} operator="||" right=AndExpression)*;
	
AndExpression returns Expression:
	RelationalExpression ({BooleanOperation.left=current} operator="&&" right=RelationalExpression)*;

RelationalExpression returns Expression:
	AdditiveExpression ({BooleanOperation.left=current} operator=("~=" | "==" | "!=" | ">=" | "<=" | ">" | "<") right=AdditiveExpression)*;
	
AdditiveExpression returns Expression:
	MultiplicativeExpression ({OperationCall.params+=current} name=("+" | "-") params+=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	UnaryOrInfixExpression ({OperationCall.params+=current} name=("*" | "/") params+=UnaryOrInfixExpression)*;

	
UnaryOrInfixExpression returns Expression:
	UnaryExpression | InfixExpression; 

UnaryExpression returns OperationCall:
	name=("!" | "-") params+=InfixExpression;
	
InfixExpression returns Expression:
	PrimaryExpression (
		({OperationCall.target=current} ":" name=ID "(" (params+=Parameter ("," params+=Parameter)*)? 
			 	('...' paramsParameters += AnonymousParameter (',' paramsParameters += AnonymousParameter)*)? ")")  |
		({FeatureCall.target=current} ":" type=ID) // |
//		({TypeSelectExpression.target=current} "." name="typeSelect" "(" type=Type ")") |
//		({CollectionExpression.target=current} name=("collect"|"select"|"selectFirst"|"reject"|"exists"|"notExists"|"sortBy"|"forAll") "(" (var=ID "|")? exp=Expression ")")
	)*;

PrimaryExpression returns Expression
	: Literal 
	| FeatureCall 
//	ListLiteral |
//	ConstructorCallExpression |
	| GlobalVarExpression
	| ParanthesizedExpression
	;
FeatureCall:
	OperationCall //|
//	(type=Type) |
//	CollectionExpression | 
//	TypeSelectExpression
	;
	
OperationCall:
	name=QualifiedName "(" (params+=Parameter ("," params+=Parameter)*)? 
		('...' paramsParameters += AnonymousParameter (',' paramsParameters += AnonymousParameter)*)? 
	")"
	;
	
Literal:
	BooleanLiteral | IntegerLiteral | NullLiteral
	| StringLiteral;
	
BooleanLiteral: val=("true" | "false");
IntegerLiteral: val=INT;
NullLiteral:    val="null";
StringLiteral:	val=STRING;

ParanthesizedExpression returns Expression
	: "(" Expression ")"
	;	
	
GlobalVarExpression 
	: name=QualifiedName
	;
