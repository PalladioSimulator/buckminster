grammar org.eclipse.b3.BeeLang with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate beeLang "http://www.eclipse.org/b3/BeeLang"
BeeModel : (imports += Import)* body = Unit ;

// Redeclare the default ID without the ^ keyword escape mechanism, and including
// the JS $ char which is allowed in the first position.
//
terminal ID : (('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|('0'..'9')|'_')* ;

// Property Names start with $ and are qualified. Must be handled by lexer as
// a.b.c is otherwise ambigous in expressions.

terminal PID : '$' ID ('.' ID)* ;

// JS Regexp - but cheating by using @ instead of / because of inability to push back terminators
// and / clashes with / in math.
//
terminal REGEX 
	: "~/" ( '\\' ('/'|'f'|'n'|'r'|'t'|'v'|'\\'|'.'|'*'|'+'|'?'
					| 'w'|'W'|'s'|'S'|'d'|'D'|'b'
					|'|'|'{'|'}'|'['|']'|'('|')'
					| (('0'..'7')('0'..'7')('0'..'7')) 
					| ('x' (('0'..'9')|('a'..'f')|('A'..'F')) (('0'..'9')|('a'..'f')|('A'..'F'))) 
					| ('c' ('A'..'Z'))
				)
			| (!('\\'|'/'|' '|'\t'|'\r'|'\n')))* "/" ('g'|'m'|'i')?
			;

// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
// A string converter may need to handle the u, x, and octal escapes.
// Regular java string handles XXXX , and gives syntax error if
// format is not ok, the other two remains, and possibly the null.
terminal STRING :
'"' ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|'"'|'\r'|'\n') )* '"' |
"'" ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|"'"|'\r'|'\n') )* "'";

terminal ML_COMMENT : '/*' -> '*/' ;
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS : (' '|'\t'|'\r'|'\n')+ ;

// TODO: Should return EInt, but uncerain if converter handles hex
//
terminal HEX : '0' ('x'|'X')(('0'..'9')|('a'..'f')|('A'..'F'))+ ;

// A JS integer is one of
// 0
// 0(0..7)*
// 0(x|X)(0-91-fA-F)*
// Validation can handle the octal case, and illegal 08, 09 00 sequencese
// TODO: converter must handle octal case if we want to support it.
//
terminal INT returns ecore::EInt: ('0'..'9')+;

// TODO: should be a floating point value and have a converter
// and check for illegal INT sequences "000" etc.
// Suppressing REAL without a decimal (INT '.') as well as ('.' INT) as
// a real otherwise can look as part of an Qualified name ('a'.e+1), the
// combination 'n.n' is not valid in a name.
//
terminal REAL : ((INT '.' INT)|(INT '.')|('.' INT) | INT) (('e'|'E')('-'|'+')INT)? ;


terminal ANY_OTHER : . ;

// Qualified name
// TODO: Needs to disallow whie space between ID and '.', and no embedded comments. A bug in xtext prevents using hidden() here.
//
QualifiedName hidden(): ID (INT|HEX|ID)* ('.' ID (INT|HEX|ID)*)* HIDDENBUG;
HIDDENBUG hidden(WS, SL_COMMENT, ML_COMMENT): ('~~~~~')? ; // TODO: REPLACE HACK WHEN HIDDEN WORKS.


// Declare Property ID to include '.'
PROP hidden(): '$' '{' QualifiedName '}' ;

PropertyName : PID ;
EscapedQualifiedName:  STRING | QualifiedName;
InterfaceName: QualifiedName ;

// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
// do not allow being broken across lines.
//
CompoundName : EscapedQualifiedName '/' EscapedQualifiedName ;

// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
UnitName : EscapedQualifiedName;
PartName : EscapedQualifiedName;

enum Visibility 	: public | private ;
enum AssertionScope : precondition | postcondition ;
enum ExecutionMode 	: parallel | sequential ;

// Version, and VersionRange
// TODO: make it into a datatype and have better rules, syntax coloring (now integer parts are colored grey, other parts are not colored), etc.
// TODO: uncertain if the set of allowed chars is definitive.
//
Separator : '.' | '-' | '!' | '@' | '$' | '%' | '&' |'+' | '=' | '*' | '<' | '>' | ':' | '?';
AlfanumSym : (ID | INT |HEX|REAL) (Separator|ID|INT|HEX|REAL)* ;

Version
	: STRING  
	| AlfanumSym
	;

/*
** VersionRange TODO: Uses two instances of Version. This works because use of [ ]  ( ) in Version must be 
** escaped with " ". Omni
** version uses version strings with \[ when a range is presented/parsed in string format.
*/
VersionRange
	: ('[' | '(') Version (',' Version)? (']'|')')
	| Version
	;

/*
** Import
** TODO: Is specified as import of URI, a String, should be QID
*/	
Import :
	'import' importClass=QualifiedName ('.*')? ';' ; 
		
/* UNIT - the body (compare to java class)
*/	
Unit returns BuildUnit hidden(WS, ML_COMMENT, SL_COMMENT) :
	(executionMode = ExecutionMode)?
	'unit' (name=UnitName)? ('version' version = Version)?
		('implements' implements += InterfaceName (',' implements+=InterfaceName)*)? 
	'{'
		(	//-- PROPERTIES
			// goes first, because they may be used in the other clauses.
			//
			  ('properties'  propertyStatements += NamedPropertyStatements)
		)*
		( 	//-- PROVIDES
			  ('provides' '{' (providedCapability += ProvidedCapability ';')+ '}')
			| ('provides' providedCapability += ProvidedCapability ';')
			//-- REQUIRES & META REQUIRES
			| ('requires' '{' (requiredCapabilities += RequiredCapability ';')+ '}')
			| ('requires' requiredCapabilities += RequiredCapability ';')
			| ('meta' 'requires' '{' (metaRequiredCapabilities += RequiredCapability ';')+ '}' )
			| ('meta' 'requires' metaRequiredCapabilities += RequiredCapability ';')
			//--ADVICE
			| ('advice' advice+=NamedAdvice )
			//--SYNCHRONIZE
			| ('sequential' '{' (synchronize += Synchronization )+  '}' )
			| ('sequential' synchronize += Synchronization  )
			//--PARTS
			| (parts += BuildPart )			
			//-- REPOSITORIES
			| ('repositories' '{' (repositoryConfig+=RepositoryConfiguration)* '}' )
		)*
	'}';
	

	
ProvidedCapability : ('when' filter=Filter)? interface=QualifiedName '/' name=QualifiedName  ('/' version=Version)?  ;
RequiredCapability : ('when' filter=Filter)? interface=QualifiedName '/' name=QualifiedName ('/' range=VersionRange)?  ;

// An optionally named sequence of property statements
NamedPropertyStatements returns PropertyStatements
	: (name = ID)? statements = PropertyStatements 
	;

// Sequence of property statements	
PropertyStatements returns PropertyStatement
	:  '{' 
		( ('when' filter=Filter)? 
			  (statements += UnsetPropertyStatement 
			| statements += PropertyStatement
			| statements += PropertyStatements
		) 
		)* '}'
	;
	
PropertyStatement returns PropertyStatement 
	: ( (immutable ?= 'immutable')? key=PropertyName op=('='|'+='|'-='|'*='|'/=') value=PropertyExpression ';')
	;

UnsetPropertyStatement returns PropertyStatement
	:  ('unset' unsetProperties += PropertyName ';' )
	;

// identical to nested properties statement, but used to get a separate data type
AnnotationStatement returns PropertyStatement
	: (('when' filter=Filter)? (immutable ?= 'immutable')? key=PropertyName op=('='|'+='|'-='|'*='|'/=') value=PropertyExpression ';')
	;

PropertyExpression : Expression ; 

Synchronization 
	: (partrefs += SynchronizedPart)(',' partrefs += SynchronizedPart)+ ';' // at least 2
	;
	
SynchronizedPart
	: CompoundName ('#' PartName)?
	| PartName
	;
	
BuildPart 
	: Artifacts
	| Group
	| Action
	;
	
Artifacts returns ArtifactsPart 
	: (visibility = Visibility)? 'artifacts' name=PartName
		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		(asserts += PostConditionAssert)?
		'{' (paths += PathGroup)* '}'
	;
	
/* PATH GROUP
* TODO: Allow basePath without paths?
* TODO: generated structure is wrong . should be in sequence, basepath and expr are out of band !!
*/
PathGroup 
	: ('when' filter=Filter)? 
		( paths+=PathExpression 
		    ( ((',' paths+=PathExpression)* ) 
		    | (firstIsBase ?='[' paths+=PathExpression (',' paths+=PathExpression)* ']')
		    ) ';'
//		| basePath=PathExpression '[' paths+=PathExpression (',' paths+=PathExpression)* ']' ';'
//		| ('expr' pathExpressions += Expression ';' ) 
		| ('annotations' '{' ('unset' unsetProperties += PropertyName ';' |  setProperties += AnnotationStatement)+ '}' )
		)
	;

PathExpression : Path | ExprStatement ;

ExprStatement : 'expr'  '(' expression = Expression ')'  ;

/*
* A path can be written without quotes if it consists of safe chars 
* TODO: repace use of ID with better definition.
* TODO: Validation of path syntax (MS, n*x) ?
*/
Path hidden()
	: STRING
	| ('/')? QualifiedName ('/' QualifiedName)* ('/')? // HIDDENBUG
	;

Group returns GroupPart 
	: (visibility = Visibility)?
	  (executionMode = ExecutionMode)?
	  'group' name=PartName
		( 'provides'  providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* )?
		(asserts += PreConditionAssert)?
		(asserts += PostConditionAssert)?
		'{' ( prerequisites += Prerequisite )*
		'}'
	;

Prerequisite
	: ((surpressed ?= 'hidden')? ('when' filter=Filter )? (alias=ID '=')? ((partReference=PrerequisiteEntry) 
	 (closure = Closure)?) /*| (partReference=ExprStatement) */) ';'
	;
	
Closure : 'with' '{'
			( ('properties' '{' ('unset' unsetProperties += PropertyName ';' |  setProperties += PropertyStatement)+ '}' )
			| ( 'advice' advice += CompoundAdvice)
			)*
		'}'
		;
		
PrerequisiteEntry 
	: PartInSelf
	| CapabilityReferencedPart
	| CompoundReferences
	| ExprStatement
	;
	
PartInSelf	: partName=PartName  // i.e. self#partName
	;
	
CapabilityReferencedPart
	: interface=InterfaceName '/' name=UnitName ('/' range=VersionRange)? '#' partName=PartName
	| interface=InterfaceName '/' name=UnitName ('/' range=VersionRange)?
	;
	
CompoundReferences
	: '{' (prerequisites += Prerequisite)* '}'
	;

Action returns ActionPart
	: (visibility = Visibility)?
      (executionMode = ExecutionMode)?
	 'action' PartName
//	 'actor' QualifiedName '(' (actorParameters += Parameter (',' actorParameters += Parameter)*)? ')'
		( 'provides' providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)*  )?
	(asserts += PreConditionAssert)?
	(asserts += PostConditionAssert)?
	 '{'
		('properties' properties += PropertyStatements)?
	     ( advice = Advice )?
	     ( resultGroup = ActionInputGroup )? 
	     ( layout += Layout )*
	     statements = Statements
	 '}'
	;

Parameter : val = Expression ;
	
Layout returns Layout
	: ('when' filter=Filter)?  'layout' (name=QualifiedName )? 
//		(asserts += PreConditionAssert)? // precondition does not make sense
		(asserts += PostConditionAssert)?
	
		'{' (paths += PathGroup)* '}' 
	;
	
ActionInputGroup
	: 'group'
		(asserts += PreConditionAssert)?
		(asserts += PostConditionAssert)?	 
		'{' (prerequisites += Prerequisite)* '}'
	;

RepositoryConfiguration
	: (location=URI | 'resolver' resolverClass=QualifiedName ) (advice=CompoundAdvice)? ';'
	;

/*
** URI TODO: Would like to have better parsing of URL - don't know if possible to push this to lexer
** as we may want to support namespaces (using 'ns:' prefix) (for importing b3 files, common advice, rules etc.).
** The ':' clashes with 'scheme:' which is the only known part in an opaque URI. 
*/
URI : STRING
	;

/* ADVICE
** TODO: Had to use '?' instead if '*', and '??' intead of '**' as these operators are intermixed with / which sometimes
** makes them look like comments. (Forbidding // comments is not the wanted sollution). 
**
*/
NamedAdvice 
	: (name=ID)? advice=CompoundAdvice ;

Advice : 'advice' CompoundAdvice ;

CompoundAdvice : '{' (advice += AdviceStatement ';')* '}' ;

AdviceStatement :  path = AdvicePath (('=' value=Expression) | advice=CompoundAdvice) ;
		
AdvicePath
	: (pathElements+=AdvicePathSeparator)? pathElements+=AdvicePathElement 
		(pathElements+=AdvicePathSeparator pathElement+=AdvicePathElement)* 
	;

AdvicePathSeparator returns AdvicePathElement
	: AdvicePathChildren
	;
AdvicePathChildren 
	: {AdvicePathChildren} '/'
	;

AdvicePathElement
	: node=(QualifiedName | WildcardNode | '.') ('[' predicate=Expression ']')? 
	| node='..'
	;
	
WildcardNode : '?' ('?')? ;

Filter : '(' predicate = Expression ')' ;

/* ASSERTS */
PreConditionAssert : scope="precondition" '{' (asserts += AssertionExpression)* '}' ;
PostConditionAssert : scope="postcondition" '{' (asserts += AssertionExpression)* '}' ;

AssertionExpression : 'assert' expr=Expression (',' message=STRING)? ';' 
;

/* STATEMENTS */
Statement
	: SwitchStatement
	| WhileStatement
	| ForStatement
	| CompoundStatement
	| VarExpression ';'
	| BreakStatement
	| ContinueStatement
	| ReturnStatement
	;
	
BreakStatement : {BreakStatement} 'break' ';' ;
ContinueStatement : {ContinueStatement} 'continue' ';' ;

CompoundStatement : '{' statements = Statements '}' ;

Statements : (statements += Statement)* ;

WhileStatement : 'while' '(' condition=VarExpression ')' body=Statement ;

SwitchStatement
	: "switch" "(" switchExpr=VarExpression ")"
		"{" case+=Case* ("default" ":" statements=Statements)? "}";
		
Case: "case" condition=ValueLiteral ":" statements+=Statement;

ForStatement : {ForStatement} "for" '(' (init=VarExpressionList)? ';' (cond=Expression)? ';' (iterate=ExpressionList)? ')'
	body = Statement
	;
	
ReturnStatement 
	: 'return' return=Expression ';'
	;
	
/* EXPRESSIONS */
SyntaxElement : Expression ;

VarExpressionList : expr +=VarExpression ( ',' expr+=VarExpression)* ;
ExpressionList returns Expression: expr +=Expression ( ',' expr += Expression)* ;

VarExpression : Expression | 'var' name=ID '=' value=Expression ;

Expression : ValueExpression ;

ValueExpression 
	: value=AssignmentExpression
	;

//TODO: This is left associative, should be right...
AssignmentExpression returns Expression:
	 ChainExpression ({AssignmentOperation.left+=current} op=("=" | "+=" | "-=" | "*=" | "/=" | "%=" )
		right+=ChainExpression)*
	;


ChainExpression returns Expression:
	ChainedExpression //({ChainExpression.first=current} ',' next=ChainedExpression)*
	;
	
ChainedExpression returns Expression:
	IfExpression;
 
IfExpression returns Expression:
	OrExpression ({IfExpression.condition=current} "?" thenPart=ChainedExpression ":" elsePart=ChainedExpression)?;
	 
OrExpression returns Expression:
	AndExpression ({BooleanOperation.left=current} operator="||" right=AndExpression)*;
	
AndExpression returns Expression:
	RelationalExpression ({BooleanOperation.left=current} operator="&&" right=RelationalExpression)*;

RelationalExpression returns Expression:
	AdditiveExpression ({BooleanOperation.left=current} operator=("~=" | "==" | "!=" | ">=" | "<=" | ">" | "<") right=AdditiveExpression)*;
	
AdditiveExpression returns Expression:
	MultiplicativeExpression ({OperationCall.params+=current} name=("+" | "-") params+=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	UnaryOrInfixExpression ({OperationCall.params+=current} name=("*" | "/" | "%") params+=UnaryOrInfixExpression)*;

	
UnaryOrInfixExpression returns Expression:
	UnaryExpression | PostopExpression; 

UnaryExpression returns OperationCall:
	name=("!" | "-" | "++" | "--") params+=PostopExpression;

PostopExpression returns Expression:
	InfixExpression ({PostOpCall.target=current} name = ("--" | "++"))?
	;

	
InfixExpression returns Expression:
	PrimaryExpression ( 
	  	({OperationCall.target=current} "." name=ID  "(" (params+=Parameter ("," params+=Parameter)*)? ")")
	  |	({AtCall.target=current} '[' index=Expression ']'
	  		("(" (params+=Parameter ("," params+=Parameter)*)? ")")?) 	  
//	  ({OperationCall.target=current} name='[' nameExpr += Parameter ']' "(" (params+=Parameter ("," params+=Parameter)*)? ")") |
//	  ({FeatureCall.target=current} type="[" expr=Expression "]") |
	  | ({FeatureCall.target=current} "." type=ID)
//		({TypeSelectExpression.target=current} "." name="typeSelect" "(" type=Type ")") |
//		({CollectionExpression.target=current} name=("collect"|"select"|"selectFirst"|"reject"|"exists"|"notExists"|"sortBy"|"forAll") "(" (var=ID "|")? exp=Expression ")")
	)*;

//AtExpression returns Expression
//	: PrimaryExpression ( 
//		({AtCall.target=current} '[' feature=Parameter ']')
//		    ("(" (params+=Parameter ("," params+=Parameter)*)? ")")?
//		)*
//	;


PrimaryExpression returns Expression
	: Literal 
	| FeatureCall 
//	ListLiteral |
//	ConstructorCallExpression |
	| VariableValue
	| PropertyValue
	| ParanthesizedExpression
	;

PropertyValue : name = PID;
VariableValue : name = ID ;

FeatureCall:
	OperationCall //|
//	(type=Type) |
//	CollectionExpression | 
//	TypeSelectExpression
	;
	
OperationCall 
	: name=(ID|PID) "(" (params+=Parameter ("," params+=Parameter)*)? ")" 
	;
	
Literal
	: ValueLiteral
	| RegexpLiteral
	;
	
ValueLiteral
	: BooleanLiteral 
	| IntegerLiteral 
	| NullLiteral
	| StringLiteral
	| RealLiteral
	;
	
BooleanLiteral	: val = ("true" | "false");
IntegerLiteral	: val = INT|HEX;
NullLiteral		: val = "null";
StringLiteral	: val = STRING;
RealLiteral		: val = REAL;
RegexpLiteral	: val = REGEX;

	
ParanthesizedExpression returns Expression
	: "(" Expression ")"
	;	


